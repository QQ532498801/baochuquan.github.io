<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="包楚权,楚权,baochuquan,chuquan,iOS,前端,Objective-C,JavaScript" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="吸收、沉淀、积累">
<meta property="og:type" content="website">
<meta property="og:title" content="包楚权的博客">
<meta property="og:url" content="http://chuquan.me/page/3/index.html">
<meta property="og:site_name" content="包楚权的博客">
<meta property="og:description" content="吸收、沉淀、积累">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="包楚权的博客">
<meta name="twitter:description" content="吸收、沉淀、积累">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chuquan.me/page/3/"/>





  <title>包楚权的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?030cf08d5b27d756fa9aeecb1130fe13";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">包楚权的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Seek the wonder of life.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2017/01/08/https-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="包楚权">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/slamdunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="包楚权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/08/https-principle/" itemprop="url">HTTPS原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-08T21:34:51+08:00">
                2017-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTPS概述"><a href="#HTTPS概述" class="headerlink" title="HTTPS概述"></a>HTTPS概述</h1><hr>
<p>在互联网领域，安全永远是一个重点关注的方向。现阶段HTTPS的安全指数显然要比HTTP高很多，前者也是互联网发展的必然趋势。为了鼓励全球网站的HTTPS实现，Google甚至调整了其搜索引擎算法，提升HTTPS网站的搜索排名。<br>那HTTPS和HTTP到底有什么区别呢？简单而言，HTTPS可以认为是HTTP+TLS/SSL。  </p>
<h1 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h1><hr>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>我们都知道不使用SSL/TLS的HTTP通信，即不加密的通信。其具有以下几个潜在的风险：  </p>
<blockquote>
<p>(1) <strong>窃听风险</strong>（eavesdropping）：第三方可获知通信内容。<br>(2) <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。<br>(3) <strong>冒充风险</strong>（pretending）：第三方可以冒充他人进行通信。  </p>
</blockquote>
<p>而SSL/TLS的作用就是解决上述几个潜在的风险：</p>
<blockquote>
<p>(1) 所有信息都是<strong>加密传播</strong>，第三方无法窃听。<br>(2) 具备<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。<br>(3) 配备<strong>身份整数</strong>，防止身份被冒充。  </p>
</blockquote>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>互联网加密通信协议的历史，几乎与互联网的历史一样长。  </p>
<blockquote>
<p>1994年，NetScape公司设计了SSL协议（Secure Socket Layer）的1.0版本，但是未发布。<br>1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。<br>1996年，SSL 3.0版本问世，得到大规模应用。<br>1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版<a href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer" target="_blank" rel="noopener">TLS</a> 1.0版本。<br>2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版本和TLS 1.2版本。最新的变动是2011年TLS 1.2的<a href="https://tools.ietf.org/html/rfc6176" target="_blank" rel="noopener">修订版</a></p>
</blockquote>
<p>目前，应用最广泛的是TLS 1.0，然后是SSL 3.0。不过，主流浏览器都已经实现了对TLS 1.2的支持。<br>通常，TLS 1.0会被标示为SSL 3.1，TLS 1.1会被标示为TLS 1.2会被标示为SSL 3.3。  </p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>SSL/TLS协议的基本思路是采用<a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">公钥加密法</a>，即：客户端先向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，使用私钥解密。<br>而这个过程中需要解决两个问题：<br>(1) 如何保证公钥不被篡改？  </p>
<blockquote>
<p><strong>解决方法</strong>：将公钥放在<a href="https://en.wikipedia.org/wiki/Public_key_certificate" target="_blank" rel="noopener">数字证书</a>中。只要证书是可信的，公钥就是可信的。  </p>
</blockquote>
<p>(2) 公钥加密法作为一种非对称加密算法，计算量比对称加密算法大很多，如何减少耗费时间？  </p>
<blockquote>
<p><strong>解决方法</strong>：每次会话（session），客户端和服务器端都生成一个”<strong>会话密钥</strong>“（session key），用它来加密信息。这里，客户端仅用公钥加密”会话密钥”，而通信过程中的大量信息则用”会话密钥”来加密，由于大量使用对称加密算法，所以可以大幅减少加密运算的时间。</p>
</blockquote>
<p>因此，SSL/TLS协议的基本过程如下：  </p>
<blockquote>
<p>(1) 客户端向服务器索取并验证公钥。<br>(2) 双方协商生成”会话密钥”。<br>(3) 双方采用”会话密钥”进行加密通信。  </p>
</blockquote>
<p>其中，(1)(2)又称为”<strong>握手阶段</strong>“（handshake）。  </p>
<h2 id="握手阶段"><a href="#握手阶段" class="headerlink" title="握手阶段"></a>握手阶段</h2><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/SSL-TLS-handshake.png" alt=""></div>

<p>如上图所示，”握手阶段”包含<strong>4次通信</strong>。而”握手阶段”的所用通信都是<strong>明文</strong>的。<br>下面分别介绍”握手阶段”的4次通信过程。  </p>
<h3 id="客户端发出请求-ClientHello"><a href="#客户端发出请求-ClientHello" class="headerlink" title="客户端发出请求(ClientHello)"></a>客户端发出请求(ClientHello)</h3><p><strong>ClientHello请求</strong>: 客户端（通常是浏览器）先向服务器发出加密通信的请求。<br>在这一步，客户端主要向服务器提供以下信息：  </p>
<blockquote>
<p>(1) 支持的协议版本，如TLS 1.0版本。<br>(2) 一个客户端生成的随机数，稍后用于生成”会话密钥”。<br>(3) 支持的加密方法，如RSA公钥加密。<br>(4) 支持的压缩方法。  </p>
</blockquote>
<p>需要注意的是，客户端发送的信息之中不包括服务器的域名。即理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。  </p>
<p>但是，这对于虚拟主机用户来说，极为不便。为此，2006年，TLS协议加入了一个<a href="https://tools.ietf.org/html/rfc4366" target="_blank" rel="noopener">Server Name Indication扩展</a>，允许客户端向服务器提供它所请求的域名。  </p>
<h3 id="服务器回应-ServerHello"><a href="#服务器回应-ServerHello" class="headerlink" title="服务器回应(ServerHello)"></a>服务器回应(ServerHello)</h3><p><strong>ServerHello</strong>: 服务器收到客户端请求后，向客户端发出回应。<br>在这一步，服务器端的回应包含以下内容：  </p>
<blockquote>
<p>(1) 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>(2) 一个服务器生成的随机数，稍后用于生成”会话密钥”。<br>(3) 确认使用的加密方法，如RSA公钥加密。<br>(4) 服务器证书。  </p>
</blockquote>
<p>除了以上信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。  </p>
<h3 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h3><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。  </p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。  </p>
<blockquote>
<p>(1) 一个随机数。该随机数用服务器公钥加密，防止被窃听。<br>(2) 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>(3) 客户端握手结束通知，表示客户端的握手阶段已经结束。本项的值为前面发送的所有内容的hash值，用于服务器校验，以防被篡改。  </p>
</blockquote>
<p>此过程中出现的随机数是整个握手阶段出现的第三个随机数，又称”<strong>premaster secret</strong>“。经过这个过程之后，服务器端和客户端就同时拥有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”<strong>会话密钥</strong>“。  </p>
<p>但是为什么一定要用三个随机数来生成”会话密钥”呢？CSDN的<a href="http://blog.csdn.net/dog250/article/details/5717162" target="_blank" rel="noopener">dog250</a>给出如下解释：  </p>
<blockquote>
<p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入随机因素来保证协商出来的密钥的随机性。<br>对于RSA密钥交换算法来说，premaster secret本身就是一个随机数，再加上hello消息中的随机数，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>Premaster secret的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么premaster secret就有可能被才出来，那么仅适用premaster secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上premaster secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机数可能完全不随机，可是三个伪随机数就十分接近随机了。”  </p>
</blockquote>
<p>此外，如果前一步，服务器要求客户端提供证书，客户端会在这一步发送证书及其相关信息。  </p>
<h3 id="服务器回应"><a href="#服务器回应" class="headerlink" title="服务器回应"></a>服务器回应</h3><p>服务器收到客户端的第三个随机数premaster secret之后，计算本次会话所需的”会话密钥”。<br>然后，向客户端发送以下信息：  </p>
<blockquote>
<p>(1) 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>(2) 服务器握手结束通知，表示服务器的握手阶段已经结束。本项的值为前面发送的所有内容的hash值，用于服务器校验，以防被篡改。  </p>
</blockquote>
<p>至此，整个握手阶段全部结束。<br>接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。  </p>
<h2 id="数字签名和数字证书"><a href="#数字签名和数字证书" class="headerlink" title="数字签名和数字证书"></a>数字签名和数字证书</h2><p>我们回顾一下SSL/TLS握手阶段的整个过程的一些关键点，来看看其中是否还有潜在的风险。  </p>
<blockquote>
<p>(1) 客户端产生一个随机数A，以明文方式发给服务器。<br>(2) 服务器产生一个随机数B，以明文方式发给客户端。此外，服务器还将公钥放入证书中发送给客户端。<br>(3) 此时客户端拥有随机数A，B以及证书（公钥）。服务器拥有随机数A，B以及其私钥。<br>(4) 客户端产生一个随机数C，使用公钥加密，发送给服务器，服务器以私钥解密，得到随机数C。此过程使用公钥加密法（非对称加密）。<br>(5) 此时客户端和服务器使用三个随机数A，B，C，生成相同的成对的”会话密钥”。<br>(6) 此后，客户端和服务器端进行通信采用”会话密钥”进行加密通信（对称加密），可以减少加解密时间，提高通信速度。  </p>
</blockquote>
<p>那么问题来了，步骤(2)中的证书是如何防止被窃听和篡改的呢？这个过程中似乎没有采用任何算法对其进行加密保护。我们知道随机数A，B作为明文可以被窃听，而如果证书也被篡改，恶意的第三方甚至就可以向用户提供自己的证书（公钥），将自己伪装成客户端想要通信的对象。最终可以获取用户的信息，达到其进一步的目的。  </p>
<p>因此，客户端需要一种机制来确认其请求的服务器是否伪造的。而数字证书就像身份证一样可以证明服务器的真伪。  </p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书由专门的机构”<strong>证书中心</strong>“（Certificate authority，简称CA）颁发。证书中心用自己的私钥，将服务器的公钥及其相关信息进行加密，生成”<strong>数字证书</strong>“（Digital Certificate）。  </p>
<p>客户端（浏览器）的”<strong>证书管理器</strong>“，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/certificate-list.png" alt=""></div>  

<p>如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/certificate-warning.png" alt=""></div>  

<p>如果这张数字证书不是由受信任的机构颁发，浏览器会发出另一种警告。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/certificate-confirm.jpg" alt=""></div>  

<p>如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，从而进行后续的通信加密相关操作。  </p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>除了数字证书以外，我们经常还能看到的”<strong>数字签名</strong>“（Digital signature）又是什么呢？  </p>
<p>数字签名是将公钥密码反过来使用。签名者将信息用私钥加密（这是一种反用，因为通常私钥是用于解密）；验证者使用公钥解密信息。也就是说，客户端向服务器端发送消息是一种正向的公钥加密法（公钥加密，私钥解密）；而服务器端向客户端发送消息则是一种公钥加密法的反向实现（私钥加密，公钥解密）。  </p>
<p>数字签名的目的是为了防止通信内容被修改。<br>通信过程中，信息发送方对通信内容进行hash，并将产生hash值作为通信内容的摘要（digest）。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/hash-digest.png" alt=""></div>  

<p>然后，使用私钥将摘要进行加密，得到数字签名。而接收端使用公钥即可解密得到摘要。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/digest-signature.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/signature-digest.png" alt=""></div>  

<p>最终，客户端将通信内容进行hash，并与解密后得到的摘要进行比对，如果一致则表示内容未被篡改。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/digest-compare.png" alt=""></div>  

<p>（完）</p>
<p>参考<br>[1] <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a><br>[2] <a href="http://blog.csdn.net/dog250/article/details/5717162" target="_blank" rel="noopener">SSL协议中的DH算法的pre-master-secret</a><br>[3] <a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名是什么？</a><br>[4] <a href="https://zh.wikipedia.org/zh-hans/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0" target="_blank" rel="noopener">数字签名</a><br>[5] <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS</a>  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2017/01/05/read-books/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="包楚权">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/slamdunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="包楚权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/05/read-books/" itemprop="url">【我的阅读轨迹】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-05T19:26:11+08:00">
                2017-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生活/" itemprop="url" rel="index">
                    <span itemprop="name">生活</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>回看过去三个月，从10月中旬开始毕设换题，到现在2017年初，自己一直忙于毕设相关事宜，几乎没有挤出一些时间来提升自己。为了能够改变现在的生活状态，写下这篇博文以长期记录自己的阅读轨迹，希望能够以此鞭策自己不断地阅读、学习、思考、成长。  </p>
</blockquote>
<h1 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h1><h2 id="《黑客与画家》"><a href="#《黑客与画家》" class="headerlink" title="《黑客与画家》"></a>《黑客与画家》</h2><ul>
<li>时间: 1月3日至1月16日，一遍完</li>
<li>简评: 硅谷创业之父Paul Graham的散文集，描述了作者对社会现象、人生、技术、创业等方面的一些自己独特的见解。虽然本书并没有围绕具体某个主题展开，但是作者不时地传达出“Think Different”的思想，非常好的一本书。<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/hacker-and-painter01.jpg" alt=""></div>

</li>
</ul>
<h2 id="《Webkit技术内幕》"><a href="#《Webkit技术内幕》" class="headerlink" title="《Webkit技术内幕》"></a>《Webkit技术内幕》</h2><ul>
<li>时间: 1月17日至今，未读完<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/webkit-tech01.jpg" alt=""></div>

</li>
</ul>
<h2 id="《启示录-打造用户喜爱的产品》"><a href="#《启示录-打造用户喜爱的产品》" class="headerlink" title="《启示录 打造用户喜爱的产品》"></a>《启示录 打造用户喜爱的产品》</h2><ul>
<li>时间: 2月9日至2月19日，一遍完</li>
<li>简评: 本书分为三大部分：人员，流程，产品。人员部分主要介绍了围绕一款产生的设计、开发、发布、管理需要进行的人员配置，这方面非常适合类似相管理等职位的人来阅读；流程部分则介绍了产品诞生的过程中，以产品经理为中心，如何处理和协调整个过程；产品部分则是关于作者根据自己30年从业经验给产品经理的一些意见和建议。总体来说，本书对于产品经理是一本非常有价值的指导手册。希望有时间能够再次拜读此书，汲取其精华，写一点自己的得心体会。<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/inspired01.jpg" alt=""></div>

</li>
</ul>
<h2 id="《从0到1-开启商业与未来的秘密》"><a href="#《从0到1-开启商业与未来的秘密》" class="headerlink" title="《从0到1 开启商业与未来的秘密》"></a>《从0到1 开启商业与未来的秘密》</h2><ul>
<li>时间: 2月19日至5月1日</li>
<li>简评: 作者是Paypal的创始人之一，本文与《黑客与画家》类似，每一章都一个主题，但整本书始终围绕着如何创业、如何打造一个成功的企业来阐述作者的观点。<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/from-zero-to-one.jpg" alt=""></div>

</li>
</ul>
<h2 id="《Objective-C编程》"><a href="#《Objective-C编程》" class="headerlink" title="《Objective-C编程》"></a>《Objective-C编程》</h2><ul>
<li>时间: 7月11日至7月13日</li>
<li>简评: 入职后转岗iOS开发，Mentor指引了一条学习路线，首先看《Object-C编程》这本书。此书非常适于iOS开发入门，主要介绍Object-C的语法及相关概念。题外话：不得不说人的潜能真的是难以置信，三天看完了一本380页的技术书，还撸了一遍示例代码。<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/object-c-programming.jpg" alt=""></div>

</li>
</ul>
<h2 id="《iOS编程》"><a href="#《iOS编程》" class="headerlink" title="《iOS编程》"></a>《iOS编程》</h2><ul>
<li>时间: 7月22日至7月30</li>
<li>简评: 一本非常好的开发指南，初学如果不看斯坦福的视频，对于里面的介绍各种东西可能会比较陌生。本书覆盖的知识面比较广，但并不深入，总体来说是一本非常好的iOS入门书籍。<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-programming.jpg" alt=""></div>

</li>
</ul>
<h2 id="《iOS开发进阶》"><a href="#《iOS开发进阶》" class="headerlink" title="《iOS开发进阶》"></a>《iOS开发进阶》</h2><ul>
<li>时间: 9月10日~9月12日</li>
<li>简评: 花了三天空余时间过了一遍这本书，主要介绍了作者根据自身多年iOS开发经验总结出的一些开发经验，包括对使用工具提高开发、应用发布的注意事项等等。<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-advanced-develop-book.jpg" alt=""></div>

</li>
</ul>
<h2 id="《iOS-Core-Animation：Advanced-Techniques》"><a href="#《iOS-Core-Animation：Advanced-Techniques》" class="headerlink" title="《iOS Core Animation：Advanced Techniques》"></a>《iOS Core Animation：Advanced Techniques》</h2><ul>
<li>时间: 9月12日~10月24日</li>
<li>简评: 主要介绍Core Animation框架的关键原理以及相关应用，值得二刷。<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-core-animation-book.jpg" alt=""></div>

</li>
</ul>
<h2 id="《Swift-3-0-官方教程中文版》"><a href="#《Swift-3-0-官方教程中文版》" class="headerlink" title="《Swift 3.0 官方教程中文版》"></a>《Swift 3.0 官方教程中文版》</h2><ul>
<li>时间: 10月24日~10月30日</li>
<li>简评: 官方教程，详细全面地介绍了swift 3.0的特性。语言类的官方教程阅读起来还是比较枯燥的，希望以后能够多多锻炼。<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/swift-official-tutorial.png?x-oss-process=image/resize,w_390" alt=""></div>

</li>
</ul>
<h2 id="《Swift编程入门》"><a href="#《Swift编程入门》" class="headerlink" title="《Swift编程入门》"></a>《Swift编程入门》</h2><ul>
<li>时间：10月31日~11月12日</li>
<li>简评：此书是对Swift官方教程进行了简化，整理得出的一般语言教程，很不错，值得向初学者推荐。<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/swift-programming-tutorial.jpg?x-oss-process=image/resize,w_390" alt=""></div>

</li>
</ul>
<h1 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h1><h2 id="《iOS应用逆向工程》"><a href="#《iOS应用逆向工程》" class="headerlink" title="《iOS应用逆向工程》"></a>《iOS应用逆向工程》</h2><ul>
<li>时间：1月14日~至今</li>
</ul>
<p>（未完待续）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2016/12/18/chisel-manual/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="包楚权">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/slamdunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="包楚权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/18/chisel-manual/" itemprop="url">Chisel手册</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-18T22:21:03+08:00">
                2016-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/chisel-manual.pdf" target="_blank" rel="noopener">原文链接</a></p>
<h1 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h1><p>本文档是Chisel的手册（在Scala嵌入语言中构建硬件）。Chisel是嵌入在高级编程语言Scala中的硬件构造语言。单独的Chisel教程文档提供了使用Chisel的简单介绍，建议首先阅读。本手册提供了Chisel语言的全面概述和规范，它只是一组特殊的类定义，预定义对象和Scala中的使用约定。当你写一个Chisel程序时，你实际上是在写一个Scala程序。在本手册中，我们假设您已经了解了Scala的基础知识。如果你不熟悉Scala，我们建议你参考一本优秀的Scala书。  </p>
<h1 id="Nodes"><a href="#Nodes" class="headerlink" title="Nodes"></a>Nodes</h1><p>Chisel中任何硬件设计最终都由节点对象的图表表示。Chisel中的用户代码生成此节点图，然后将其传递到Chisel后端以转换为Verilog或C ++代码。节点定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">// name assigned by user or from introspection var name: String = ""</span></span><br><span class="line">	<span class="comment">// incoming graph edges</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inputs</span></span>: <span class="type">ArrayBuffer</span>[<span class="type">Node</span>]</span><br><span class="line">	<span class="comment">// outgoing graph edges</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">consumers</span></span>: <span class="type">ArrayBuffer</span>[<span class="type">Node</span>]</span><br><span class="line">	<span class="comment">// node specific width inference</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inferWidth</span></span>: <span class="type">Int</span></span><br><span class="line">	<span class="comment">// get width immediately inferrable</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getWidth</span></span>: <span class="type">Int</span></span><br><span class="line">	<span class="comment">// get first raw node</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getRawNode</span></span>: <span class="type">Node</span></span><br><span class="line">	<span class="comment">// convert to raw bits</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toBits</span></span>: <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// convert to raw bits</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fromBits</span></span>(x: <span class="type">Bits</span>): <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">	<span class="comment">// return lit value if inferrable else null def litOf: Lit</span></span><br><span class="line">	<span class="comment">// return value of lit if litOf is non null</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">litValue</span></span>(<span class="keyword">default</span>: <span class="type">BigInt</span> = <span class="type">BigInt</span>(<span class="number">-1</span>)): <span class="type">BigInt</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节点类层次结构的最高级别如图所示。基本类别是：  </p>
<ul>
<li><strong>Lit</strong>: 常量或文本  </li>
<li><strong>Op</strong>: 逻辑或算术操作  </li>
<li><strong>Updateable</strong>: 条件更新节点  </li>
<li><strong>Data</strong>: 具有类型的wire或port  </li>
<li><strong>Reg</strong>: 上升沿触发的寄存器  </li>
<li><strong>Mem</strong>: 存储  <div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-node.png" alt=""></div>

</li>
</ul>
<h1 id="Lits"><a href="#Lits" class="headerlink" title="Lits"></a>Lits</h1><p>原始文本表示为Lit节点，定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lit</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="comment">// original value</span></span><br><span class="line">	<span class="keyword">val</span> inputVal: <span class="type">BigInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原始文本包含位的集合。用户不直接创建原始文本，而是使用第Type节中定义的类型构造函数。  </p>
<h1 id="Ops"><a href="#Ops" class="headerlink" title="Ops"></a>Ops</h1><p>原始操作表示为如下定义的Op节点：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Op</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">// op name used during emission </span></span><br><span class="line">	<span class="keyword">val</span> op: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Ops计算其输入的组合函数。</p>
<h1 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h1><p>表示硬件设计的Chisel图包含原始节点和类型节点。Chisel类型系统与底层Scala类型系统分开维护，因此类型节点散布在原始节点之间，以允许Chisel检查并响应Chisel类型。Chisel类型节点在硬件设计转换为C ++或Verilog之前被擦除。getRawNode运算符定义在基本Node类中，跳过类型节点并返回找到的第一个原始节点。下图显示了内置的Chisel类型层次结构，其中Data为最顶层节点。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-type.png" alt=""></div>

<p>内置标量类型包括Bool，SInt和UInt和内置聚合类型Bundle和Vec允许用户使用其他类型的集合扩展Chisel数据类型集。<br>Data自身就是一个节点：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cloneType</span></span>(): <span class="keyword">this</span>.<span class="keyword">type</span> =</span><br><span class="line">		<span class="keyword">this</span>.getClass.newInstance.asInstanceOf[<span class="keyword">this</span>.<span class="keyword">type</span>]</span><br><span class="line">	<span class="comment">// simple conversions</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toSInt</span></span>: <span class="type">SInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toUInt</span></span>: <span class="type">UInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toBool</span></span>: <span class="type">Bool</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toBits</span></span>: <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// flatten out to leaves of tree </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Data</span>)] </span><br><span class="line">	<span class="comment">// port direction if leaf</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">dir</span></span>: <span class="type">PortDir</span></span><br><span class="line">	<span class="comment">// change dir to OUTPUT </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">asOutput</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span> </span><br><span class="line">	<span class="comment">// change dir to INPUT </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">asInput</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">	<span class="comment">// change polarity of dir </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">flip</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">	<span class="comment">// assign to input</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>:=[<span class="type">T</span> &lt;: <span class="type">Data</span>](t: <span class="type">T</span>) </span><br><span class="line">	<span class="comment">// bulk assign to input </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;&gt;</span></span>(t: <span class="type">Data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Data类具有用于在类型之间转换和将端口方法委托给其单个输入的方法。我们将在Port一节讨论端口。最后，用户可以在其自己的类型节点（例如bundle）中覆盖cloneType方法，以便反映克隆所需的构造参数。<br>Data节点可以用于四种目的：  </p>
<ul>
<li><strong>types</strong>: UInt(width = 8), 在指定最小位宽的图中记录中间类型（在本节中描述）  </li>
<li><strong>wires</strong>: UInt(width = 8), 作为数据的前向声明，允许将来的条件更新（在Updateable一节中描述）  </li>
<li><strong>ports</strong>: UInt(dir = OUTPUT, width = 8), 定义模块接口的专用线，还能指定方向（在Ports一节中描述）  </li>
<li><strong>literals</strong>: UInt(1) 或 UInt(1, 8), 可以使类型对象构造函数来构造其值和可选宽度。  </li>
</ul>
<h2 id="Bits"><a href="#Bits" class="headerlink" title="Bits"></a>Bits</h2><p>在Chisel中，位的原始集合如下Bits类型定义所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Bits</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// create literal from BigInt or Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">BigInt</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// create literal from String using</span></span><br><span class="line">	<span class="comment">// base_char digit+ string format</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">String</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Bits</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bits</span> <span class="keyword">extends</span> <span class="title">Data</span> <span class="keyword">with</span> <span class="title">Updateable</span> </span>&#123; </span><br><span class="line">	<span class="comment">// bitwise-not</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">unary_~</span></span>(): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// bitwise-and</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&amp;</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// bitwise-or</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">|</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// bitwise-xor</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">^</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// and-reduction</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">andR</span></span>(): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// or-reduction</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">orR</span></span>(): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// xor-reduction def xorR(): Bool </span></span><br><span class="line">	<span class="comment">// logical NOT</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">unary_!</span></span>(): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// logical AND</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&amp;&amp;</span> </span>(b: <span class="type">Bool</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// logical OR</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">||</span> </span>(b: <span class="type">Bool</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// equality</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">===</span></span>(b: <span class="type">Bits</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// inequality</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">!=</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// logical left shift </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;&lt;</span> </span>(b: <span class="type">UInt</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// logical right shift </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;</span> </span>(b: <span class="type">UInt</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// concatenate</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">##</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// extract single bit, LSB is 0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// extract bit field from end to start bit pos </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(hi: <span class="type">Int</span>, lo: <span class="type">Int</span>): <span class="type">Bits</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Cat</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](elt: <span class="type">T</span>, elts: <span class="type">T</span>*): <span class="type">Bits</span></span><br></pre></td></tr></table></figure></p>
<p>Bits具有用于简单位操作的方法。注意，##是二进制连接，而Cat是一个正则拼接。为了避免与Scala的内置==冲突，Chisel的按位比较命名为===。<br>使用Fill可以创建n位宽的域：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fill</span></span>(n: <span class="type">Int</span>, field: <span class="type">Bits</span>): <span class="type">Bits</span></span><br></pre></td></tr></table></figure></p>
<p>一个两输入的选择器可以使用Mux：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](sel: <span class="type">Bits</span>, cons: <span class="type">T</span>, alt: <span class="type">T</span>): <span class="type">T</span></span><br></pre></td></tr></table></figure></p>
<p>常量或字面值使用Scala整数或传递给构造函数的字符串表示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">UInt</span>(<span class="string">"ha"</span>)</span><br><span class="line"><span class="type">UInt</span>(<span class="string">"o12"</span>)</span><br><span class="line"><span class="type">UInt</span>(<span class="string">"b1010"</span>) <span class="comment">// binary 4-bit lit from string.</span></span><br></pre></td></tr></table></figure></p>
<p>如下图所示的最左边子图，可以产生Lit。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-op-lit-graph.png" alt=""></div>

<p>操作返回一个实际的操作符节点和类型节点组合成输入类型节点。参见上图，了解更复杂的例子。  </p>
<h2 id="Bools"><a href="#Bools" class="headerlink" title="Bools"></a>Bools</h2><p>布尔值用Bools表示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Bool</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// create literal</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">Boolean</span>): <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bool</span> <span class="keyword">extends</span> <span class="title">UInt</span></span></span><br></pre></td></tr></table></figure></p>
<p>Bool与UInt(width = 1)相等。  </p>
<h2 id="Nums"><a href="#Nums" class="headerlink" title="Nums"></a>Nums</h2><p>Num是一个类型节点，定义了算术运算：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span> <span class="keyword">extends</span> <span class="title">Bits</span> </span>&#123; </span><br><span class="line">	<span class="comment">// Negation</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">unary_-</span></span>(): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// Addition</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(b: <span class="type">Num</span>): <span class="type">Num</span> </span><br><span class="line">	<span class="comment">// Subtraction</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">-</span></span>(b: <span class="type">Num</span>): <span class="type">Num</span> </span><br><span class="line">	<span class="comment">// Multiplication </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">*</span></span>(b: <span class="type">Num</span>): <span class="type">Num</span> </span><br><span class="line">	<span class="comment">// Greater than</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// Less than</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// Less than or equal </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// Greater than or equal </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有符号和无符号整数被认为是定点数的子集，并且分别由类型SInt和UInt表示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SInt</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">SInt</span></span><br><span class="line">	<span class="comment">// create literal</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(value: <span class="type">BigInt</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">SInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(value: <span class="type">String</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">SInt</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SInt</span> <span class="keyword">extends</span> <span class="title">Num</span> <span class="title">object</span> <span class="title">UInt</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">UInt</span></span><br><span class="line">	<span class="comment">// create literal</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">BigInt</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">UInt</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">String</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">UInt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UInt</span> <span class="keyword">extends</span> <span class="title">Num</span> </span>&#123;</span><br><span class="line">	<span class="comment">// arithmetic right shift override </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;</span> </span>(b: <span class="type">UInt</span>): <span class="type">SInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>带符号的定点数（包括整数）使用二进制补码格式表示。  </p>
<h2 id="Bundles"><a href="#Bundles" class="headerlink" title="Bundles"></a>Bundles</h2><p>Bundle将几种不同类型的命名字段组合成一个连续单元，非常像C中的struct：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bundle</span> <span class="keyword">extends</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="comment">// shallow named bundle elements</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">elements</span></span>: <span class="type">ArrayBuffer</span>[(<span class="type">String</span>, <span class="type">Data</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用elements方法可以获取Bundle中每个元素的名称和类型，flatten方法返回嵌套聚合的叶子处的元素。 用户可以通过对bundle进行子类化来定义新的bundle，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFloat</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> sign = <span class="type">Bool</span>()</span><br><span class="line">	<span class="keyword">val</span> exponent = <span class="type">UInt</span>(width = <span class="number">8</span>) </span><br><span class="line">	<span class="keyword">val</span> significand = <span class="type">UInt</span>(width = <span class="number">23</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>元素通过Scala字段访问：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">MyFloat</span>() </span><br><span class="line"><span class="keyword">val</span> xs = x.sign</span><br></pre></td></tr></table></figure></p>
<p>当使用C++或Verilog后端发送时，bundle的元素的名称是从它们的bundle字段名获取的，使用Scala内省。  </p>
<h2 id="Vecs"><a href="#Vecs" class="headerlink" title="Vecs"></a>Vecs</h2><p>Vecs可以创建可索引元素向量：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Vec</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](elts: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">Vec</span>[<span class="type">T</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](elt0: <span class="type">T</span>, elts: <span class="type">T</span>*): <span class="type">Vec</span>[<span class="type">T</span>] </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fill</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](n: <span class="type">Int</span>)	(gen: =&gt; <span class="type">T</span>): <span class="type">Vec</span>[<span class="type">T</span>] </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tabulate</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](n: <span class="type">Int</span>)(gen: (<span class="type">Int</span>) =&gt; <span class="type">T</span>): <span class="type">Vec</span>[<span class="type">T</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tabulate</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](n1: <span class="type">Int</span>, n2: <span class="type">Int</span>) (gen: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">T</span>): <span class="type">Vec</span>[<span class="type">Vec</span>[<span class="type">T</span>]]</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vec</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">n: <span class="type">Int</span>, val gen: (</span>) <span class="title">=&gt;</span> <span class="title">T</span>) <span class="keyword">extends</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">UInt</span>): <span class="type">T</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">Int</span>): <span class="type">T</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">forall</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>[<span class="type">T</span> &lt;: <span class="type">Bits</span>](x: <span class="type">T</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">UInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">indexWhere</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">UInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lastIndexWhere</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">UInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中n个元素类型由gen定义。用户可以使用Int索引静态访问元素或使用UInt索引动态访问元素，其中动态访问创建一个虚拟类型节点（表示读取“端口”），该节点使用给定地址记录读取。在任一情况下，用户可以连线到读取的结果如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v(a) := d</span><br></pre></td></tr></table></figure></p>
<p>只读存储器可以使用Vecs来表示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rom = <span class="type">Vec</span>(<span class="type">UInt</span>(<span class="number">3</span>), <span class="type">UInt</span>(<span class="number">7</span>), <span class="type">UInt</span>(<span class="number">4</span>), <span class="type">UInt</span>(<span class="number">0</span>)) &#123; <span class="type">UInt</span>(width=<span class="number">3</span>) &#125;</span><br><span class="line"><span class="keyword">val</span> dout = rom(addr)</span><br></pre></td></tr></table></figure></p>
<h2 id="Bit-Width-Inference"><a href="#Bit-Width-Inference" class="headerlink" title="Bit Width Inference"></a>Bit Width Inference</h2><p>用户需要设置端口和寄存器的位宽度，否则节点上的位宽度会自动推断，除非用户手动设置（使用Extract或Cat）。位宽推理引擎从图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度：  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-interfence-rule.png" alt=""></div>

<p>其中例如wz是线z的位宽度，并且＆规则应用于所有按位逻辑运算。  </p>
<p>位宽推理过程继续，直到没有位宽改变。除了固定位数的右移之外，位宽度推断规则规定输出位宽不能小于输入位宽度，因此，输出位宽度增长或保持相同。此外，寄存器的宽度必须由用户明确地或从复位值的位宽指定。从这两个要求，我们可以知道位宽推理过程将收敛到一个固定点。  </p>
<h1 id="Updateables"><a href="#Updateables" class="headerlink" title="Updateables"></a>Updateables</h1><p>当描述线和状态节点的操作时，将规范作为输出值的一系列条件更新并且跨多个单独的语句分布这些更新通常是有用的。例如，可以立即引用数据节点的输出，但可以稍后设置其输入。可更新表示一个条件可更新节点，其累积对节点的访问，并且其稍后可以生成多路复用器以在电路中组合这些访问。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Updateable</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="comment">// conditional reads</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reads</span></span>: <span class="type">Queue</span>[(<span class="type">Bool</span>, <span class="type">UInt</span>)]</span><br><span class="line">	<span class="comment">// conditional writes</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">writes</span></span>: <span class="type">Queue</span>[(<span class="type">Bool</span>, <span class="type">UInt</span>, <span class="type">Node</span>)]</span><br><span class="line">	<span class="comment">// gen mux integrating all conditional writes </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">genMuxes</span></span>(<span class="keyword">default</span>: <span class="type">Node</span>)</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> </span>:= (x: <span class="type">Node</span>): <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel以when的形式提供条件更新规则，以支持这种顺序逻辑描述的风格：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">when</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(cond: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>): when</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">when</span> (<span class="params">prevCond: <span class="type">Bool</span></span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">elsewhen</span> </span>(cond: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>): when </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">otherwise</span> </span>(block: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>when操作具有动态作用域的全局条件堆栈。因此，when创建一个在条件函数调用中有效的新条件。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateWhen</span> </span>(c: <span class="type">Bool</span>, d: <span class="type">Data</span>) = </span><br><span class="line">	when (c) &#123; r := d &#125;</span><br><span class="line">when (a) &#123; </span><br><span class="line">	updateWhen(b, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (a) &#123;</span><br><span class="line">	when (b) &#123; r := x &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel为其他常见形式的条件更新提供了一些语法糖：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unless</span></span>(c: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>) = </span><br><span class="line">	when (!c) &#123; block )</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">otherwise</span></span>(block: =&gt; <span class="type">Unit</span>) = </span><br><span class="line">	when (<span class="type">Bool</span>(<span class="literal">true</span>)) &#123; block &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再介绍用于条件更新的switch语句，其涉及对一个公共密钥的一系列比较：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch</span></span>(c: <span class="type">UInt</span>)(block: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is</span></span>(v: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="Forward-Declaration"><a href="#Forward-Declaration" class="headerlink" title="Forward Declaration"></a>Forward Declaration</h1><p>纯组合电路不允许在节点之间有循环，如果检测到这样的循环，则Chisel将报告错误。因为它们不具有周期，所以可以总是以前馈方式构建法向组合电路，通过添加其输入从已经定义的节点导出的新节点。 时序电路在节点之间具有反馈，因此有时需要在生成节点被定义之前参考输出线。因为Scala按顺序执行程序语句，所以我们允许数据节点用作提供节点声明的线，可：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pcPlus4 = <span class="type">UInt</span>() </span><br><span class="line"><span class="keyword">val</span> brTarget = <span class="type">UInt</span>()</span><br><span class="line"><span class="keyword">val</span> pcNext	= <span class="type">Mux</span>(pcSel, brTarget, pcPlus4)</span><br><span class="line"><span class="keyword">val</span> pcReg	= <span class="type">RegUpdate</span>(pcNext)</span><br><span class="line">pcPlus4  := pcReg + <span class="type">UInt</span>(<span class="number">4</span>)</span><br><span class="line">... </span><br><span class="line">brTarget := addOut</span><br></pre></td></tr></table></figure></p>
<p>接线操作符：=用于在pcReg和addOut定义之后进行连接。在所有赋值完成后，如果前向声明未分配，则是一个错误。…  </p>
<h1 id="Regs"><a href="#Regs" class="headerlink" title="Regs"></a>Regs</h1><p>Chisel支持的状态元素的最简单形式是一个正边沿触发寄存器，定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Reg</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (data: <span class="type">T</span>, next: <span class="type">T</span> = <span class="literal">null</span>, init: <span class="type">T</span> = <span class="literal">null</span>): <span class="type">T</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RegNext</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (next: <span class="type">T</span>, init: <span class="type">T</span> = <span class="literal">null</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RegInit</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (init: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reg</span> <span class="keyword">extends</span> <span class="title">Updateable</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以如下进行构造：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r1 = <span class="type">RegUpdate</span>(io.in)</span><br><span class="line"><span class="keyword">val</span> r2 = <span class="type">RegReset</span>(<span class="type">UInt</span>(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">val</span> r3 = <span class="type">RegUpdate</span>(io.in, <span class="type">UInt</span>(<span class="number">1</span>)) </span><br><span class="line"><span class="keyword">val</span> r4 = <span class="type">Reg</span>(<span class="type">UInt</span>(width = <span class="number">8</span>))</span><br></pre></td></tr></table></figure></p>
<p>其中resetVal是reset为ture时用于寄存器的值。  </p>
<h1 id="Mems"><a href="#Mems" class="headerlink" title="Mems"></a>Mems</h1><p>Chisel通过Mem结构支持随机存取存储器。写入Mem是正边沿触发，读取是组合或正边沿触发。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Mem</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](depth: <span class="type">Int</span>, gen: =&gt; <span class="type">T</span>, seqRead: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Mem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mem</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: (</span>) <span class="title">=&gt;</span> <span class="title">T</span>, <span class="title">depth</span></span>: <span class="type">Int</span>, seqRead: <span class="type">Boolean</span> = <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">extends</span> <span class="type">Updateable</span> &#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">UInt</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过应用UInt索引创建到Mems的端口。具有一个写入端口和两个组合读取端口的32个条目的寄存器文件可以表示如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rf = <span class="type">Mem</span>(<span class="number">32</span>, <span class="type">UInt</span>(width = <span class="number">64</span>)) </span><br><span class="line">when (wen) &#123; rf(waddr) := wdata &#125; </span><br><span class="line"><span class="keyword">val</span> dout1 = rf(waddr1)</span><br><span class="line"><span class="keyword">val</span> dout2 = rf(waddr2)</span><br></pre></td></tr></table></figure></p>
<p>如果设置了可选参数seqRead，当Reg分配了Mem的输出时，Chisel将尝试推断顺序读端口。单读，单写SRAM可以描述如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1r1w = <span class="type">Mem</span>(<span class="number">1024</span>, <span class="type">UInt</span>(width = <span class="number">32</span>), seqRead = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> dout = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1r1w(waddr) := wdata &#125; </span><br><span class="line">when (ren) &#123; dout := ram1r1w(raddr) &#125;</span><br></pre></td></tr></table></figure></p>
<p>单端口SRAM可以在读和写条件在链中相同时相互排斥时推断：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1p =</span><br><span class="line"><span class="type">Mem</span>(<span class="number">1024</span>, <span class="type">UInt</span>(width = <span class="number">32</span>), seqRead = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> dout = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1p(waddr) := wdata &#125; </span><br><span class="line">.elsewhen (ren) &#123; dout := ram1p(raddr) &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果相同的Mem地址在相同的时钟沿上被写入和顺序读取，或者如果顺序读取使能被清除，则读取数据是实现定义的。<br>Mem还支持子字写入的写掩码。如果相应的屏蔽位置1，则写入给定位。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram = <span class="type">Mem</span>(<span class="number">256</span>, <span class="type">UInt</span>(width = <span class="number">32</span>))</span><br><span class="line">when (wen) &#123; ram.write(waddr, wdata, wmask) &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Ports"><a href="#Ports" class="headerlink" title="Ports"></a>Ports</h1><p>端口是用作硬件模块接口的Data派生节点。端口是原始Data对象的定向版本。端口方向定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PortDir</span></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">INPUT</span> <span class="keyword">extends</span> <span class="title">PortDir</span> </span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">OUTPUT</span> <span class="keyword">extends</span> <span class="title">PortDir</span></span></span><br></pre></td></tr></table></figure></p>
<p>聚合端口可以使用vec或bundle的实例作为叶子递归构造。  </p>
<h1 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h1><p>在Chisel中，module与Verilog中的module非常相似，在生成电路中定义了层次结构。分层模块命名空间可在下游工具中访问，以帮助调试和物理布局。用户定义的模块被定义为一个类：  </p>
<ul>
<li>继承自Module  </li>
<li>包含一个接口Bundle，其存储在一个名为io的域中  </li>
<li>在其构造器中将子电路连接起来  </li>
</ul>
<p>用户通过子类化Module来编写自己的模块，其定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io: <span class="type">Bundle</span></span><br><span class="line">	<span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compileV</span></span>: <span class="type">Unit</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compileC</span></span>: <span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并定义自己的io字段。例如，要定义一个两输入多路复用器，我们将定义一个模块如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux2</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span>&#123;</span><br><span class="line">		<span class="keyword">val</span> sel = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> in0 = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> in1 = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>:=赋值运算符，在模块定义的主体中使用，是Chisel中的一个特殊运算符，它将左侧的输入连接到右侧的输出。它通常用于将输出端口连接到其定义。  </p>
<p>&lt;&gt;操作符批量连接父对象模型之间的对等相反接口或父/子模块之间相同的接口。批量连接使用路径名匹配连接叶子端口。仅当其中一个端口非空时允许连接，从而允许用户重复地批量连接部分填充的接口。在所有连接完成并且电路正在精心设计后，Chisel警告用户端口是否只有一个到它们的连接。  </p>
<p>当使用C++或Verilog后端发送时，存储在模块中的节点和子模块的名称可以使用Scala内省从它们的模块字段名称中获取。使用函数setName()设置节点或子模块的名称。  </p>
<h1 id="Black-Box"><a href="#Black-Box" class="headerlink" title="Black Box"></a>Black Box</h1><p>黑盒允许用户定义接口到Chisel之外定义的电路。用户定义：  </p>
<ul>
<li>一个BlackBox子类的模块  </li>
<li>一个带有接口的io  </li>
<li>可选的VerilogParameters子类  </li>
</ul>
<p>例如，可以将简单的ROM黑盒定义为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomIo</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> isVal = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> raddr = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>) </span><br><span class="line">	<span class="keyword">val</span> rdata = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">32</span>) </span><br><span class="line">	raddr.setName(<span class="string">"RADDR"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomParams</span> <span class="keyword">extends</span> <span class="title">VerilogParameters</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> <span class="type">MY_STR</span> = <span class="string">"Test"</span></span><br><span class="line">	<span class="keyword">val</span> <span class="type">MY_INT</span> = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rom</span> <span class="keyword">extends</span> <span class="title">BlackBox</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">RomIo</span>()</span><br><span class="line">	<span class="keyword">val</span> romParams = <span class="keyword">new</span> <span class="type">RomParams</span>() </span><br><span class="line">	setVerilogParameters(romParams) 	</span><br><span class="line">	renameClock(<span class="type">Driver</span>.implicitClock, <span class="string">"clock_A"</span>)</span><br><span class="line">	renameClock(<span class="string">"my_other_clock"</span>, <span class="string">"test_clock"</span>) </span><br><span class="line">	renameReset(<span class="string">"rst"</span>)</span><br><span class="line">	<span class="comment">// Define how to use in simulation here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数将转换为verilog参数，其中包含类定义中使用的名称和值。setVerilogParameters也可以直接接受一个字符串。函数renameClock可以获取Clock对象或时钟的字符串名称来重命名BlackBox输出时钟。函数renameReset将重命名隐式重置。如果需要命名其他重置，请调用setName()。在io类中显示了使用setName()的示例。而不是被称为io_raddr为黑箱的io，它将是RADDR。黑盒在c模拟中作为一个模块。这意味着您可以使用io实现BlackBox的功能，以便您可以验证您的设计。  </p>
<h1 id="Printf-amp-Sprintf"><a href="#Printf-amp-Sprintf" class="headerlink" title="Printf &amp; Sprintf"></a>Printf &amp; Sprintf</h1><p>Chisel提供了为调试目的格式化和打印字符串的能力。printf和sprintf结构与它们的C名称类似：它们取一个格式字符串和可变数量的参数，然后分别打印或返回一个字符串。在模拟期间，printf在上升时钟沿将控制字符串打印到控制台。另一方面，sprintf返回格式化的字符串作为位向量。  </p>
<p>支持的格式说明符是％b（二进制数），％d（十进制数），％x（十六进制数）和％s（由8位扩展ASCII字符序列组成的字符串）。%%指定文字％。）与C不同，没有宽度修饰符：相应参数的位宽决定了字符串表示中的宽度。  </p>
<p>以下示例在c为true时打印“0x4142 16706 AB”行：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="type">Bits</span>(<span class="number">0x4142</span>)</span><br><span class="line"><span class="keyword">val</span> s1 = sprintf(<span class="string">"%x %s"</span>, x, x);</span><br><span class="line">when (c) &#123; printf(<span class="string">"%d %s\n"</span>, x, s1); &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h1><p>运行时断言由assert结构提供。在仿真期间，如果断言的论点在上升时钟边沿为false，则会打印错误并终止仿真。例如，以下将在十个时钟周期后终止仿真：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, <span class="number">4</span>)) </span><br><span class="line">x := x + <span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line">assert(x &lt; <span class="type">UInt</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></p>
<h1 id="Main-amp-Testing"><a href="#Main-amp-Testing" class="headerlink" title="Main &amp; Testing"></a>Main &amp; Testing</h1><p>为了构造一个电路，用户从它们的顶层main函数调用chiselMain：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">chiselMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Module</span>]</span><br><span class="line">		(args: <span class="type">Array</span>[<span class="type">String</span>], comp: () =&gt; <span class="type">T</span>): <span class="type">T</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行以上对象会在–targetDir dir_name参数指定的目录下生成module_name.cpp和module_name.h C++文件。  </p>
<p>测试是电路设计的一个关键部分，因此在Chisel中，我们提供了一种测试电路的机制，通过使用Tester类的子类在Scala中提供测试向量：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>[<span class="type">T</span> &lt;: <span class="type">Module</span>] (<span class="params">val c: <span class="type">T</span>, val isTrace: <span class="type">Boolean</span> = true</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> t: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">var</span> ok: <span class="type">Boolean</span></span><br><span class="line">	<span class="keyword">val</span> rnd: <span class="type">Random</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Boolean</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Int</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Bits</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(n: <span class="type">Int</span> = <span class="number">1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">step</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pokeAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>, x: <span class="type">BigInt</span>) </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Bits</span>, x: <span class="type">BigInt</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Aggregate</span>, x: <span class="type">Array</span>[<span class="type">BigInt</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peekAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Bits</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Aggregate</span>): <span class="type">Array</span>[<span class="type">BigInt</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(good: <span class="type">Boolean</span>, msg: <span class="type">String</span>): <span class="type">Boolean</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(data: <span class="type">Bits</span>, target: <span class="type">BigInt</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它将tester绑定到模块，并允许用户使用给定的调试协议编写测试。用户利用：  </p>
<ul>
<li><strong>poke</strong>: 设置端口和状态值  </li>
<li><strong>step</strong>: 以一个时间单位执行电路  </li>
<li><strong>peek</strong>: 读端口和状态值  </li>
<li><strong>expect</strong>: 比较测试电路的值和预期的值  </li>
</ul>
<p>用户通过如下方式连接tester实例和模块：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">chiselMainTest</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Module</span>]</span><br><span class="line">		(args: <span class="type">Array</span>[<span class="type">String</span>], comp: () =&gt; <span class="type">T</span>)( </span><br><span class="line">		tester: <span class="type">T</span> =&gt; <span class="type">Tester</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当–test作为chiselMain的参数时，tester实例在单独的进程中运行被测设计（DUT），stdin和stdout连接，以便调试命令可以发送到DUT，并且响应可以从DUT如图所示。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-DUT.png" alt=""></div>

<p>如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux2Tests</span>(<span class="params">c: <span class="type">Mux2</span></span>) <span class="keyword">extends</span> <span class="title">Tester</span>(<span class="params">c</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> n = pow(<span class="number">2</span>, <span class="number">3</span>).toInt</span><br><span class="line">	<span class="keyword">for</span> (s &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i0 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123; </span><br><span class="line">			<span class="keyword">for</span> (i1 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">				poke(c.io.sel, s)</span><br><span class="line">				poke(c.io.in1, i1)</span><br><span class="line">				poke(c.io.in0, i0)</span><br><span class="line">				step(<span class="number">1</span>)</span><br><span class="line">				expect(c.io.out, (<span class="keyword">if</span> (s == <span class="number">1</span>) i1 <span class="keyword">else</span> i0))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用poke将Mux2的每个输入的分配设置为适当的值。对于这个特定的例子，我们通过将输入硬编码到一些已知的值并检查输出是否对应于已知的值来测试Mux2。为此，在每次迭代中，我们生成模块的适当输入，并告诉模拟将这些值分配给我们正在测试的器件的输入c，步骤电路和测试期望值。最后，下面显示了如何调用测试器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chiselMainTest(args + <span class="string">"--test"</span>, () =&gt; <span class="keyword">new</span> <span class="type">Mux2</span>())&#123; </span><br><span class="line">	c =&gt; <span class="keyword">new</span> <span class="type">Mux2Tests</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，chiselMain*有以下命令参数：  </p>
<blockquote>
<p>–targetDir        目标路径前缀<br>–genHarness        生成C++文件<br>–debug            把所有wire放入C++类文件中<br>–compile            编译生成的C++<br>–test            使用C++应用运行测试<br>–backend v        产生verilog<br>–backend c        产生C++（默认）<br>–vcd                使能vcd打印</p>
</blockquote>
<h1 id="C-Emulator"><a href="#C-Emulator" class="headerlink" title="C++ Emulator"></a>C++ Emulator</h1><p>C ++仿真器基于使用C ++模板的快速多字库。 单个字由val_t定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef uint64_t val_t; </span><br><span class="line">typedef int64_t sval_t; </span><br><span class="line">typedef uint32_t half_val_t;</span><br></pre></td></tr></table></figure></p>
<p>多字由dat_t定义，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">template &lt;int w&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dat_t</span> </span>&#123;</span><br><span class="line">	public:</span><br><span class="line">		const static int n_words;</span><br><span class="line">		inline int width ( void );</span><br><span class="line">		inline int n_words_of ( void );</span><br><span class="line">		inline bool to_bool ( void );</span><br><span class="line">		inline val_t lo_word ( void );</span><br><span class="line">		inline unsigned long to_ulong ( void ); </span><br><span class="line">		std::string to_str ();</span><br><span class="line">		dat_t&lt;w&gt; ();</span><br><span class="line">template &lt;int sw&gt;</span><br><span class="line">	dat_t&lt;w&gt; (const dat_t&lt;sw&gt;&amp; src); </span><br><span class="line">	dat_t&lt;w&gt; (const dat_t&lt;w&gt;&amp; src); </span><br><span class="line">	dat_t&lt;w&gt; (val_t <span class="keyword">val</span>);</span><br><span class="line">template &lt;int sw&gt;</span><br><span class="line">	dat_t&lt;w&gt; mask(dat_t&lt;sw&gt; fill, int n);</span><br><span class="line">template &lt;int dw&gt; </span><br><span class="line">	dat_t&lt;dw&gt; mask(int n);</span><br><span class="line">template &lt;int n&gt;</span><br><span class="line">	dat_t&lt;n&gt; mask(void);</span><br><span class="line">	dat_t&lt;w&gt; operator + ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator - ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator - ( );</span><br><span class="line">	dat_t&lt;w+w&gt; operator * ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w+w&gt; fix_times_fix( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w+w&gt; ufix_times_fix( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w+w&gt; fix_times_ufix( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &lt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &gt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &gt;= ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &lt;= ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; gt ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; gte ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; lt ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; lte ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;w&gt; operator ^ ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator &amp; ( dat_t&lt;w&gt; o );	</span><br><span class="line">	dat_t&lt;w&gt; operator | ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator ~ ( void);</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator ! ( void );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &amp;&amp; ( dat_t&lt;<span class="number">1</span>&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator || ( dat_t&lt;<span class="number">1</span>&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator == ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator == ( datz_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator != ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator &lt;&lt; ( int amount ); </span><br><span class="line">	dat_t&lt;w&gt; operator &lt;&lt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator &gt;&gt; ( int amount ); </span><br><span class="line">	dat_t&lt;w&gt; operator &gt;&gt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; rsha ( dat_t&lt;w&gt; o); </span><br><span class="line">	dat_t&lt;w&gt;&amp; operator = ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; fill_bit(val_t bit); </span><br><span class="line">	dat_t&lt;w&gt; fill_byte(val_t byte, int nb, int n);</span><br><span class="line">template &lt;int dw, int n&gt;</span><br><span class="line">	dat_t&lt;dw&gt; fill( void );</span><br><span class="line">template &lt;int dw, int nw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; fill( dat_t&lt;nw&gt; n );</span><br><span class="line">template &lt;int dw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; extract(); </span><br><span class="line">template &lt;int dw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; extract(val_t e, val_t s); </span><br><span class="line">template &lt;int dw, int iwe, int iws&gt;</span><br><span class="line">	dat_t&lt;dw&gt; extract(dat_t&lt;iwe&gt; e, dat_t&lt;iws&gt; s);</span><br><span class="line">template &lt;int sw&gt; </span><br><span class="line">	dat_t&lt;w&gt; inject(dat_t&lt;sw&gt; src, val_t e, val_t s); </span><br><span class="line">template &lt;int sw, int iwe, int iws&gt;</span><br><span class="line">	dat_t&lt;w&gt; inject (dat_t&lt;sw&gt; src, dat_t&lt;iwe&gt; e, dat_t&lt;iws&gt; s); </span><br><span class="line">template &lt;int dw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; log2(); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; bit(val_t b); </span><br><span class="line">	val_t msb();</span><br><span class="line">template &lt;int iw&gt;</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; bit(dat_t&lt;iw&gt; b)</span><br><span class="line">&#125;</span><br><span class="line">template &lt;int w, int sw&gt; </span><br><span class="line">	dat_t&lt;w&gt; <span class="type">DAT</span>(dat_t&lt;sw&gt; dat);</span><br><span class="line">template &lt;int w&gt;</span><br><span class="line">	dat_t&lt;w&gt; <span class="type">LIT</span>(val_t value);</span><br><span class="line">template &lt;int w&gt; dat_t&lt;w&gt;</span><br><span class="line">	mux ( dat_t&lt;<span class="number">1</span>&gt; t, dat_t&lt;w&gt; c, dat_t&lt;w&gt; a )</span><br></pre></td></tr></table></figure></p>
<p>其中w是位宽参数。  </p>
<p>Chisel编译器将顶层模块编译为可以创建和执行的单个扁平的mod_t类：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mod_t</span> </span>&#123; </span><br><span class="line">	public:</span><br><span class="line">		<span class="comment">// initialize module</span></span><br><span class="line">		virtual void init (void) &#123; &#125;;</span><br><span class="line">		<span class="comment">// compute all combinational logic</span></span><br><span class="line">		virtual void clock_lo (dat_t&lt;<span class="number">1</span>&gt; reset) &#123; &#125;; </span><br><span class="line">		<span class="comment">// commit state updates</span></span><br><span class="line">		virtual void clock_hi (dat_t&lt;<span class="number">1</span>&gt; reset) &#123; &#125;; </span><br><span class="line">		<span class="comment">// print printer specd node values to stdout </span></span><br><span class="line">		virtual void print (<span class="type">FILE</span>* f) &#123; &#125;;</span><br><span class="line">		<span class="comment">// scan scanner specd node values from stdin </span></span><br><span class="line">		virtual bool scan (<span class="type">FILE</span>* f) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;; </span><br><span class="line">		<span class="comment">// dump vcd file</span></span><br><span class="line">		virtual void dump (<span class="type">FILE</span>* f, int t) &#123; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Chisel编译器可以创建一个线束，或者用户可以自己写一个线束。以下是CPU模块的线束示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"cpu.h"</span></span><br><span class="line">int main (int argc, char* argv[]) &#123;</span><br><span class="line">	cpu_t* c = <span class="keyword">new</span> cpu_t();</span><br><span class="line">	int lim = (argc &gt; <span class="number">1</span>) ? atoi(argv[<span class="number">1</span>]) : <span class="number">-1</span>; </span><br><span class="line">	c-&gt;init();</span><br><span class="line">	<span class="keyword">for</span> (int t = <span class="number">0</span>; lim &lt; <span class="number">0</span> || t &lt; lim; t++) &#123;</span><br><span class="line">		dat_t&lt;<span class="number">1</span>&gt; reset = <span class="type">LIT</span>&lt;<span class="number">1</span>&gt;(t == <span class="number">0</span>); </span><br><span class="line">		<span class="keyword">if</span> (!c-&gt;scan(stdin)) <span class="keyword">break</span>; </span><br><span class="line">		c-&gt;clock_lo(reset); </span><br><span class="line">		c-&gt;clock_hi(reset); </span><br><span class="line">		c-&gt;print(stdout);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h1><p>当-v参数传递到chiselMain时，Chisel生成Verilog。 例如，从SBT，以下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run --v</span><br></pre></td></tr></table></figure></p>
<p>将在目标目录中生成名为module-name.v的单个Verilog文件。该文件将包含一个模块，每个模块定义为在chiselMain中创建的顶层模块的子模块。具有相同接口和主体的模块将被缓存和重用。  </p>
<h1 id="Multiple-Clock-Domains"><a href="#Multiple-Clock-Domains" class="headerlink" title="Multiple Clock Domains"></a>Multiple Clock Domains</h1><h2 id="Creating-Clock-domains"><a href="#Creating-Clock-domains" class="headerlink" title="Creating Clock domains"></a>Creating Clock domains</h2><p>为了使用多个时钟域，用户必须创建多个时钟。在Chisel中，时钟是用复位信号参数创建的一级节点，并定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> (<span class="params">reset: <span class="type">Bool</span></span>) <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>: <span class="type">Bool</span> <span class="comment">// returns reset pin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Chisel中有一个内置的隐式时钟，状态元素默认使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> implicitClock = <span class="keyword">new</span> <span class="type">Clock</span>( implicitReset )</span><br></pre></td></tr></table></figure></p>
<p>状态元素和模块的时钟可以使用名为clock的附加命名参数来定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reg</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Mem</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Module</span>(... clock: <span class="type">Clock</span> = implicitClock)</span><br></pre></td></tr></table></figure></p>
<h2 id="Crossing-Clock-Domains"><a href="#Crossing-Clock-Domains" class="headerlink" title="Crossing Clock Domains"></a>Crossing Clock Domains</h2><p>有两种方式可以定义电路在时钟域之间发送数据。第一种和最原始的方式是使用由两个寄存器组成的同步电路，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signalA is in clock domain clockA,</span></span><br><span class="line"><span class="comment">// want a version in clockB as signalB</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB) </span><br><span class="line"><span class="keyword">val</span> s2 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB)</span><br><span class="line">s1 := signalA</span><br><span class="line">s2 := s1;</span><br><span class="line">signalB := s2</span><br></pre></td></tr></table></figure></p>
<p>由于亚稳性问题，该技术限于在域之间传递一位数据。  </p>
<p>在域之间发送数据的第二种更一般的方式是通过使用异步fifo：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncFifo</span>[<span class="type">T</span>&lt;:<span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, entries: <span class="type">Int</span>, enq_clk: <span class="type">Clock</span>, deq_clock: <span class="type">Clock</span></span>)</span></span><br><span class="line"><span class="class">	<span class="keyword">extends</span> <span class="title">Module</span></span></span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以通过指定标准fifo参数和两个时钟，然后使用标准去耦就绪/有效信号，从时钟频率A到时钟B获得一个版本的signalA：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fifo = <span class="keyword">new</span> <span class="type">AsyncFifo</span>(<span class="type">Uint</span>(width = <span class="number">32</span>), <span class="number">2</span>, clockA, clockB)</span><br><span class="line">fifo.io.enq.bits := signalA</span><br><span class="line">signalB := fifo.io.deq.bits </span><br><span class="line">fifo.io.enq.valid := condA </span><br><span class="line">fifo.io.deq.ready := condB</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="Backend-Specific-Multiple-Clock-Domains"><a href="#Backend-Specific-Multiple-Clock-Domains" class="headerlink" title="Backend Specific Multiple Clock Domains"></a>Backend Specific Multiple Clock Domains</h2><p>时钟域可以以域特定的方式映射到C++和Verilog后端。为了展示如何驱动多时钟设计，考虑硬件示例，其中两个模块使用AsyncFifo进行通信，每个模块在不同的时钟：fastClock和slowClock。  </p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>在C ++后端，对于每个时钟i，有一个：  </p>
<ul>
<li>uint64_t clk_i域表示时钟i的周期  </li>
<li>uint63_t clk_i_cnt域表示时钟i当前计数  </li>
<li>clock_lo_i和clock_hi_i  </li>
<li>int reset()函数，其保证了所有的clock_lo和clock_hi函数被立即调用  </li>
<li>int clock(reset)函数，其计算最小增量，调用适当的clock_lo和clock_hi，并返回使用的最小增量。  </li>
</ul>
<p>为了建立C++模拟，用户需要：  </p>
<ul>
<li>将所有周期字段初始化为所需周期  </li>
<li>将所有计数字段初始化为期望的相位  </li>
<li>调用reset  </li>
<li>重复调用时钟逐步模拟  </li>
</ul>
<p>以下是slowClock / fastClock的main函数C++示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123; </span><br><span class="line">	<span class="type">ClkDomainTest_t</span> dut; dut.init(<span class="number">1</span>);</span><br><span class="line">	dut.clk = <span class="number">2</span>;</span><br><span class="line">	dut.clk_cnt = <span class="number">1</span>; </span><br><span class="line">	dut.fastClock = <span class="number">4</span>; </span><br><span class="line">	dut.fastClock_cnt = <span class="number">0</span>; </span><br><span class="line">	dut.slowClock = <span class="number">6</span>; </span><br><span class="line">	dut.slowClock_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i ++)</span><br><span class="line">		dut.reset();</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i ++)</span><br><span class="line">		dut.clock(<span class="type">LIT</span>&lt;<span class="number">1</span>&gt;(<span class="number">0</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Verilog-1"><a href="#Verilog-1" class="headerlink" title="Verilog"></a>Verilog</h3><p>在verilog中，  </p>
<ul>
<li>Chisel为每个时钟/复位创建一个新端口  </li>
<li>Chisel将所有时钟连接到顶部模块  </li>
<li>用户必须为每个时钟i创建一个always块时钟驱动器  </li>
</ul>
<p>以下是驱动slowClock / fastClock示例电路的顶层线束的Verilog示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module emulator;</span><br><span class="line">	reg fastClock = <span class="number">0</span>, slowClock = <span class="number">0</span>, resetFast = <span class="number">1</span>, resetSlow = <span class="number">1</span>; </span><br><span class="line">	wire [<span class="number">31</span>:<span class="number">0</span>] add, mul, test; </span><br><span class="line">	always #<span class="number">2</span> fastClock = ~fastClock; </span><br><span class="line">	always #<span class="number">4</span> slowClock = ~slowClock; </span><br><span class="line">	initial begin</span><br><span class="line">		#<span class="number">8</span></span><br><span class="line">		resetFast = <span class="number">0</span>; </span><br><span class="line">		resetSlow = <span class="number">0</span>; </span><br><span class="line">		#<span class="number">400</span></span><br><span class="line">		$finish;</span><br><span class="line">	end</span><br><span class="line"><span class="type">ClkDomainTest</span> dut (</span><br><span class="line">	.fastClock(fastClock), </span><br><span class="line">	.slowClock(slowClock), </span><br><span class="line">	.io_resetFast(resetFast), </span><br><span class="line">	.io_resetSlow(resetSlow),</span><br><span class="line">	.io_add(add), </span><br><span class="line">	.io_mul(mul), </span><br><span class="line">	.io_test(test));</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h1 id="Extra-Stuff"><a href="#Extra-Stuff" class="headerlink" title="Extra Stuff"></a>Extra Stuff</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListLookup</span></span>[<span class="type">T</span> &lt;: <span class="type">Bits</span>](addr: <span class="type">UInt</span>, <span class="keyword">default</span>: <span class="type">List</span>[<span class="type">T</span>],</span><br><span class="line">	mapping: <span class="type">Array</span>[(<span class="type">UInt</span>, <span class="type">List</span>[<span class="type">T</span>])]): <span class="type">List</span>[<span class="type">T</span>]</span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Lookup</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (addr: <span class="type">UInt</span>, <span class="keyword">default</span>: <span class="type">T</span>,</span><br><span class="line">	mapping: <span class="type">Seq</span>[(<span class="type">UInt</span>, <span class="type">T</span>)]): <span class="type">T</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">// n-way multiplexor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MuxCase</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="keyword">default</span>: <span class="type">T</span>, mapping: <span class="type">Seq</span>[(<span class="type">Bool</span>, <span class="type">T</span>)]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// n-way indexed multiplexer:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MuxLookup</span></span>[<span class="type">S</span> &lt;: <span class="type">UInt</span>, <span class="type">T</span> &lt;: <span class="type">Data</span>](key: <span class="type">S</span>, <span class="keyword">default</span>: <span class="type">T</span>, mapping: <span class="type">Seq</span>[(<span class="type">S</span>, <span class="type">T</span>)]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create n enum values of given type</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Enum</span></span>[<span class="type">T</span> &lt;: <span class="type">UInt</span>](n: <span class="type">Int</span>)(gen: =&gt; <span class="type">T</span>): <span class="type">List</span>[<span class="type">T</span>]</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create enum values of given type and names</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Enum</span></span>[<span class="type">T</span> &lt;: <span class="type">UInt</span>](l: <span class="type">Symbol</span> *)(gen: =&gt; <span class="type">T</span>): <span class="type">Map</span>[<span class="type">Symbol</span>, <span class="type">T</span>]</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create enum values of given type and names</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Enum</span></span>[<span class="type">T</span> &lt;: <span class="type">UInt</span>](l: <span class="type">List</span>[<span class="type">Symbol</span>])(gen: =&gt; <span class="type">T</span>): <span class="type">Map</span>[<span class="type">Symbol</span>, <span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<h1 id="Standard-Library"><a href="#Standard-Library" class="headerlink" title="Standard Library"></a>Standard Library</h1><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the log base 2 of the input </span></span><br><span class="line"><span class="comment">// Scala Integer rounded up</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log2Up</span></span>(in: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line"><span class="comment">// Returns the log base 2 of the input </span></span><br><span class="line"><span class="comment">// Scala Integer rounded down</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log2Down</span></span>(in: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns true if the input Scala Integer </span></span><br><span class="line"><span class="comment">//isapowerof2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPow2</span></span>(in: <span class="type">Int</span>): <span class="type">Boolean</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// linear feedback shift register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LFSR16</span></span>(increment: <span class="type">Bool</span> = <span class="type">Bool</span>(<span class="literal">true</span>)): <span class="type">UInt</span></span><br></pre></td></tr></table></figure>
<h2 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential"></a>Sequential</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the n-cycle delayed version</span></span><br><span class="line"><span class="comment">// of the input signal</span></span><br><span class="line"><span class="comment">// Has an optional enable signal defaulting to true def ShiftRegister[T &lt;: Data (in: T, n: Int, en = </span></span><br><span class="line">	<span class="type">Bool</span>(<span class="literal">true</span>)): <span class="type">T</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Counter</span></span>(cond: <span class="type">Bool</span>, n: <span class="type">Int</span>) = &#123; </span><br><span class="line">	<span class="keyword">val</span> c = <span class="type">RegReset</span>(<span class="type">UInt</span>(<span class="number">0</span>, log2Up(n))) </span><br><span class="line">	<span class="keyword">val</span> wrap = c === <span class="type">UInt</span>(n<span class="number">-1</span>)</span><br><span class="line">	when (cond) &#123;</span><br><span class="line">		c := <span class="type">Mux</span>(<span class="type">Bool</span>(!isPow2(n)) &amp;&amp; wrap, <span class="type">UInt</span>(<span class="number">0</span>), c + <span class="type">UInt</span>(<span class="number">1</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	(c, wrap &amp;&amp; cond) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the number of bits set in the // input signal. Causes an exception if // the input is wider than 32 bits.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PopCount</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns the reverse the input signal</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reverse</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// returns the one hot encoding of</span></span><br><span class="line"><span class="comment">// the input UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UIntToOH</span></span>(in: <span class="type">UInt</span>, width: <span class="type">Int</span>): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// does the inverse of UIntToOH</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OHToUInt</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OHToUInt</span></span>(in: <span class="type">Seq</span>[<span class="type">Bool</span>]): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Builds a Mux tree out of the input</span></span><br><span class="line"><span class="comment">// signal vector using a one hot encoded </span></span><br><span class="line"><span class="comment">// select signal. Returns the output of </span></span><br><span class="line"><span class="comment">// the Mux tree</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux1H</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (sel: <span class="type">UInt</span>, in: <span class="type">Vec</span>[<span class="type">T</span>]): <span class="type">T</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux1H</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (sel: <span class="type">Vec</span>[<span class="type">Bool</span>], in: <span class="type">Vec</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Builds a Mux tree under the</span></span><br><span class="line"><span class="comment">// assumption that multiple</span></span><br><span class="line"><span class="comment">// select signals can be enabled.</span></span><br><span class="line"><span class="comment">// Priority is given to the first</span></span><br><span class="line"><span class="comment">// select signal. Returns the output </span></span><br><span class="line"><span class="comment">// of the Mux tree.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityMux</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](sel: <span class="type">UInt</span>, in: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">T</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityMux</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](sel: <span class="type">Seq</span>[<span class="type">UInt</span>], in: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns the bit position of the</span></span><br><span class="line"><span class="comment">// trailing 1 in the input vector with </span></span><br><span class="line"><span class="comment">// the assumption that multiple bits of </span></span><br><span class="line"><span class="comment">// the input bit vector can be set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoder</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoder</span></span>(in: <span class="type">Seq</span>[<span class="type">Bool</span>]): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns the bit position of the</span></span><br><span class="line"><span class="comment">// trailing 1 in the input vector with</span></span><br><span class="line"><span class="comment">// the assumption that only one bit in</span></span><br><span class="line"><span class="comment">// the input vector can be set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoderOH</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoderOH</span></span>(in: <span class="type">Seq</span>[<span class="type">Boo</span>]): <span class="type">UInt</span></span><br></pre></td></tr></table></figure>
<h2 id="Decoupled"><a href="#Decoupled" class="headerlink" title="Decoupled"></a>Decoupled</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adds a ready-valid handshaking </span></span><br><span class="line"><span class="comment">// protocol to any interface. The</span></span><br><span class="line"><span class="comment">// standard used is that the</span></span><br><span class="line"><span class="comment">// consumer uses the fliped interface</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoupledIO</span>[+<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> ready = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> bits  = gen.cloneType.asOutput</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Adds a valid protocol to any</span></span><br><span class="line"><span class="comment">// interface. The standard used is </span></span><br><span class="line"><span class="comment">// that the consumer uses the</span></span><br><span class="line"><span class="comment">// fliped interface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidIO</span>[+<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> bits  = gen.cloneType.asOutput</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hardware module that is used to </span></span><br><span class="line"><span class="comment">// sequence n producers into 1 consumer</span></span><br><span class="line"><span class="comment">// Priority is given to lower</span></span><br><span class="line"><span class="comment">// producer</span></span><br><span class="line"><span class="comment">// Example usage: </span></span><br><span class="line"><span class="comment">// 		val arb = new Arbiter(UInt(), 2)</span></span><br><span class="line"><span class="comment">//		arb.io.in(0) &lt;&gt; producer0.io.out</span></span><br><span class="line"><span class="comment">// 		arb.io.in(1) &lt;&gt; producer1.io.out</span></span><br><span class="line"><span class="comment">//		consumer.io.in &lt;&gt; arb.io.out</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arbiter</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">Hardware</span> <span class="title">module</span> <span class="title">that</span> <span class="title">is</span> <span class="title">used</span> <span class="title">to</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">sequence</span> <span class="title">n</span> <span class="title">producers</span> <span class="title">into</span> 1 <span class="title">consumer</span>.</span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">Producers</span> <span class="title">are</span> <span class="title">chosen</span> <span class="title">in</span> <span class="title">round</span> <span class="title">robin</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">order</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">Example</span> <span class="title">usage</span></span>:</span><br><span class="line"><span class="comment">//		val arb = new RRArbiter(UInt(), 2) </span></span><br><span class="line"><span class="comment">//		arb.io.in(0) &lt;&gt; producer0.io.out </span></span><br><span class="line"><span class="comment">//		arb.io.in(1) &lt;&gt; producer1.io.out </span></span><br><span class="line"><span class="comment">//		consumer.io.in &lt;&gt; arb.io.out </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RRArbiter</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">Generic</span> <span class="title">hardware</span> <span class="title">queue</span>. <span class="title">Required</span> </span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">parameter</span> <span class="title">entries</span> <span class="title">controls</span> <span class="title">the</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">depth</span> <span class="title">of</span> <span class="title">the</span> <span class="title">queues</span>. <span class="title">The</span> <span class="title">width</span> <span class="title">of</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">the</span> <span class="title">queue</span> <span class="title">is</span> <span class="title">determined</span> <span class="title">from</span> <span class="title">the</span> </span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">inputs</span>.</span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">Example</span> <span class="title">usage</span></span>:</span><br><span class="line"><span class="comment">// 		val q = new Queue(UInt(), 16)</span></span><br><span class="line"><span class="comment">//		q.io.enq &lt;&gt; producer.io.out</span></span><br><span class="line"><span class="comment">// 		consumer.io.in &lt;&gt; q.io.deq</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (<span class="params">gen: <span class="type">T</span>, entries: <span class="type">Int</span>, pipe: <span class="type">Boolean</span> = false, flow: <span class="type">Boolean</span> =false</span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"><span class="class"><span class="title">//</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">A</span> <span class="title">hardware</span> <span class="title">module</span> <span class="title">that</span> <span class="title">delays</span> <span class="title">data</span> </span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">coming</span> <span class="title">down</span> <span class="title">the</span> <span class="title">pipeline</span> <span class="title">by</span> <span class="title">the</span> </span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">number</span> <span class="title">of</span> <span class="title">cycles</span> <span class="title">set</span> <span class="title">by</span> <span class="title">the</span> </span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">latency</span> <span class="title">parameter</span>. <span class="title">Functionality</span> </span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">is</span> <span class="title">similar</span> <span class="title">to</span> <span class="title">ShiftRegister</span> <span class="title">but</span> </span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">this</span> <span class="title">exposes</span> <span class="title">a</span> <span class="title">Pipe</span> <span class="title">interface</span>. </span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">Example</span> <span class="title">usage</span></span>:</span><br><span class="line"><span class="comment">// 		val pipe = new Pipe(UInt()) </span></span><br><span class="line"><span class="comment">//		pipe.io.enq &lt;&gt; produce.io.out </span></span><br><span class="line"><span class="comment">// 		consumer.io.in &lt;&gt; pipe.io.deq</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipe</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, latency: <span class="type">Int</span> = 1</span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br></pre></td></tr></table></figure>
<p>（完）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2016/12/17/chisel-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="包楚权">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/slamdunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="包楚权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/17/chisel-tutorial/" itemprop="url">Chisel入门教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-17T14:46:37+08:00">
                2016-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/chisel-tutorial.pdf" target="_blank" rel="noopener">原文链接</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Chisel（Constructing Hardware In a Scala Embedded Language）是一种嵌入在高级编程语言Scala的硬件构建语言。Chisel实际上只是一些特殊的类定义，预定义对象的集合，使用Scala的用法，所以在写Chisel程序时实际上是在写Scala程序。不过，本文我们并不假设你知道如何去写一个Scala程序。本文会通过一些Chisel的例子来说明某些重要的Scala特征，可以让你只使用本文介绍的东西也能完成一些伟大的硬件设计。 当你越来越有经验，希望自己的代码能够更加简化或提高复用性，你会发现有必要了解Scala语言的潜力。 所以，进一步学习Scala会让你变得更加专业。  </p>
<p>Chisel仍处于起步阶段，你可能会遇到一些实现方面的bug，甚至可能会遇到一些概念设计问题。不过，我们正在积极地修改和改进语言，并且对错误报告和建议开放。即使在早期阶段，我们希望Chisel将帮助设计师在构建易于重复使用和维护的设计时更有效率。  </p>
<h1 id="Chisel硬件表达"><a href="#Chisel硬件表达" class="headerlink" title="Chisel硬件表达"></a>Chisel硬件表达</h1><p>此版本的Chisel只支持二进制逻辑，不支持三态信号。  </p>
<blockquote>
<p>我们专注于二进制逻辑设计，因为它们构成了实践中的绝大多数设计。我们忽略对当前Chisel语言中的三态逻辑的支持，因为这在工业环境中也很少支持，并且难以在受控硬宏之外可靠地使用。  </p>
</blockquote>
<h1 id="Chisel数据类型"><a href="#Chisel数据类型" class="headerlink" title="Chisel数据类型"></a>Chisel数据类型</h1><p>Chisel数据类型用于指定状态元素中保存的值或wire上传输的值。虽然硬件设计最终操作的是二进制数值向量，但对于值的其他抽象表示具有更清晰的规范，并且能够帮助工具生成更优化的电路。在Chisel中，原始比特集合可以用Bits类型来表示。带符号和无符号整数被认为是定点数的子集，可以用SInt和UInt来表示。带符号定点整数（包括整数）使用二进制补码格式来表示。布尔值可以用Bool类型表示。注意，这些类型与Scala的内建类型不同，例如Int或Boolean。另外，Chisel定义了Bundle用来将值进行集合（类似于其他语言中的struct），还定义了Vec用来对值的集合进行索引。  </p>
<p>常量或字面值使用Scala整数或传递给构造函数的字符串表示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="number">1</span>)			<span class="comment">// decimal 1-bit lit from Scala Int.</span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">"ha"</span>)		<span class="comment">// hexadecimal 4-bit lit from string.</span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">"o12"</span>)		<span class="comment">// octal 4-bit lit from string.</span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">"b1010"</span>) 	<span class="comment">// binary 4-bit lit from string.</span></span><br><span class="line"><span class="type">SInt</span>(<span class="number">5</span>) 		<span class="comment">// signed decimal 4-bit lit from Scala Int. </span></span><br><span class="line"><span class="type">SInt</span>(<span class="number">-8</span>) 		<span class="comment">// negative decimal 4-bit lit from Scala Int. </span></span><br><span class="line"><span class="type">UInt</span>(<span class="number">5</span>) 		<span class="comment">// unsigned decimal 3-bit lit from Scala Int.</span></span><br><span class="line"><span class="type">Bool</span>(<span class="literal">true</span>) 		<span class="comment">// Bool lits from Scala lits. </span></span><br><span class="line"><span class="type">Bool</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
<p>下划线可以用作长字符串文字中的分隔符，以帮助可读性，但在创建值时会被忽略，例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="string">"h_dead_beef"</span>) <span class="comment">// 32-bit lit of type UInt</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下，Chisel编译器将每个常量的大小设置为保存常量所需的最小位数，包括带符号类型的符号位。位宽也可以在字面上明确指定，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="string">"ha"</span>, <span class="number">8</span>) 		<span class="comment">// hexadecimal 8-bit lit of type UInt </span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">"o12"</span>, <span class="number">6</span>) 		<span class="comment">// octal 6-bit lit of type UInt </span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">"b1010"</span>, <span class="number">12</span>) 	<span class="comment">// binary 12-bit lit of type UInt</span></span><br><span class="line"><span class="type">SInt</span>(<span class="number">5</span>, <span class="number">7</span>) 			<span class="comment">// signed decimal 7-bit lit of type SInt </span></span><br><span class="line"><span class="type">UInt</span>(<span class="number">5</span>, <span class="number">8</span>) 			<span class="comment">// unsigned decimal 8-bit lit of type UInt</span></span><br></pre></td></tr></table></figure></p>
<p>对于UInt类型值，值被零扩展到所需的位宽。对于类型为SInt的文字，该值被符号扩展以填充所需的位宽度。如果给定的位宽太小而不能容纳参数值，则会生成Chisel错误。</p>
<h1 id="组合电路"><a href="#组合电路" class="headerlink" title="组合电路"></a>组合电路</h1><p>在Chisel中，电路会被表示为一张节点图。每个节点是具有零个或多个输入并驱动一个输出的硬件运算符。上面介绍的Uint是一种退化类型的节点，它没有输入，并且在其输出上驱动一个恒定的值。创建和连接节点的一种方法是使用字面表达式。例如，我们可以使用以下表达式来表示简单的组合逻辑电路：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &amp; b) | (~c &amp; d)</span><br></pre></td></tr></table></figure></p>
<p>语法应该看起来很熟悉，用＆和|分别表示按位与和按位或，~表示按位非。a到d表示某些（未指定）宽度的命名导线。<br>任何简单的表达式都可以直接转换成电路树，在叶子处使用命名的导线和操作符形成内部节点。表达式的电路输出取自树根处的运算符，在本示例中是按位或运算。<br>简单表达式可以以树的形式构建电路，但是如果想以任意有向非循环图（DAG）的形式构建电路，我们需要描述扇出。在Chisel中，我们通过命名一根wire来表示一个子表达式，这样我们就可以在后续表达式中多次引用。我们通过声明变量来命名Chisel中的wire。例如，考虑如下示例的select表达式，它在后续的多选器描述中可以多次使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sel = a | b</span><br><span class="line"><span class="keyword">val</span> out = (sel &amp; in1) | (~sel &amp; in0)</span><br></pre></td></tr></table></figure></p>
<p>关键字<strong>val</strong>是Scala的一部分，用于命名具有不会再更改的值的变量。 在上面的例子中它命名了wire类型的sel，保存了第一个按位或运算符的输出，以便输出可在第二个表达式中多次使用。  </p>
<h1 id="内建操作符"><a href="#内建操作符" class="headerlink" title="内建操作符"></a>内建操作符</h1><p>Chisel定义了一组硬件操作符，如下表所示：  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-operators.png" alt=""></div>

<h2 id="位宽接口"><a href="#位宽接口" class="headerlink" title="位宽接口"></a>位宽接口</h2><p>用户需要设置端口和寄存器的位宽，除非用户手动设置，否则编译器会自动推测wire上的位宽。位宽推测引擎会从节点图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度：  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-interfence-rule.png" alt=""></div>  

<p>其中例如wz是wire z的位宽，＆规则可应用于所有按位逻辑运算。</p>
<p>位宽推测过程会持续到没有位宽改变。 除了通过已知固定数量的右移之外，位宽推测规定了输出位宽度不能小于输入位宽度，因此输出位宽度增长或保持相同。 此外，寄存器的宽度必须由用户明确地或根据复位值或下一个参数的位宽指定。根据这两个要求，我们可以将位宽推测过程将收敛到一个固定点。  </p>
<blockquote>
<p>我们选择的运算符名称受到Scala语言的限制。所以我们必须使用===表示等于判断逻辑和=/=表示不等判断逻辑，这样可以保持原生Scala相关运算符可用。  </p>
</blockquote>
<h1 id="功能抽象"><a href="#功能抽象" class="headerlink" title="功能抽象"></a>功能抽象</h1><p>我们可以定义函数来分解一个重复的逻辑，这样可以在后续设计中重复使用。例如，我们可以包装一个简单的组合逻辑块：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clb</span></span>(a: <span class="type">UInt</span>, b: <span class="type">UInt</span>, c: <span class="type">UInt</span>, d: <span class="type">UInt</span>): <span class="type">UInt</span> = </span><br><span class="line">	(a &amp; b) | (~c &amp; d)</span><br></pre></td></tr></table></figure></p>
<p>其中clb是表示以a，b，c，d为参数的函数，并返回一个布尔电路的输出。 <strong>def</strong>关键字是Scala的一部分，表示引入了一个函数定义，每个语句后面跟一个冒号，然后是它的类型，函数返回类型在参数列表之后的冒号之后。（=）符号将函数参数列表与函数定义分隔开。<br>然后我们就可以在其他的电路中使用了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> out = clb(a,b,c,d)</span><br></pre></td></tr></table></figure></p>
<p>我们将在后面介绍许多吊炸天的函数使用方法来构造硬件。  </p>
<h1 id="Bundles-amp-Vecs"><a href="#Bundles-amp-Vecs" class="headerlink" title="Bundles &amp; Vecs"></a>Bundles &amp; Vecs</h1><p>Bundle和Vec是可以允许用户使用其他数据类型来扩展Chisel数据类型集合的类。<br>Bundle可以将一些不同类型的命名字段组合成一个单元，类似于C语言中的struct。用户可以通过将一个类定义为Bundle的子类来定义自己的bundle：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFloat</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> sign = <span class="type">Bool</span>()</span><br><span class="line">	<span class="keyword">val</span> exponent = <span class="type">UInt</span>(width = <span class="number">8</span>) </span><br><span class="line">	<span class="keyword">val</span> significand = <span class="type">UInt</span>(width = <span class="number">23</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">MyFloat</span>()</span><br><span class="line"><span class="keyword">val</span> xs = x.sign</span><br></pre></td></tr></table></figure></p>
<p>scala约定将新类的名称的首字母大写，所以我们建议在Chisel中也遵循这个约定。 UInt构造函数的width命名参数指定类型中的位数。  </p>
<p>Vecs用来创建一个可索引的元素向量，其构造如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector of 5 23-bit signed integers.</span></span><br><span class="line"><span class="keyword">val</span> myVec = <span class="type">Vec</span>.fill(<span class="number">5</span>)&#123; <span class="type">SInt</span>(width = <span class="number">23</span>) &#125; </span><br><span class="line"><span class="comment">// Connect to one element of vector.</span></span><br><span class="line"><span class="keyword">val</span> reg3 = myVec(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>（注意，我们必须在花括号内指定Vec元素的类型，因为我们必须将位宽参数传递给SInt构造器。）<br>原始类（SInt，UInt和Bool）加上聚合类（Bundles和Vecs）都继承自一个公共的超类Data。在电路中，每个最终继承自Data的对象都可以表示为一个位向量。<br>Bundle和Vec可以任意嵌套，从而构建复杂的数据结构：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigBundle</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Vector of 5 23-bit signed integers.</span></span><br><span class="line">	<span class="keyword">val</span> myVec = <span class="type">Vec</span>.fill(<span class="number">5</span>) &#123; <span class="type">SInt</span>(width = <span class="number">23</span>) &#125; </span><br><span class="line">	<span class="keyword">val</span> flag = <span class="type">Bool</span>()</span><br><span class="line">	<span class="comment">// Previously defined bundle.</span></span><br><span class="line">	<span class="keyword">val</span> f = <span class="keyword">new</span> <span class="type">MyFloat</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>端口用作硬件组件的接口。一个端口可以是任意的Data对象，但它是具有方向的。<br>Chisel提供端口构造函数，以允许在构建时给对象添加（输入或输出）。原始的端口构造函数需要将方向作为第一个参数（方向为INPUT或OUTPUT），将位数作为第二个参数（除了始终为1位的布尔值）。<br>端口的声明如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoupled</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> ready = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> data = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>) </span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Decoupled被定义后，它就会变成一个新的类型，可以根据需要用于模块接口或命名的wire集合。<br>对象的方向也可以实例化时确定：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScaleIO</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> in = <span class="keyword">new</span> <span class="type">MyFloat</span>().asInput </span><br><span class="line">	<span class="keyword">val</span> scale = <span class="keyword">new</span> <span class="type">MyFloat</span>().asInput </span><br><span class="line">	<span class="keyword">val</span> out = <span class="keyword">new</span> <span class="type">MyFloat</span>().asOutput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>asInput和asOutput方法可以强制数据对象的所有模块设置成对应的方向。<br>通过将方向折叠到对象声明中，Chisel能够提供强大的布线能力，稍后会详细介绍。  </p>
<h1 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h1><p>我们现在可以构建电路层次，我们可以从较小的子模块开开始构建更大的模块。例如，我们可以通过将三个2输入多路选择器连接在一起，构建一个4输入多路选择器模块：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux4</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> in0 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in1 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in2 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) 	</span><br><span class="line">		<span class="keyword">val</span> in3 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> sel = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">2</span>) </span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> m0 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())</span><br><span class="line">	m0.io.sel := io.sel(<span class="number">0</span>)</span><br><span class="line">	m0.io.in0 := io.in0; </span><br><span class="line">	m0.io.in1 := io.in1</span><br><span class="line">	<span class="keyword">val</span> m1 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())</span><br><span class="line">	m1.io.sel := io.sel(<span class="number">0</span>)</span><br><span class="line">	m1.io.in0 := io.in2; </span><br><span class="line">	m1.io.in1 := io.in3</span><br><span class="line">	<span class="keyword">val</span> m3 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())</span><br><span class="line">	m3.io.sel := io.sel(<span class="number">1</span>)</span><br><span class="line">	m3.io.in0 := m0.io.out; </span><br><span class="line">	m3.io.in1 := m1.io.out</span><br><span class="line">	io.out := m3.io.out </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="运行和测试"><a href="#运行和测试" class="headerlink" title="运行和测试"></a>运行和测试</h1><p>现在我们已经定义了模块，我们将讨论如何实际运行并测试电路。Chisel代码可以转换为C++或Verilog。 为了编译电路，我们需要调用chiselMain：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">tutorial</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">		chiselMain(args, () =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())) </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试是电路设计的关键部分，因此在Chisel中，我们通过这样一种测试机制：使用Tester类的子类在Scala中提供测试向量：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>[<span class="type">T</span> &lt;: <span class="type">Module</span>] (<span class="params">val c: <span class="type">T</span>, val isTrace: <span class="type">Boolean</span> = true</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> t: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">val</span> rnd: <span class="type">Random</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Boolean</span>): <span class="type">BigInt</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Int</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Bits</span>): <span class="type">BigInt</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(n: <span class="type">Int</span> = <span class="number">1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">step</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pokeAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>, x: <span class="type">BigInt</span>) </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Bits</span>, x: <span class="type">BigInt</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Aggregate</span>, x: <span class="type">Array</span>[<span class="type">BigInt</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peekAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Bits</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Aggregate</span>): <span class="type">Array</span>[<span class="type">BigInt</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(good: <span class="type">Boolean</span>, msg: <span class="type">String</span>): <span class="type">Boolean</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(data: <span class="type">Bits</span>, target: <span class="type">BigInt</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它将tester绑定到模块，并允许用户使用给定的调试协议编写测试。用户会用到一下这些：  </p>
<ul>
<li><strong>poke</strong>: 设置输入端口以及状态值  </li>
<li><strong>step</strong>: 以一个时间单元执行电路  </li>
<li><strong>peek</strong>: 读取端口和状态值  </li>
<li><strong>expect</strong>: 比较peek获得的值和期望的值  </li>
</ul>
<p>用户使用如下的方式连接tester和模块：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">chiselMainTest</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Module</span>]</span><br><span class="line">		(args: <span class="type">Array</span>[<span class="type">String</span>], comp: () =&gt; <span class="type">T</span>)( </span><br><span class="line">			tester: <span class="type">T</span> =&gt; <span class="type">Tester</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当- -test作为参数传递给chiselMainTest时，tester实例在独立的进程中运行被测器件（DUT），并连接stdin和stdout，这样调试命令可以发送到DUT，响应也可以从DUT接收，如图所示。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-DUT.png" alt=""></div>

<p>举例说明：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux2Tests</span>(<span class="params">c: <span class="type">Mux2</span></span>) <span class="keyword">extends</span> <span class="title">Tester</span>(<span class="params">c</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> n = pow(<span class="number">2</span>, <span class="number">3</span>).toInt</span><br><span class="line">	<span class="keyword">for</span> (s &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i0 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123; </span><br><span class="line">			<span class="keyword">for</span> (i1 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">				poke(c.io.sel, s)</span><br><span class="line">				poke(c.io.in1, i1)</span><br><span class="line">				poke(c.io.in0, i0)</span><br><span class="line">				step(<span class="number">1</span>)</span><br><span class="line">				expect(c.io.out, (<span class="keyword">if</span> (s == <span class="number">1</span>) i1 <span class="keyword">else</span> i0))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用poke将Mux2的每个输入的分别设置为合适的值。对于这个例子，我们通过硬编码输入到一些已知的值并检查输出是否对应于已知的值来测试Mux2。为此，在每次迭代中，我们生成模块输入，让模拟将这些值分配给我们正在测试的器件c的输入，单步运行电路并对比期望值。最后，简单说明一下如何调用测试器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chiselMainTest(args + <span class="string">"--test"</span>, () =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>()))&#123; </span><br><span class="line">	c =&gt; <span class="keyword">new</span> <span class="type">Mux2Tests</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有其他的一些命令参数：  </p>
<blockquote>
<p>–targetDir    目标路径名前缀<br>–genHarness    生成C++文件<br>–backend v    生成verilog<br>–backend c    生成C++（默认）<br>–vcd            开启vcd打印<br>–debug        把所有的wire放入class文件  </p>
</blockquote>
<h1 id="状态元素"><a href="#状态元素" class="headerlink" title="状态元素"></a>状态元素</h1><p>Chisel支持的状态元素的最简单形式是上升沿触发寄存器，可以实例化为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> reg = <span class="type">Reg</span>(next = in)</span><br></pre></td></tr></table></figure></p>
<p>该电路具有输出，该输出是前一个时钟周期的输入信号产生的值。注意，我们不必指定Reg的类型，因为它会在实例化时从输入开始自动推断。在当前版本的Chisel中，时钟和复位是全局信号，在需要时可以隐式包含。<br>使用寄存器，我们可以快速定义一些有用的电路结构。 例如，当当前值为true且之前的值为false时，上升沿检测器能够获取到布尔信号并输出true，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">risingedge</span></span>(x: <span class="type">Bool</span>) = x &amp;&amp; !<span class="type">Reg</span>(next = x)</span><br></pre></td></tr></table></figure></p>
<p>计数器是一个重要的时序电路。 如果想构建一个向上计数器，计数到最大值max后回到零：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span></span>(max: <span class="type">UInt</span>) = &#123;</span><br><span class="line">	<span class="keyword">val</span> x = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, max.getWidth))</span><br><span class="line">	x := <span class="type">Mux</span>(x === max, <span class="type">UInt</span>(<span class="number">0</span>), x + <span class="type">UInt</span>(<span class="number">1</span>))</span><br><span class="line">	x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计数器复位值为0（宽度大到足以容纳max），当电路的全局复位置位时，寄存器将初始化为该值。<br>计数器可用于构建很多有用的时序电路。例如，我们可以通过在计数器达到零时输出true来构建脉冲发生器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Produce pulse every n cycles.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pulse</span></span>(n: <span class="type">UInt</span>) = counter(n - <span class="type">UInt</span>(<span class="number">1</span>)) === <span class="type">UInt</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后可以通过切换方波发生器脉冲序列，在每个脉冲上的true和false之间切换：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flip internal state when input true.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toggle</span></span>(p: <span class="type">Bool</span>) = &#123;</span><br><span class="line">	<span class="keyword">val</span> x = <span class="type">Reg</span>(init = <span class="type">Bool</span>(<span class="literal">false</span>)) </span><br><span class="line">	x := <span class="type">Mux</span>(p, !x, x)</span><br><span class="line">	x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Square wave of a given period.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squareWave</span></span>(period: <span class="type">UInt</span>) = toggle(pulse(period/<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="转发声明"><a href="#转发声明" class="headerlink" title="转发声明"></a>转发声明</h2><p>纯组合电路在节点之间不存在周期，如果检测到这样的周期，则Chisel将报告错误。因为它们不具有周期，所以可以总是以前馈方式构建组合电路，通过添加一些输入从已经定义的节点导出的新节点。时序电路在节点之间具有反馈，因此有时需要在生成节点被定义之前输出。因为Scala顺序执行程序语句，所以我们允许数据节点作为wire来提供节点声明，这样可以立即被使用，但其输入将稍后设置。如下例所示，在简单的CPU中，我们需要定义pcPlus4和brTarget的线，以便在定义之前引用它们：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pcPlus4 = <span class="type">UInt</span>()</span><br><span class="line"><span class="keyword">val</span> brTarget = <span class="type">UInt</span>()</span><br><span class="line"><span class="keyword">val</span> pcNext = <span class="type">Mux</span>(io.ctrl.pcSel, brTarget, pcPlus4)</span><br><span class="line"><span class="keyword">val</span> pcReg = <span class="type">Reg</span>(next = pcNext, init = <span class="type">UInt</span>(<span class="number">0</span>, <span class="number">32</span>)) </span><br><span class="line">pcPlus4 := pcReg + <span class="type">UInt</span>(<span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line">brTarget := addOut</span><br></pre></td></tr></table></figure></p>
<p>接线操作符:=用于在pcReg和addOut定义后连接。  </p>
<h2 id="条件更新"><a href="#条件更新" class="headerlink" title="条件更新"></a>条件更新</h2><p>在前面使用到寄存器的示例中，我们简单地将组合逻辑块连接到寄存器的输入。当描述状态元素的操作时，指定何时将发生寄存器更新并且用几个单独的语句指明这些更新。Chisel以when的形式提供条件更新规则，以支持这种顺序逻辑描述的风格。例如，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, <span class="number">16</span>)) </span><br><span class="line">when (cond) &#123;</span><br><span class="line">	r := r + <span class="type">UInt</span>(<span class="number">1</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中只有在cond为真时，才在当前时钟周期的结尾更新寄存器r。when的参数是返回Bool值。后面的更新块只能包含使用赋值运算符:=，简单表达式和用val定义的命名引线的更新语句。<br>在条件更新序列中，条件为真的最近条件更新优先。 例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">when (c1) &#123; r := <span class="type">UInt</span>(<span class="number">1</span>) &#125; </span><br><span class="line">when (c2) &#123; r := <span class="type">UInt</span>(<span class="number">2</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述表达式会根据以下真值表更新r：  </p>
<table>
<thead>
<tr>
<th style="text-align:center">c1</th>
<th style="text-align:center">c2</th>
<th style="text-align:center">r</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">r</td>
<td style="text-align:left">r 不变</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:left">c2优先于c1</td>
</tr>
</tbody>
</table>
<p>下图显示了如何将每个条件更新视为在寄存器的输入之前插入mux，根据when选择更新表达式或之前的输入。编译器会把初始化值置于链的开头，以便如果在一个时钟周期内没有条件更新激活，则寄存器的加载使能将被置为无效，寄存器值就不会改变。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-for-when.png" alt=""></div>

<p>Chisel为条件更新的其他常见形式提供了一些语法糖。除非结构与when相同，但否定其条件。也就是说，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unless (c) &#123; body &#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (!c) &#123; body &#125;</span><br></pre></td></tr></table></figure></p>
<p>更新块可以操作多个目标寄存器，在不同更新块中的也允许存在寄存器的不同重叠子集。每个寄存器只受其出现的条件的影响。组合电路（更新Wire）也是可能的。注意，所有组合电路需要默认值。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r := <span class="type">SInt</span>(<span class="number">3</span>); s := <span class="type">SInt</span>(<span class="number">3</span>)</span><br><span class="line">when (c1) &#123; r := <span class="type">SInt</span>(<span class="number">1</span>); s := <span class="type">SInt</span>(<span class="number">1</span>) &#125; </span><br><span class="line">when (c2) &#123; r := <span class="type">SInt</span>(<span class="number">2</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述语句会根据如下真值表更新r和s：  </p>
<table>
<thead>
<tr>
<th style="text-align:center">c1</th>
<th style="text-align:center">c2</th>
<th style="text-align:center">r</th>
<th style="text-align:center">s</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>条件更新结构可以嵌套，任何给定块在所有外嵌套条件的联合下才能执行。例如，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">when (a) &#123; when (b) &#123; body &#125; &#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (a &amp;&amp; b) &#123; body &#125;</span><br></pre></td></tr></table></figure></p>
<p>条件可以使用when，.elsewhen，.otherwise来链式表达，对应于Scala中的if, else if, else。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">when (c1) &#123; u1 &#125; </span><br><span class="line">.elsewhen (c2) &#123; u2 &#125; </span><br><span class="line">.otherwise &#123; ud &#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (c1) &#123; u1 &#125;</span><br><span class="line">when (!c1 &amp;&amp; c2) &#123; u2 &#125; </span><br><span class="line">when (!(c1 || c2)) &#123; ud &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再介绍关于用于条件更新的switch语句，其涉及针对公共密钥的一系列比较。例如，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch(idx) &#123; </span><br><span class="line">	is(v1) &#123; u1 &#125; </span><br><span class="line">	is(v2) &#123; u2 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the same sa</span></span><br><span class="line">when (idx === v1) &#123; u1 &#125; </span><br><span class="line">.elsewhen (idx === v2) &#123; u2 &#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel还允许Wire，即一些组合逻辑的输出，成为条件性更新语句的目标，以允许逐步构建复杂的组合逻辑表达式。Chisel不允许不指定组合输出，并且如果组合输出未遇到无条件更新，则报告错误。  </p>
<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>在数字设计中有限状态机（FSM）是时序电路常用的类型。简单FSM的例子就是奇偶校验生成器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parity</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> in = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">Bool</span>(dir = <span class="type">OUTPUT</span>) </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> s_even :: s_odd :: <span class="type">Nil</span> = <span class="type">Enum</span>(<span class="type">UInt</span>(), <span class="number">2</span>) </span><br><span class="line">	<span class="keyword">val</span> state = <span class="type">Reg</span>(init = s_even)</span><br><span class="line">	when (io.in) &#123;</span><br><span class="line">		when (state === s_even) &#123; state := s_odd &#125;</span><br><span class="line">		when (state === s_odd) &#123; state := s_even &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	io.out := (state === s_odd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中Enum(Uint(), 2)生成两个UInt数。当io.in为true时更新状态。需要注意的是，FSM的所有机制都建立在寄存器，线和条件更新的基础上。<br>下面是一个复杂的FSM例子，这是一个自动售货机接收货币的电路：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> nickel = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> dime   = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> valid  = <span class="type">Bool</span>(dir = <span class="type">OUTPUT</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> s_idle :: s_5 :: s_10 :: s_15 :: s_ok :: <span class="type">Nil</span> = <span class="type">Enum</span>(<span class="type">UInt</span>(), <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">val</span> state = <span class="type">Reg</span>(init = s_idle) </span><br><span class="line">	when (state === s_idle) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_5 &#125;</span><br><span class="line">		when (io.dime) &#123; state := s_10 &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_5) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_10 &#125; </span><br><span class="line">		when (io.dime) &#123; state := s_15 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_10) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_15 &#125;</span><br><span class="line">		when (io.dime) &#123; state := s_ok &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_15) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_ok &#125; </span><br><span class="line">		when (io.dime) &#123; state := s_ok &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_ok) &#123;</span><br><span class="line">		state := s_idle</span><br><span class="line">	&#125;</span><br><span class="line">	io.valid := (state === s_ok) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个使用switch语句定义的售货机FSM：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> nickle = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> dime   = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> valid  = <span class="type">Bool</span>(dir = <span class="type">OUTPUT</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> s_idle :: s_5 :: s_10 :: s_15 :: s_ok :: <span class="type">Nil</span> = <span class="type">Enum</span>(<span class="type">UInt</span>(), <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">val</span> state = <span class="type">Reg</span>(init = s_idle) </span><br><span class="line">	switch (state) &#123; </span><br><span class="line">		is (s_idle) &#123;</span><br><span class="line">			when (io.nickel) &#123; state := s_5 &#125;</span><br><span class="line">			when (io.dime) &#123; state := s_10 &#125; </span><br><span class="line">		&#125; </span><br><span class="line">		is (s_5) &#123;</span><br><span class="line">			when (io.nickel) &#123; state := s_10 &#125; </span><br><span class="line">			when (io.dime) &#123; state := s_15 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		is (s_10) &#123;</span><br><span class="line">			when (io.nickel) &#123; state := s_15 &#125;</span><br><span class="line">			when (io.dime) &#123; state := s_ok &#125; </span><br><span class="line">		&#125;</span><br><span class="line">		is (s_ok) &#123;</span><br><span class="line">			state := s_idle</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	io.valid := (state === s_ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>Chisel提供了创建只读和读/写存储器的功能。  </p>
<h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>用户可以使用Vec定义ROM：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Vec</span>(inits: <span class="type">Seq</span>[<span class="type">T</span>])</span><br><span class="line"><span class="type">Vec</span>(elt0: <span class="type">T</span>, elts: <span class="type">T</span>*)</span><br></pre></td></tr></table></figure></p>
<p>其中inits是初始化ROM的初始Data序列。例如，用户可以创建一个初始化为1,2,4,8的小型ROM，并使用计数器作为地址生成器循环访问所有值，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> m = <span class="type">Vec</span>(<span class="type">Array</span>(<span class="type">UInt</span>(<span class="number">1</span>), <span class="type">UInt</span>(<span class="number">2</span>), <span class="type">UInt</span>(<span class="number">4</span>), <span class="type">UInt</span>(<span class="number">8</span>))) </span><br><span class="line"><span class="keyword">val</span> r = m(counter(<span class="type">UInt</span>(m.length)))</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用如下初始化的ROM创建n值正弦查找表：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinTable</span> </span>(amp: <span class="type">Double</span>, n: <span class="type">Int</span>) = &#123; </span><br><span class="line">	<span class="keyword">val</span> times = <span class="type">Range</span>(<span class="number">0</span>, n, <span class="number">1</span>).map(i =&gt; (i*<span class="number">2</span>*<span class="type">Pi</span>)/(n.toDouble<span class="number">-1</span>) - <span class="type">Pi</span>) </span><br><span class="line">	<span class="keyword">val</span> inits = times.map(t =&gt; <span class="type">SInt</span>(round(amp * sin(t)), width = <span class="number">32</span>)) </span><br><span class="line">	<span class="type">Vec</span>(inits)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinWave</span> </span>(amp: <span class="type">Double</span>, n: <span class="type">Int</span>) =</span><br><span class="line">	sinTable(amp, n)(counter(<span class="type">UInt</span>(n))</span><br></pre></td></tr></table></figure></p>
<p>其中amp用于缩放存储在ROM中的固定点值。</p>
<h2 id="Mem"><a href="#Mem" class="headerlink" title="Mem"></a>Mem</h2><p>存储器在Chisel中被给予特殊处理，因为存储器的硬件实现具有许多变化，例如，FPGA存储器与ASIC存储实例化的结果完全不同。Chisel定义了一个内存抽象，可以映射到简单的Verilog行为描述，也可以映射到从代工厂或IP厂商提供的外部内存生成器获得的内存模块实例。<br>Chisel通过Mem结构可以支持随机存取存储器。写入Mems是正边沿触发，读取是组合或正边沿触发。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Mem</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="class"><span class="keyword">type</span></span>: <span class="type">T</span>, depth: <span class="type">Int</span>,</span><br><span class="line">		seqRead: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Mem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mem</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">type: <span class="type">T</span>, depth: <span class="type">Int</span>, seqRead: <span class="type">Boolean</span> = false</span>)</span></span><br><span class="line"><span class="class">	<span class="keyword">extends</span> <span class="title">Updateable</span> </span>&#123; </span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">UInt</span>): <span class="type">T</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过使用UInt索引创建到Mems的端口。具有一个写入端口和两个组合读取端口的32-entry的寄存器堆可以如下表示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rf = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">64</span>), <span class="number">32</span>) </span><br><span class="line">when (wen) &#123; rf(waddr) := wdata &#125; </span><br><span class="line"><span class="keyword">val</span> dout1 = rf(waddr1)</span><br><span class="line"><span class="keyword">val</span> dout2 = rf(waddr2)</span><br></pre></td></tr></table></figure></p>
<p>如果设置了可选参数seqRead，当读地址为Reg时，Chisel将尝试推断顺序读端口。单读端口，单写端口SRAM可以描述如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1r1w = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">32</span>), <span class="number">1024</span>, seqRead = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> reg_raddr = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1r1w(waddr) := wdata &#125; </span><br><span class="line">when (ren) &#123; reg_raddr := raddr &#125;</span><br><span class="line"><span class="keyword">val</span> rdata = ram1r1w(reg_raddr)</span><br></pre></td></tr></table></figure></p>
<p>单端口SRAM可以在读和写条件在链中相同时相互排斥时推断：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1p = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">32</span>), <span class="number">1024</span>, seqRead = <span class="literal">true</span>) </span><br><span class="line"><span class="keyword">val</span> reg_raddr = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1p(waddr) := wdata &#125; </span><br><span class="line">.elsewhen (ren) &#123; reg_raddr := raddr &#125;</span><br><span class="line"><span class="keyword">val</span> rdata = ram1p(reg_raddr)</span><br></pre></td></tr></table></figure></p>
<p>如果相同的Mem地址在相同的时钟沿上被写入和顺序读取，或者如果顺序读取使能被清除，则读取数据为未定义。<br>Mem还支持subword写入的写掩码。如果相应的屏蔽位置1，则写入给定位。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">32</span>), <span class="number">256</span>)</span><br><span class="line">when (wen) &#123; ram.write(waddr, wdata, wmask) &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterIO</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">PLink</span>().flip</span><br><span class="line">	<span class="keyword">val</span> y = <span class="keyword">new</span> <span class="type">PLink</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中flip递归地改变Bundle的“性别”，将输入改变为输出和输出。<br>我们现在可以通过定义一个过滤器类扩展模块来定义一个过滤器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; <span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">FilterIO</span>()</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中io包含了FilterIO。  </p>
<h2 id="Bundle-向量"><a href="#Bundle-向量" class="headerlink" title="Bundle 向量"></a>Bundle 向量</h2><p>除了单个元素，元素向量可以形成更丰富的分层接口。例如，创建具有输入向量的交叉开关，产生输出向量，并通过UInt输入选择，我们可以使用Vec构造函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossbarIo</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> in = <span class="type">Vec</span>.fill(n)&#123; <span class="keyword">new</span> <span class="type">PLink</span>().flip() &#125; </span><br><span class="line">	<span class="keyword">val</span> sel = <span class="type">UInt</span>(<span class="type">INPUT</span>, sizeof(n))</span><br><span class="line">	<span class="keyword">val</span> out = <span class="type">Vec</span>.fill(n)&#123; <span class="keyword">new</span> <span class="type">PLink</span>() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中Vec用第一个参获取大小，区块返回一个端口作为第二个参数。  </p>
<h2 id="批量连接"><a href="#批量连接" class="headerlink" title="批量连接"></a>批量连接</h2><p>我们现在可以将两个过滤器组成一个过滤器块，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">FilterIO</span>()</span><br><span class="line">	<span class="keyword">val</span> f1 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Filter</span>()) </span><br><span class="line">	<span class="keyword">val</span> f2 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Filter</span>())</span><br><span class="line">	f1.io.x &lt;&gt; io.x </span><br><span class="line">	f1.io.y &lt;&gt; f2.io.x </span><br><span class="line">	f2.io.y &lt;&gt; io.y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中&lt;&gt;批量连接同级模块之间的相反接口或父/子模块之间的相同接口。批量连接将相同名称的叶子端口彼此连接。在所有连接完成后，Chisel警告用户端口是否只有一个到它们的连接。  </p>
<h2 id="接口视图"><a href="#接口视图" class="headerlink" title="接口视图"></a>接口视图</h2><p>考虑一个由控制逻辑和数据通路子模块以及主机和存储器接口组成的简单CPU，如图所示。在这个CPU中，我们可以看到控制逻辑和数据通路每个只连接到指令和数据存储器接口的一部分。Chisel允许用户通过部分实现接口来实现这一点。用户首先定义到ROM和Mem的完整接口，如下：  </p>
<p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-cpu.png" alt=""></div><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomIo</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> isVal = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> raddr = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>) </span><br><span class="line">	<span class="keyword">val</span> rdata = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RamIo</span> <span class="keyword">extends</span> <span class="title">RomIo</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> isWr = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> wdata = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在控制逻辑可以根据这些接口构建接口：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CpathIo</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> imem = <span class="type">RomIo</span>().flip() </span><br><span class="line">	<span class="keyword">val</span> dmem = 	<span class="type">RamIo</span>().flip() </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而且控制和数据通路模块可以通过部分地分配来给这个接口来构建，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpath</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">CpathIo</span>();</span><br><span class="line">	...</span><br><span class="line">	io.imem.isVal := ...;</span><br><span class="line">	 io.dmem.isVal := ...; </span><br><span class="line">	 io.dmem.isWr := ...; </span><br><span class="line">	 ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dpath</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">DpathIo</span>(); </span><br><span class="line">	...</span><br><span class="line">	io.imem.raddr := ...; </span><br><span class="line">	io.dmem.raddr := ...; </span><br><span class="line">	io.dmem.wdata := ...;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们现在可以使用批量连接来连接CPU，就像使用其他bundle一样：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpu</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">CpuIo</span>()</span><br><span class="line">	<span class="keyword">val</span> c = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">CtlPath</span>()) </span><br><span class="line">	<span class="keyword">val</span> d = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">DatPath</span>()) </span><br><span class="line">	c.io.ctl &lt;&gt; d.io.ctl</span><br><span class="line">	c.io.dat &lt;&gt; d.io.dat </span><br><span class="line">	c.io.imem &lt;&gt; io.imem</span><br><span class="line">	d.io.imem &lt;&gt; io.imem</span><br><span class="line">	c.io.dmem &lt;&gt; io.dmem</span><br><span class="line">	d.io.dmem &lt;&gt; io.dmem</span><br><span class="line">	d.io.host &lt;&gt; io.host</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="模块的功能创建"><a href="#模块的功能创建" class="headerlink" title="模块的功能创建"></a>模块的功能创建</h1><p>制造用于模块构造的功能接口也是有用的。例如，我们可以构建一个构造函数，它将多路复用器输入作为参数，并返回多路复用器输出：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Mux2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(sel: <span class="type">UInt</span>, in0: <span class="type">UInt</span>, in1: <span class="type">UInt</span>) = &#123;</span><br><span class="line">		<span class="keyword">val</span> m = <span class="keyword">new</span> <span class="type">Mux2</span>() </span><br><span class="line">		m.io.in0 := in0 </span><br><span class="line">		m.io.in1 := in1 </span><br><span class="line">		m.io.sel := sel </span><br><span class="line">		m.io.out</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中对象Mux2在Mux2模块类中创建一个Scala单例对象，并且apply定义了创建Mux2实例的方法。有了这个Mux2创建功能，Mux4的规格现在明显更简单。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux4</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> in0 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">val</span> in1 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in2 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in3 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> sel = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">2</span>) </span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	io.out := <span class="type">Mux2</span>(io.sel(<span class="number">1</span>), <span class="type">Mux2</span>(io.sel(<span class="number">0</span>), io.in0, io.in1), <span class="type">Mux2</span>(io.sel(<span class="number">0</span>), io.in2, io.in3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel提供MuxCase，其本质上是一个n-way Mux。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MuxCase</span>(<span class="keyword">default</span>, <span class="type">Array</span>(c1 -&gt; a, c2 -&gt; b, ...))</span><br></pre></td></tr></table></figure></p>
<p>其中每个条件/值在Scala数组中表示为元组，并且其中MuxCase可以转换为以下Mux表达式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Mux</span>(c1, a, <span class="type">Mux</span>(c2, b, <span class="type">Mux</span>(..., <span class="keyword">default</span>)))</span><br></pre></td></tr></table></figure></p>
<p>Chisel还提供MuxLookup，其本质是一个n-way的可索引多路选择器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MuxLookup</span>(idx, <span class="keyword">default</span>,</span><br><span class="line">	<span class="type">Array</span>(<span class="type">UInt</span>(<span class="number">0</span>) -&gt; a, <span class="type">UInt</span>(<span class="number">1</span>) -&gt; b, ...))</span><br></pre></td></tr></table></figure></p>
<p>这可以用MuxCase来重写：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MuxCase</span>(<span class="keyword">default</span>,<span class="type">Array</span>((idx === <span class="type">UInt</span>(<span class="number">0</span>)) -&gt; a,(idx === <span class="type">UInt</span>(<span class="number">1</span>)) -&gt; b, ...))</span><br></pre></td></tr></table></figure></p>
<h1 id="多态性和参数化"><a href="#多态性和参数化" class="headerlink" title="多态性和参数化"></a>多态性和参数化</h1><p>Scala是一种强类型语言，使用参数化类型来指定通用函数和类。 在本节中，我们展示了Chisel用户如何使用参数化类来定义自己的可重用函数和类。  </p>
<h2 id="参数化函数"><a href="#参数化函数" class="headerlink" title="参数化函数"></a>参数化函数</h2><p>前面我们在Bool上定义了Mux2，但现在我们展示如何定义一个通用的多路复用器功能。我们使用一个布尔条件和con和alt参数（对应于then和else表达式）来定义一个T类型的函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux</span></span>[<span class="type">T</span> &lt;: <span class="type">Bits</span>](c: <span class="type">Bool</span>, con: <span class="type">T</span>, alt: <span class="type">T</span>): <span class="type">T</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中T需要是Bits的子类。Scala确保在Mux的每个使用中，它可以找到实际的con和alt参数类型的公共超类，否则会导致Scala编译类型错误。例如，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Mux</span>(c, <span class="type">UInt</span>(<span class="number">10</span>), <span class="type">UInt</span>(<span class="number">11</span>))</span><br></pre></td></tr></table></figure></p>
<p>这会产生一个UInt线，因为con和alt参数都是UInt类型。<br>我们现在提出一个更高级的参数化函数的例子，用于定义一个内积FIR数字滤波器，通常用于Chisel Num。 内积FIR滤波器可以在数学上定义为：  </p>
<p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-gongshi.png" alt=""></div><br>其中x是输入，w是权重向量。在Chisel中，这可以定义为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delays</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](x: <span class="type">T</span>, n: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">T</span>] =</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="type">List</span>(x) <span class="keyword">else</span> x :: <span class="type">Delays</span>(<span class="type">RegNext</span>(x), n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FIR</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span> <span class="keyword">with</span> <span class="type">Num</span>[<span class="type">T</span>]](ws: <span class="type">Seq</span>[<span class="type">T</span>], x: <span class="type">T</span>): <span class="type">T</span> = </span><br><span class="line">	(ws, <span class="type">Delays</span>(x, ws.length)).zipped.map( _ * _ ).reduce( _ + _ )</span><br></pre></td></tr></table></figure></p>
<p>其中延迟产生其输入的增量递增延迟的列表，并且reduce构造给出二进制组合器函数f的简化电路。在这种情况下，reduce创建一个求和电路。最后，FIR函数被限制为处理类型Num的输入，其中定义了Chisel乘法和加法。  </p>
<h2 id="参数化类"><a href="#参数化类" class="headerlink" title="参数化类"></a>参数化类</h2><p>与参数化函数一样，我们也可以参数化类，使它们可重用程度更高。例如，我们可以将Filter类概括为可以使用任何类型的链接。我们可以通过参数化FilterIO类和定义构造函数采取零参数类型构造函数来做到这点，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterIO</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">type: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> x = <span class="class"><span class="keyword">type</span>.<span class="title">asInput</span>.<span class="title">flip</span></span></span><br><span class="line"><span class="class">	<span class="title">val</span> <span class="title">y</span> </span>= <span class="class"><span class="keyword">type</span>.<span class="title">asOutput</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们现在可以通过定义一个模块类来定义Filter，该模块类也接收一个链接类型构造函数参数，并将其传递给FilterIO接口构造器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">type: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">FilterIO</span>(<span class="class"><span class="keyword">type</span>)</span></span><br><span class="line"><span class="class">	...</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们现在可以定义一个基于PLant的过滤器，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Filter</span>(<span class="keyword">new</span> <span class="type">PLink</span>()))</span><br></pre></td></tr></table></figure></p>
<p>其中大括号{}表示零参数函数（也称为thunk），在这种情况下创建链接类型。<br>通用FIFO可以这样定义，并使用如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBundle</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> <span class="type">A</span> = <span class="type">UInt</span>(width = <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">val</span> <span class="type">B</span> = <span class="type">UInt</span>(width = <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FifoDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>() = <span class="keyword">new</span> <span class="type">Fifo</span>(<span class="keyword">new</span> <span class="type">DataBundle</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fifo</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (<span class="params">type: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> enq_val = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> enq_rdy = <span class="type">Bool</span>(<span class="type">OUTPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> deq_val = <span class="type">Bool</span>(<span class="type">OUTPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> deq_rdy = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> enq_dat = <span class="class"><span class="keyword">type</span>.<span class="title">asInput</span> </span></span><br><span class="line"><span class="class">		<span class="title">val</span> <span class="title">deq_dat</span> </span>= <span class="class"><span class="keyword">type</span>.<span class="title">asOutput</span></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">	<span class="title">val</span> <span class="title">enq_ptr</span> </span>= <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, sizeof(n)))</span><br><span class="line">	<span class="keyword">val</span> deq_ptr = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, sizeof(n)))</span><br><span class="line">	<span class="keyword">val</span> is_full = <span class="type">Reg</span>(init = <span class="type">Bool</span>(<span class="literal">false</span>))</span><br><span class="line">	<span class="keyword">val</span> do_enq  = io.enq_rdy &amp;&amp; io.enq_val</span><br><span class="line">	<span class="keyword">val</span> do_deq  = io.enq_rdy &amp;&amp; io.deq_val </span><br><span class="line">	<span class="keyword">val</span> is_empty = !is_full &amp;&amp; (enq_ptr === deq_ptr)</span><br><span class="line">	<span class="keyword">val</span> deq_ptr_inc = deq_ptr + <span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">val</span> enq_ptr_inc = enq_ptr + <span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">val</span> is_full_next = <span class="type">Mux</span>(do_enq &amp;&amp; ~do_deq &amp;&amp; (enq_ptr_inc === deq_ptr), <span class="type">Bool</span>(<span class="literal">true</span>), <span class="type">Mux</span>(do_deq &amp;&amp; is_full, <span class="type">Bool</span>(<span class="literal">false</span>), is_full)) </span><br><span class="line">	enq_ptr := <span class="type">Mux</span>(do_enq, enq_ptr_inc, enq_ptr) </span><br><span class="line">	deq_ptr := <span class="type">Mux</span>(do_deq, deq_ptr_inc, deq_ptr) </span><br><span class="line">	is_full := is_full_next</span><br><span class="line">	<span class="keyword">val</span> ram = <span class="type">Mem</span>(n) </span><br><span class="line">	when (do_enq) &#123;</span><br><span class="line">		ram(enq_ptr) := io.enq_dat </span><br><span class="line">	&#125;</span><br><span class="line">	io.enq_rdy := !is_full </span><br><span class="line">	io.deq_val := !is_empty </span><br><span class="line">	ram(deq_ptr) &lt;&gt; io.deq_dat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以定义成通用解耦接口：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoupledIO</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">data: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> ready = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> bits = data.clone.asOutput </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后可以使用该模板向任何信号集添加握手：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoupledDemo</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">DecoupledIO</span>(<span class="params"></span>)(<span class="params"> new <span class="type">DataBundle</span> </span>)</span></span><br></pre></td></tr></table></figure></p>
<p>FIFO的接口也可以如下进行简化：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fifo</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (<span class="params">data: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> enq = <span class="keyword">new</span> <span class="type">DecoupledIO</span>( data ).flip() </span><br><span class="line">		<span class="keyword">val</span> deq = <span class="keyword">new</span> <span class="type">DecoupledIO</span>( data )</span><br><span class="line">	&#125;</span><br><span class="line">	... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多时钟域"><a href="#多时钟域" class="headerlink" title="多时钟域"></a>多时钟域</h1><p>Chisel 2.0介绍了对多时钟域的支持。  </p>
<h2 id="创建时钟域"><a href="#创建时钟域" class="headerlink" title="创建时钟域"></a>创建时钟域</h2><p>为了使用多个时钟域，用户必须创建多个时钟。 在Chisel中，时钟是使用复位信号参数创建的第一级节点，定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> (<span class="params">reset: <span class="type">Bool</span></span>) <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>: <span class="type">Bool</span> <span class="comment">// returns reset pin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Chisel中有一个内置的隐式时钟，状态元素默认使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> implicitClock = <span class="keyword">new</span> <span class="type">Clock</span>( implicitReset )</span><br></pre></td></tr></table></figure></p>
<p>状态元素和模块的时钟可以使用名为clock的附加命名参数来定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reg</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Mem</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Module</span>(... clock: <span class="type">Clock</span> = implicitClock)</span><br></pre></td></tr></table></figure></p>
<h2 id="交叉时钟域"><a href="#交叉时钟域" class="headerlink" title="交叉时钟域"></a>交叉时钟域</h2><p>有两种方式可以定义电路在时钟域之间发送数据。第一种也是最原始的方式就是使用由两个寄存器组成的同步器电路，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signalA is in clock domain clockA,</span></span><br><span class="line"><span class="comment">// want a version in clockB as signalB</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB) </span><br><span class="line"><span class="keyword">val</span> s2 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB)</span><br><span class="line">s1 := signalA</span><br><span class="line">s2 := s1;</span><br><span class="line">signalB := s2</span><br></pre></td></tr></table></figure></p>
<p>由于亚稳性问题，该技术只限于在域之间传递一位数据。<br>在域之间发送数据的第二种和更一般的方式是通过使用异步fifo：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncFifo</span>[<span class="type">T</span>&lt;:<span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, entries: <span class="type">Int</span>, enq_clk: <span class="type">Clock</span>, deq_clock:<span class="type">Clock</span></span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br></pre></td></tr></table></figure></p>
<p>当通过指定标准fifo参数和两个时钟，然后使用标准解耦就绪/有效信号从时钟域clockA到clockB获取一个版本的signalA时：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fifo = <span class="keyword">new</span> <span class="type">AsyncFifo</span>(<span class="type">Uint</span>(width = <span class="number">32</span>), <span class="number">2</span>, clockA, clockB)</span><br><span class="line">fifo.io..enq.bits	:= signalA</span><br><span class="line">signalB				:= fifo.io.deq.bits</span><br><span class="line">fifo.io.enq.valid	:= condA</span><br><span class="line">fifo.io.deq.ready	:= condB</span><br></pre></td></tr></table></figure></p>
<h2 id="后端特定的多个时钟域"><a href="#后端特定的多个时钟域" class="headerlink" title="后端特定的多个时钟域"></a>后端特定的多个时钟域</h2><p>每个Chisel后端需要用户以后端特定的方式设置和控制多个时钟。为了展示如何驱动一个多时钟设计，考虑这样一个硬件示例，其中两个模块使用Async-Fifo进行通信，每个模块在不同的时钟：fastClock和slowClock。  </p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>在C++后端，对于每个时钟i有：  </p>
<ul>
<li>size_t clk.len域表示时钟i的周期  </li>
<li>clock_lo_i，clock_hi_i</li>
<li>int reset() 函数，可以保证clock_lo和clock_hi的所有函数被立刻调用  </li>
<li>int clock(reset)函数，计算最小增量，调用合适的clock_lo和clock_hi，并返回使用的最小增量。  </li>
</ul>
<p>为了设置一个C++模拟器，用户需要：  </p>
<ul>
<li>将所有周期字段初始化为期望的周期  </li>
<li>将所有计数字段初始化为期望的相位  </li>
<li>调用reset</li>
<li>重复调用时钟来单步模拟  </li>
</ul>
<p>以下是slowClock / fastClock的main函数C++示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123; </span><br><span class="line">	ClkDomainTest_t dut; dut.init(<span class="number">1</span>);</span><br><span class="line">	dut.clk = <span class="number">2</span>;</span><br><span class="line">	dut.clk_cnt = <span class="number">1</span>; </span><br><span class="line">	dut.fastClock = <span class="number">4</span>; </span><br><span class="line">	dut.fastClock_cnt = <span class="number">0</span>; </span><br><span class="line">	dut.slowClock = <span class="number">6</span>; 	</span><br><span class="line">	dut.slowClock_cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i ++)</span><br><span class="line">	dut.reset();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i ++)</span><br><span class="line">		dut.clock(LIT&lt;<span class="number">1</span>&gt;(<span class="number">0</span>)); &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h3><p>在Verilog中：  </p>
<ul>
<li>Chisel为每个时钟/复位创建一个新端口，  </li>
<li>Chisel将所有的时钟连到顶层模块  </li>
<li>用户必须要为每个时钟i创建一个always块时钟驱动  </li>
</ul>
<p>以下是驱动slowClock / fastClock电路的顶层Verilog示例：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> emulator;</span><br><span class="line">	<span class="keyword">reg</span> fastClock = <span class="number">0</span>, slowClock = <span class="number">0</span>, resetFast = <span class="number">1</span>, resetSlow = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] add, mul, test;</span><br><span class="line">	<span class="keyword">always</span> #<span class="number">2</span> fastClock = ~fastClock;</span><br><span class="line">	<span class="keyword">always</span> #<span class="number">4</span> slowClock = ~slowClock; </span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		# <span class="number">8</span></span><br><span class="line">		resetFast = <span class="number">0</span>; </span><br><span class="line">		resetSlow = <span class="number">0</span>; </span><br><span class="line">		#<span class="number">400</span></span><br><span class="line">	<span class="built_in">$finish</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ClkDomainTest dut (</span><br><span class="line">	<span class="variable">.fastClock</span>(fastClock), </span><br><span class="line">	<span class="variable">.slowClock</span>(slowClock), </span><br><span class="line">	<span class="variable">.io_resetFast</span>(resetFast),</span><br><span class="line">	<span class="variable">.io_resetSlow</span>(resetSlow),</span><br><span class="line">	<span class="variable">.io_add</span>(add), </span><br><span class="line">	<span class="variable">.io_mul</span>(mul), </span><br><span class="line">	<span class="variable">.io_test</span>(test));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>（完）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2016/12/14/computer-boot-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="包楚权">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/slamdunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="包楚权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/14/computer-boot-process/" itemprop="url">计算机那些事(1)——开机启动过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-14T14:26:23+08:00">
                2016-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机原理/" itemprop="url" rel="index">
                    <span itemprop="name">计算机原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先用一张图来大致了解一下计算机启动的整个过程。</p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/computer-boot-up-timeline.png" alt=""></div>

<h1 id="上电"><a href="#上电" class="headerlink" title="上电"></a>上电</h1><p>按下主机的电源键后，计算机开始启动，主板上电后开始初始化其固件（firmware）。固件是一些固化在芯片组上的程序，它会试图去启动CPU。如果启动失败（例如CPU坏了或没插好），计算机就会死机并给出错误提示（如某些版本的主板固件会发出蜂鸣警告）。这种状态称为“zoombie-with-fans”。  </p>
<p>如果前一个阶段未出错，就开始加电工作，在多CPU或多核CPU情况下，某一个CPU会被随机选取作为启动CPU（bootstrap processor，BSP）运行BIOS内部的程序。其余的CPU（application processor，AP）保持停机直到操作系统内核显式地使用它们。  </p>
<blockquote>
<p>2000年以前的计算机主板上均使用<a href="https://zh.wikipedia.org/wiki/BIOS" target="_blank" rel="noopener">BIOS</a>，如今绝大多数计算机采用的是<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2" target="_blank" rel="noopener">EFI</a>（Mac用的就是EFI）或<a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface" target="_blank" rel="noopener">UEFI</a>，BIOS正在逐步被淘汰。基于EFI、UEFI的开机过程与传统的BIOS不尽相同，本文将以传统的BIOS，Intel CPU为例介绍开机过程。  </p>
</blockquote>
<p>此时CPU工作模式为实模式，该模式下地址总线是20位，寻址范围是0x00000~0xFFFFF的1M范围。这也就解释了为什么BIOS的容量只有1MB。  </p>
<blockquote>
<p>Intel CPU用三种运行模式: 实模式、32位保护模式、64位保护模式。实模式: Intel 8086的寻址方案，为了商业连续性，兼容了这古老的方案；保护模式: 采用了虚实地址转换方案。</p>
</blockquote>
<p>BIOS启动之初，内存是空的。此时CPU处于实模式，内存的地址映射均为硬连接的设备。内存映射图如下图所示:  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/computer-boot-memory.jpg" alt=""></div>  

<h1 id="重置向量"><a href="#重置向量" class="headerlink" title="重置向量"></a>重置向量</h1><p>CPU启动后其大多数寄存器会被初始化为预定的值，包括指令寄存器（instruction pointer, EIP），它保存着CPU将要执行指令的内存地址。此时CPU会有一个特殊行为，其会对EIP的初始值加上一个基址寄存器的值，生成一个32位的地址0xFFFFFFF0。之所以称为特殊行为，是因为实模式下CPU只能寻址1MB地址空间，而这个32位地址已经大于1MB的内存限制。因此，0xFFFFFFF0也被称为重置向量（reset vector），参考上图0xFFFFFFF0处的标识。  </p>
<p>于是，CPU开始执行0xFFFFFFF0地址处的指令，该地址处是一条JUMP指令，这条指令清空了基址寄存器的值，并让指令跳回到BIOS开始处（物理地址为0xF0000，参考上图0xF0000处的标识）以执行BIOS。</p>
<blockquote>
<p>BIOS内部可以分成两个区块: code block（普通程序）、boot block（引导程序）。上电后，boot block会先被执行，它会检查code block的代码是否正确，如果正确，就会转到code block继续执行下去。  </p>
</blockquote>
<h1 id="BIOS初始化"><a href="#BIOS初始化" class="headerlink" title="BIOS初始化"></a>BIOS初始化</h1><p>0xF0000地址实际上是BIOS中的boot block的开始处。在这个阶段，会初始化部分硬件。系统的CPU、USB只有部分被初始化。</p>
<h1 id="BIOS-POST（加电自检）"><a href="#BIOS-POST（加电自检）" class="headerlink" title="BIOS POST（加电自检）"></a>BIOS POST（加电自检）</h1><p>初始化完成后，CPU跳转到0xA0000地址处（参考上图640KB处）进行BIOS加电自检（power on self test, POST）。这个过程会检查计算机的各项组件，如CPU、显卡、内存、鼠标、键盘等。如果找不到内存或者键盘都有可能让BIOS停止工作并且打印一些相关的错误信息，如果找不到显卡BIOS会发出蜂鸣警告（因为无法显示画面）<br>当CPU执行到0xC0000地址处（参考上图768KB处），开始寻找其他设备的ROM，如果找到任何其他设备的BIOS，它们也会被执行。<br>下一步，显卡就会显示BIOS界面，并进行更深入的检查。</p>
<h1 id="BIOS记录系统设定值"><a href="#BIOS记录系统设定值" class="headerlink" title="BIOS记录系统设定值"></a>BIOS记录系统设定值</h1><p>检查完成后，BIOS会根据自己的“系统资源表”，对系统进行进一步确认，从而确定计算机配有哪些资源或设备。例如BIOS支持随插即用，它会检测并配置随插即用设备。<br>然后BIOS会遵循高级配置电源接口（Advanced Configuration Power Interface，ACPI）在内存中设置好一系列的数据来描述硬件信息，以便被操作系统内核利用。</p>
<h1 id="搜索MBR"><a href="#搜索MBR" class="headerlink" title="搜索MBR"></a>搜索MBR</h1><p>到这一步，BIOS开始尝试加载操作系统。它会从硬盘，光驱，软驱，网络等几个地方依次寻找操作系统（用户可以在BIOS设定中修改查找的优先级）。如果找不到操作系统，BIOS会停机并给出错误信息。  </p>
<p>假设在硬盘上找到了操作系统，它会首先读取硬盘上的大小为512B的0号扇区，这个扇区被称为<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95" target="_blank" rel="noopener">主引导记录</a>（master boot record，MBR），其包含三部分：<br>(1) <strong>启动代码</strong><br>(2) <strong>硬盘分区表</strong><br>(3) <strong>结束标志字</strong>  </p>
<p>BIOS读完磁盘上的MBR之后会把它拷贝到内存0x7C00地址处，然后CPU跳转到该内存地址执行MBR里的指令。下图可以帮助大家理解MBR的结构。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/computer-boot-MBR.png" alt=""></div>  

<blockquote>
<p><strong>启动代码</strong>中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（Windows里面是Windows MBR Loader，Linux的话可能是<a href="https://zh.wikipedia.org/zh-hans/LILO" target="_blank" rel="noopener">LILO</a>或者<a href="https://zh.wikipedia.org/wiki/GNU_GRUB" target="_blank" rel="noopener">GRUB</a>）。<br><strong>磁盘分区表</strong>是固定的，一个64字节的区域，每16字节为一个条目，描述硬盘的分区信息（这样就可以在同一磁盘的不同分区上安装不同的操作系统）。所以采用了MBR格式分区表的文件系统最多能安装四个操作系统。  </p>
</blockquote>
<h1 id="引导操作系统"><a href="#引导操作系统" class="headerlink" title="引导操作系统"></a>引导操作系统</h1><p>执行MBR内部启动代码中的引导程序可以引导操作系统。Linux的引导程序LILO和GRUB可以处理各种不同的操作系统，文件系统和引导配置。</p>
<ol>
<li>根据MBR启动代码中的引导程序加载包含了额外引导代码的其他扇区。这些扇区可能是一个分区的引导扇区，也可能是MBR安装时硬编码到MBR代码中的某个扇区。  </li>
<li>执行步骤1载入的引导代码读取配置文件（例如，GRUB中是grub.conf，windows中是boot.ini）。然后它会显示启动选项，或直接启动操作系统</li>
<li>此时引导程序开始引导操作系统内核。它必须能够识别内核所在引导分区的文件系统。在Linux中，这一步是读取一个类似“<a href="https://zh.wikipedia.org/wiki/Vmlinux" target="_blank" rel="noopener">vmlinuz</a>”的文件，加载至内存中并跳转到内核启动代码。</li>
</ol>
<p>此时我们回头再看第一张图，从引导程序到早期的内核初始化过程，此时内核解压开始了。</p>
<p>（完）</p>
<p><strong>参考</strong><br>[1] <a href="http://duartes.org/gustavo/blog/post/how-computers-boot-up/" target="_blank" rel="noopener">How Computers Boot Up</a><br>[2] <a href="http://www.techbang.com/posts/4359" target="_blank" rel="noopener">即将换掉传统BIOS的UEFI</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2016/12/01/riscv-brief-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="包楚权">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/slamdunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="包楚权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/01/riscv-brief-introduction/" itemprop="url">RISC-V——针对SoC的一套开放标准</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-01T16:47:17+08:00">
                2016-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/riscv-logo.png" alt=""></div>

<p><strong>对于大多数计算设备来说Linux已经成为了标准的操作系统，伯克利的研究者希望RISC-V也能够像Linux一样成为所有计算设备的标准ISA</strong>  </p>
<p>片上系统（systems-on-a-chip, SoCs)，集成了处理器和cache，如今已经被越来越广泛的运用到各个领域之中。因此有越来越多的公司加入到了芯片制造这个领域之中。鉴于业界已经通过开放标准和开源软件进行了革命——如TCP/IP和Linux。那么作为最重要的接口之一的指令系统（instruction set architecture，ISA）为什么不对所有人开放呢？  </p>
<p>尽管指令系统由于历史或商业原因变得专利化了，但是从技术角度来看，必须要有免费的、开放的ISA。  </p>
<p><em>这并不是一个遗漏的错误</em>。一些拥有很成功ISA的公司，如ARM，IBM，Intel，MIPS都拥有针对他们自己的ISA的专利，而这使得我们这些没有license的学术机构和小公司根本无法使用这些ISA，除非付出巨额的费用。</p>
<p>而ARM的license甚至还不允许你设计自己的ARM核；而是只能使用其设计。目前世界上大约只有10家大公司才拥有修改其设计自己的ARM核的license。这就是商业，通过阻止别人进行设计改造从而扼杀了竞争和创新。  </p>
<p><em>也不是因为公司做大部分的软件开发</em>。虽然围绕这些流行ISA的软件生态系统有着非常高价值，但这几乎都是外人构建了所有的软件。  </p>
<p><em>并不只有公司具备设计合格的ISA的能力</em>。虽然设计ISA涉及到大量工作，但是今天有很多机构或公司有能力设计ISA。  </p>
<p><em>最流行的ISA并不见得是完美的ISA</em>。ARM和80x86不被视为完美的ISA。  </p>
<p><em>也不是只有设计ISA的公司才能验证它们</em>。很久以前，开放组织开发了可以确保与诸如浮点单元（IEEE 754），网络芯片和交换机（以太网）和I/O总线（PCIe）的硬件标准兼容的机制。如果没有这样的组织，开放的IT标准也不会那么受欢迎。  </p>
<p><em>最后，专有ISA不能保证永远存活下去</em>。如果一个公司倒闭了，它的ISA也会随之消亡。Digital Equipment公司的消亡导致Alpha和VAX ISA也一起终结了。注意，ISA实际上是一个接口规范，而不是实现。  </p>
<p>其实有应该三种类型的ISA实现：<br>(1) 私有的闭源，如AppleiOS<br>(2) 许可的开源，如Wind River VxWorks<br>(3) 免费的开源，用户可以修改、共享，如Linux</p>
<p>拥有专利的ISA实际上允许前两种类型，但是我们还需要一种免费开放的ISA。  </p>
<p>我们的结论是，业界将受益于可行的，免费开放的ISA，就像它从免费开放的软件栈中获益。例如，它将实现一个真正的，自由，开放的处理器设计市场，拥有专利的ISA阻止了这样一个市场的诞生。这样的市场会具有： </p>
<ul>
<li><strong>更强大的创新能力</strong>: 通过源自更多设计师的自由市场竞争，包括开放ISA与专有的ISA的竞争。  </li>
<li><strong>共享的、开放的核心设计</strong>: 这意味着更短的上市时间，更低的成本（由于重复使用），更少的错误（因为有更多人的关注），比如这将使政府机构加入涉密后门更困难。  </li>
<li><strong>负担得起的处理器</strong>: 更多的设备能够负担得起处理器的费用，这将有助于扩大物联网，其目标成本可能只有1美元。</li>
</ul>
<p>要想让开源社区拥抱如此的开源ISA，我们认为它需要一个可靠的商业记录。第一个问题是，哪种风格的ISA有成功的历史？  </p>
<p>在30年来没有这样的成功的ISA。除了DSP市场的一部分，VLIW已经失败了：Multiflow也不行，Itanium破产了，尽管惠普和英特尔投资了数十亿美元。没有新的CISC ISA可以成功数十年。幸存的CISC从复杂的ISA转换为更容易执行的ISA，这对于制定有价值的遗留代码基础是非常有意义的。  </p>
<p>一套新的ISA不会有任何遗留代码，所以额外的硬件成本和翻译的开销成本很难证明：为什么不是只使用易于执行的ISA在第一位？ RISC风格load-store ISA可以追溯到至少50年到Seymour Cray的CDC 6600.虽然80x86赢得了PC战争，RISC主导后PC时代的平板电脑和智能手机; 在2013年超过100亿基于ARM的SoC出货，相比之下，80x86芯片只有3亿。  </p>
<p>鉴于ISA可以存活数十年，我们预测未来的技术景观，看看哪些功能对于基于RISC的免费开放ISA可能是重要的。 三个平台可能占据主导地位：物联网，个人移动设备和仓库规模计算机（WSC）。 这个蓝图式的建议有四个关键要求：<br>(1) <strong>基本、扩展ISA</strong>: 为了匹配SoC的需求，同时保持稳定的软件基础，自由的，开放的ISA应该具有：</p>
<ul>
<li>编译器和操作系统可以依赖的一小组核心指令  </li>
<li>标准且可扩展的ISA，可以为应用程序定制SoC  </li>
<li>可调用特定应用程序加速器的全新操作码的空间<br>这符合当今SoC经常使用自定义应用程序特定加速器的做法。  </li>
</ul>
<p>(2) <strong>紧凑指令集编码</strong>: 考虑到IoT的成本敏感性和对小容量存储器的期望，较小代码是可取的。<br>(3) <strong>四精度（QP）以及单精度和双精度浮点</strong>: 在WSC中运行的一些应用程序处理这样的大数据集，这依靠软件库进行QP运算。<br>(4) <strong>128位寻址以及32位和64位</strong>: 物联网上的节点的有限内存大小意味着32位寻址在未来几十年将是非常重要的，而64位寻址是更高要求的标准。尽管WSC行业不需要128位的运算，但是在十年内，WSC可能需要超过64位（16艾字节）来寻址所有的固态，非易失性存储器。  </p>
<p>这些都是需要很多年才能确认是否正确的细节，所以似乎使用现有的ISA起步是更聪明的做法，而不是成立委员会，从头开始。 RISC ISAs都很相似，所以其中很多都可能是很好的选择。好消息是，已经有三个开源RISC ISA：SPARC，OpenRISC和RISC-V。  </p>
<p>只有RISC-V满足上述所有四个要求（见下表）。 RISC-V也是10到20岁的年轻人，所以我们可以从以前的RISC ISA的错误中学习和修复——例如，SPARC和OpenRISC延迟分支——这就是为什么RISC-V是如此简单和干净。 此外，SPARC（V9）的64位地址版本是专有的，而OpenRISC可能失去了动力。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/RISC-ISA-compare.gif" alt=""></div>

<p>RISC-V有很大的发展势头，到目前为止，它有来自Berkeley的8个芯片实现，以及在印度，英国和美国的外部项目。 由于开源Chisel硬件设计系统，一个64位RISC-V核要比类似过程制造的32位ARM内核快，且功耗和速度均为后者的一半。  </p>
<p>虽然很难摒弃我们的偏见，但我们认为RISC-V是自由，开放RISC ISA的最好的、最安全的选择。为了扩大这个免费的，开放的ISA的社区，我们将提供研讨会和创建一个非营利基础，以验证实施和维护和发展RISC-V。</p>
<p>虽然RISC-V的第一个首要目标是物联网，但我们有着更为远大的目标：正如Linux已成为大多数计算设备的标准操作系统一样，我们设想RISC-V成为所有计算设备的标准ISA。  </p>
<p>目前已经有大量公司和机构加入并关注着RISC-V的发展。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/google.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/microsoft_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ibmpos_blurgb.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/NVIDIA.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/amd_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/huawei.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/westerndigital.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oracle.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/uc_berkeley_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/microsemi.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/lowrisc.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/nxp.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/minima_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/codasip.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/eth_zurich_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/grayresearch.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/esperanto_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/cortus_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/roalogic.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/lattice.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ultra_soc.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/mircon.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sifive.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bluespec.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/baesystems.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/espressif.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ict-logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/rumble.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/IDT.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/syntacore.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/andes_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/antmicro.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/blockstream_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/iit_madras_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/technolution.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/Mellanox_logo.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/Rambus-Cryptography-Research.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/draper.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/intrinsix.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/runtime.png" alt=""></div>

<p>（完）</p>
<p><strong>参考</strong><br>[1] <a href="http://www.eetimes.com/author.asp?doc_id=1323406&amp;page_number=1" target="_blank" rel="noopener">RISC-V: An Open Standard for SoCs</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2016/11/10/advanced-chisel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="包楚权">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/slamdunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="包楚权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/10/advanced-chisel/" itemprop="url">Chisel高级参数化详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-10T21:43:23+08:00">
                2016-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>本文为Chisel高级参数库手册。关于Chisel更多通用信息请参考Getting Started文档。<br>随着硬件设计的复杂度的不断提高，模块化对于验证和复用都是非常重要的。Chisel的主要应用案例就是描述各种高度可配置的硬件生成器，我们很快意识到传统的参数化方式迫使设计的源代码非常脆弱，并且限制了组件的重用。</p>
<h1 id="2-高级参数化"><a href="#2-高级参数化" class="headerlink" title="2. 高级参数化"></a>2. 高级参数化</h1><p>每个Chisel Module有一个Parameters类的成员参数，其提供在模块之间传递参数的机制。<br>本节描述以下这些特征:<br>(1) <strong>Parameters</strong>类及其相关的方法/成员；<br>(2) 基本使用模型；<br>(3) 语法糖；<br>(4) 向外部用户/程序暴露参数的模板代码；<br>(5) <strong>Views(site, here, up)</strong>的高级功能；</p>
<h2 id="2-1-类和方法"><a href="#2-1-类和方法" class="headerlink" title="2.1 类和方法"></a>2.1 类和方法</h2><p><strong>Parameters</strong>有以下这些基本方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parameters</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回类型T的一个值</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](key:<span class="type">Any</span>):<span class="type">T</span></span><br><span class="line">	<span class="comment">// 返回一个新的Parameters类</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">alter</span></span>(mask:(<span class="type">Any</span>,<span class="type">View</span>,<span class="type">View</span>,<span class="type">View</span>)=&gt;<span class="type">Any</span>):<span class="type">Paramters</span></span><br><span class="line">	<span class="comment">// 返回一个模块的Parameters实例</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">params</span></span>:<span class="type">Parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>View</strong>是一个只包含一个基本方法的类:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回类型T的一个值</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](key:<span class="type">Any</span>):<span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Parameters</strong>有一个工厂对象，其包含一个基本的方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Parameters</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个空的Parameters实例</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">empty</span></span>:<span class="type">Parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Module</strong>工厂对象有一个附加的<strong>apply</strong>方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个新的类型T的Module，如果_p!=None，则由一个Parameters实例初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>&lt;:<span class="type">Module</span>](<span class="type">C</span>: =&gt; <span class="type">T</span>)(<span class="keyword">implicit</span> _p: <span class="type">Option</span>[<span class="type">Parameters</span>] = <span class="type">None</span>):<span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-基本使用模型"><a href="#2-2-基本使用模型" class="headerlink" title="2.2 基本使用模型"></a>2.2 基本使用模型</h2><p>这个例子示范了最简单的用法: (1)查询参数; (2) 改变Parameters对象; (3) 传递一个Parameters对象到一个Module。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params[<span class="type">Int</span>](<span class="symbol">'widt</span>h')</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Top</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> parameters = <span class="type">Parameters</span>.empty</span><br><span class="line">	<span class="keyword">val</span> tile_parameters = parameters.alter((key, site, here, up) =&gt; &#123;<span class="keyword">case</span> <span class="symbol">'widt</span>h' =&gt; <span class="number">64</span>&#125;)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">		chiselMain(args,()=&gt;<span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Tile</span>)(<span class="type">Some</span>(tile_paramters)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<strong>Module Tile</strong>中，<strong>params</strong>成员被查询，通过调用<strong>Parameters.apply</strong>传递key并返回value类型。<br>在<strong>Top</strong>中，通过调用<strong>Parameters.empty</strong>创建了一个空的<strong>parameters</strong>；然后通过<strong>(Any, View, View, View) =&gt; Any</strong>函数修改参数值并返回一个新的<strong>Parameters</strong>实例，并赋值给<strong>tile_parameters</strong>。<br>将<strong>tile_parameters</strong>包装在<strong>Some:Option[Parameters]</strong>之后，当其被传递给<strong>chiselMain</strong>时，它会被作为第二个参数传递给<strong>Module</strong>对象。  </p>
<h2 id="2-3-语法糖-Field-T"><a href="#2-3-语法糖-Field-T" class="headerlink" title="2.3 语法糖: Field[T]"></a>2.3 语法糖: Field[T]</h2><p>一个简单的例子: 要求返回类型<strong>Int</strong>必须作为参数传给<strong>apply</strong>方法；否则Scala编译器会抛出错误:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params[<span class="type">Int</span>](<span class="symbol">'widt</span>h')</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示的代码示例为一种参数查询的方式，还有一种方式如下所示，可以为每个<strong>key</strong>创建一个<strong>case object</strong>，该对象继承自<strong>Field[T]</strong>，并直接传递给<strong>params</strong>的<strong>apply</strong>方法。由于<strong>Field</strong>包含了返回类型信息，所以类型并不需要被传递:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Width</span> <span class="keyword">extends</span> <span class="title">Field</span>[<span class="type">Int</span>]</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文档的剩下内容，假设每个查询的<strong>key</strong>都是一个继承自<strong>Field[T]</strong>的<strong>case</strong>类。</p>
<h2 id="2-4-语法糖-Passing-amp-Altering"><a href="#2-4-语法糖-Passing-amp-Altering" class="headerlink" title="2.4 语法糖: Passing &amp; Altering"></a>2.4 语法糖: Passing &amp; Altering</h2><p>当具有模块层级结构时，这些<strong>Parameters</strong>对象会在父模块和子模块之间传递。如果程序员指定，这些对象可以在实例化子对象之前被拷贝，修改。<br>当发生修改时，Chisel会在内部拷贝存在的key/value映射链，并将提供的key/value映射添加到链的底部（译者注: 类似于JS中的原型链）。  </p>
<p>当进行一次查询时，会首先查询链的底部key/value映射。如果没有匹配，则会查询链上的下一级key/value映射，以此类推。如果查询达到链的顶部还没有匹配，则Chisel会触发一个<strong>ParameterUndefinedExpection</strong>。<br>当实例化一个子模块时，父模块可以以两种方式传递它的<strong>Parameters</strong>对象:  </p>
<ol>
<li><p>给<strong>Module</strong>工厂方法传递第二个参数，即包装在<strong>Option[Parameters]</strong>，显式地传递其<strong>Parameters</strong>对象至子模块:  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>)(<span class="type">Some</span>(params))</span><br><span class="line">	<span class="comment">// 显示地传递Tile的参数给Core</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式地将其<strong>Parameters</strong>对象传递给子模块:  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>)</span><br><span class="line">	<span class="comment">// 隐式地传递Tile的参数给Core</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果父模块想要拷贝或修改子模块的字典，父模块有两种方法来完成:  </p>
<ol>
<li><p>向<strong>Module</strong>工厂方法提供一个偏函数映射作为一个参数。内部地，Chisel会拷贝父模块的<strong>Parameters</strong>对象并进行修改:  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>, &#123;<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">32</span>&#125;)</span><br><span class="line">	<span class="comment">// 向Module工厂方法提供偏函数来改变Core的code&#123;Parameters&#125;对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<strong>Parameters.alter</strong>方法，该方法会返回一个新的<strong>Parameters</strong>对象。这种方法让程序员可以访问新的<strong>Parameters</strong>对象，还能够使用<strong>site</strong>，<strong>here</strong>，<strong>up</strong>，请看<a href="http://chuquan.me/2016/11/10/advanced-chisel/#2-6-使用site">2.6</a>，<a href="http://chuquan.me/2016/11/10/advanced-chisel/#2-7-使用here">2.7</a>，<a href="http://chuquan.me/2016/11/10/advanced-chisel/#2-8-使用up">2.8</a>:  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> core_params = params.alter((pname, site, here, up) =&gt; pname <span class="keyword">match</span> &#123;<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">32</span>&#125;)</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>)(<span class="type">Some</span>(core_params))</span><br><span class="line">	<span class="comment">// 使用Parameters.alter方法来返回一个修改过的Parameters对象。只有当需要site，here或up等机制时才使用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>下图所示是一个更加复杂的修改链的示例:  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/key-value-chain.png" alt=""></div>  

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>, &#123; <span class="keyword">case</span> <span class="type">FPU</span> =&gt; <span class="literal">true</span>; <span class="keyword">case</span> <span class="type">QDepth</span> =&gt; <span class="number">20</span>; <span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">64</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> <span class="keyword">extends</span> <span class="title">Module</span></span>&#123;</span><br><span class="line">	<span class="keyword">val</span> fpu = params(<span class="type">FPU</span>)</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> depth = params(<span class="type">Depth</span>)</span><br><span class="line">	<span class="keyword">val</span> quete = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Queue</span>, &#123;<span class="keyword">case</span> <span class="type">Depth</span> =&gt; depth*<span class="number">2</span>; <span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">32</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> depth = params(<span class="type">Depth</span>)</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>, &#123;<span class="keyword">case</span> <span class="type">Size</span> =&gt; depth * width&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> size = params(<span class="type">Size</span>)</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-ChiseConfig-amp-Boilerplate"><a href="#2-5-ChiseConfig-amp-Boilerplate" class="headerlink" title="2.5 ChiseConfig &amp; Boilerplate"></a>2.5 ChiseConfig &amp; Boilerplate</h2><p>Chisel配置顶层参数的机制是通过一个<strong>ChiselConfig</strong>对象实现的。<strong>ChiselConfig.topDefinitions</strong>包含最高层的参数定义，如下所示:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Width</span> <span class="keyword">extends</span> <span class="title">Field</span>[<span class="type">Int</span>]</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DefaultConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> topDefinitions:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123;(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123;<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">32</span>&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，设计会调用<strong>chiselMain.apply</strong>来实例化一个设计。为了使用Chisel的参数化机制并正确地配置<strong>ChiselConfig</strong>，应该调用<strong>chiselMain.run</strong>，且设计不能用<strong>Module</strong>工厂方法包裹起来。这样的原因是为了针对已经存在的设计而保留的向后兼容性，未来我们会修复这个问题的。<br>如下就是一个调用<strong>chiselMain.run</strong>的例子:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">		chiselMain.run(args, () =&gt; <span class="keyword">new</span> <span class="type">Tile</span>())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了用特定的<strong>ChiselConfig</strong>来实例化设计，可以简单地在调用Chisel编译器时使用<strong>–configInstance project_name.configClass_name</strong>参数。  </p>
<h2 id="2-6-使用site"><a href="#2-6-使用site" class="headerlink" title="2.6 使用site"></a>2.6 使用site</h2><p>为了帮助设计者表达参数之间传递的关系，我们添加了<strong>site</strong>机制。为了理解它的功能，从概念上记住，一个被查询的Module的参数成员首先会查看其所在的key/value映射链的最底部的key/value映射。如果不匹配，查询会向上寻找。<br>假设我们有一些如下形式的模块:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> data_width = params(<span class="type">Width</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> line_width = params(<span class="type">Width</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有两个相同的查询参数<strong>Width</strong>，但是对于这个例子，它们有不同的语义。在<strong>Core</strong>中，<strong>Width</strong>表示字长，而在<strong>Cache</strong>中，<strong>Width</strong>表示cache line的宽度。我们希望能够简单地做一个参数查询响应机制。<br><strong>site</strong>机制允许链中间位置的key/value映射可以从链的底部开始进行查询。<br>看下面的例子:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> top:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123;</span><br><span class="line">		(pname,size,here) =&gt; pname <span class="keyword">match</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="type">With</span> =&gt; site(<span class="type">Location</span>) <span class="keyword">match</span>&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="symbol">'cor</span>e' =&gt; <span class="number">64</span> <span class="comment">// data width</span></span><br><span class="line">				<span class="keyword">case</span> <span class="symbol">'cach</span>e' =&gt; <span class="number">128</span> <span class="comment">// cache line width</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>, &#123;<span class="keyword">case</span> <span class="type">Location</span> =&gt; <span class="symbol">'cor</span>e'&#125;)</span><br><span class="line">	<span class="keyword">val</span> cache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>, &#123;<span class="keyword">case</span> <span class="type">Location</span> =&gt; <span class="symbol">'cach</span>e'&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如下图所示，顶层key/value映射使用<strong>site</strong>为<strong>Location</strong>查询链的底部。顶层的key/value映射产生不同的值，这依赖于<strong>Location</strong>返回的值(“core”或”cache”)。  </p>
<div center="align"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/site.png" alt=""></div>

<h2 id="2-7-使用here"><a href="#2-7-使用here" class="headerlink" title="2.7 使用here"></a>2.7 使用here</h2><p>如下图所示，如果参数是同一级key/value映射链中其他参数的函数表达式，该参数并不想复制一个值，因为赋予一个新值需要多处变化。那么，它可以通过使用<strong>here</strong>机制来查询同一层级的key/value映射:  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/here.png" alt=""></div>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> cache_params = param.alter(</span><br><span class="line">		(pname, site, here, up) =&gt; pname <span class="keyword">match</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="type">Sets</span> =&gt; <span class="number">128</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Ways</span> =&gt; <span class="number">4</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Size</span> =&gt; here(<span class="type">Sets</span>)*here(<span class="type">Ways</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">val</span> cache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>)(cache_params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-8-使用up"><a href="#2-8-使用up" class="headerlink" title="2.8 使用up"></a>2.8 使用up</h2><p><strong>up</strong>机制允许用户查询父级key/value映射。这等同于直接调用<strong>Parameters.apply</strong>，但可以在<strong>Parameters.alter</strong>中完成。具体请看<a href="http://chuquan.me/2016/11/10/advanced-chisel/#3-6-重命名参数">3.6</a>节。</p>
<h1 id="3-示例"><a href="#3-示例" class="headerlink" title="3 示例"></a>3 示例</h1><p>所有参数化方案都需要遵循以下三个准则:<br>(1) 所有可查找到的参数暴露在顶层；<br>(2) 评估不同节点时源代码绝对不能改变；<br>(3) 添加新的参数时尽量不用改变源代码。<br>本章在介绍完每个例子之后，我们会提出最简单的参数化方案以支持期望的设计空间，且不违反三个准则中的任意一个。随着例子的复杂性提高，最简单的设计方案也会随着改变，直到我们使用这里介绍的高级参数化方案。  </p>
<h2 id="3-1-简单参数"><a href="#3-1-简单参数" class="headerlink" title="3.1 简单参数"></a>3.1 简单参数</h2><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/simple-parameters.png" alt=""></div>

<p>在这个设计中，我们只改变core和cache的参数。最直接的参数化方案就是通过<strong>Tile</strong>构造函数参数来传递所有的参数。这些值然后会被传递给<strong>Core</strong>和<strong>Cache</strong>，通过它们各自的构造函数完成传递:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span>(<span class="params">val fpu:<span class="type">Boolean</span>, val ic_set:<span class="type">Int</span>, val ic_way:<span class="type">Int</span>, val dc_sets:<span class="type">Int</span>, val dc_ways:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>(fpu))</span><br><span class="line">	<span class="keyword">val</span> icache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(ic_sets, ic_ways))</span><br><span class="line">	<span class="keyword">val</span> dcache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(dc_sets, dc_ways))</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> (<span class="params">val fpu:<span class="type">Boolean</span></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>(<span class="params">val sets:<span class="type">Int</span>, val ways:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>当探索我们的参数空间时，没有源代码被修改，并且所有的可查找参数暴露在顶层。此外，添加一个新的参数，由于这个例子简单，我们的代码只需要很少的改动。  </p>
<h2 id="3-2-不相交参数集合"><a href="#3-2-不相交参数集合" class="headerlink" title="3.2 不相交参数集合"></a>3.2 不相交参数集合</h2><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/disjoint-parameter-sets.png" alt=""></div>

<p>在下一个设计中，我们设计一个芯片，其可以实例化不同的core，每个core有自己的一组参数。如果我们使用简单的解决方案，<strong>Tile</strong>的构造函数的参数会非常多，因为它必须为所有可能的core包含所有的参数。<br>有一个更好的办法就是把参数集合成一个配置对象。比如，我们可以把所有的<strong>BigCore</strong>参数集合到一个<strong>BigCoreConfig</strong>的<strong>case class</strong>中，把所有的<strong>SmallCore</strong>的参数集合到一个<strong>SmallCoreConfig</strong>的<strong>case</strong>类中，它们都继承自<strong>CoreConfig</strong>。此外，我们让<strong>Cache</strong>和<strong>Tile</strong>在它们的构造函数中分别接受<strong>CacheConfig</strong>和<strong>TileConfig</strong>。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoreConfig</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BigCoreConfig</span>(<span class="params">iq_depth:<span class="type">Int</span>, lsq_depth:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">CoreConfig</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">SmallCoreConfig</span>(<span class="params">fpu:<span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">CoreConfig</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">CacheConfig</span>(<span class="params">sets:<span class="type">Int</span>, ways:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">TileConfig</span>(<span class="params">cc:<span class="type">CoreConfig</span>, icc:<span class="type">CacheConfig</span>, dcc:<span class="type">CacheConfig</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">TIle</span> (<span class="params">val tc:<span class="type">TileConfig</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> core = tc.cc <span class="keyword">match</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> bcc:<span class="type">BigCoreConfig</span> =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BigCore</span>(tc.bcc))</span><br><span class="line">		<span class="keyword">case</span> scc:<span class="type">SmallCoreConfig</span> =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">SmallCore</span>(tc.scc))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> icache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(tc.icc))</span><br><span class="line">	<span class="keyword">val</span> dcache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(tc.dcc))</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-3-位置无关参数"><a href="#3-3-位置无关参数" class="headerlink" title="3.3 位置无关参数"></a>3.3 位置无关参数</h2><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/location-independent-parameters.png" alt=""></div>

<p>嵌套配置对象是非常脆弱的，这是因为嵌入配置对象的结构与模块的层次结构强相关。给定一个如上图所示的设计，我们假设其中包含<strong>BigCore</strong>的IQ和LSQ，以及<strong>icache</strong>和<strong>dcache</strong>，实例化一个<strong>Memory</strong>模块。<strong>Memory</strong>模块包含一个<strong>width</strong>参数，为了能让设计符合正确的预期功能，所有的<strong>Memory</strong>宽度必须设为同样的值。为了确保这个要求，代码可能会这样写:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MemConfig</span>(<span class="params">size:<span class="type">Int</span>, banks:<span class="type">Int</span>, width:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">CacheConfig</span>(<span class="params">sets:<span class="type">Int</span>, ways:<span class="type">Int</span>, mc:<span class="type">MemConfig</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">QueueConfig</span>(<span class="params">depth:<span class="type">Int</span>, mc:<span class="type">MemConfig</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">BigCoreConfig</span>(<span class="params">iqc:<span class="type">QueeuConfig</span>, lsqc:<span class="type">QueueConfig</span>, mc:<span class="type">MemConfig</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">TileConfig</span>(<span class="params">cc:<span class="type">CoreConfig</span>, icc:<span class="type">CacheConfig</span>, dcc:<span class="type">CacheConfig</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Tile</span>(<span class="params">val tc:<span class="type">TileConfig</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> core = tc.cc <span class="keyword">match</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> bcc:<span class="type">BigCoreConfig</span> =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BigCore</span>(tc.bcc))</span><br><span class="line">		<span class="keyword">case</span> scc:<span class="type">SmallCoreConfig</span> =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">SmallCore</span>(tc.scc))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> icache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(tc.icc))</span><br><span class="line">	<span class="keyword">val</span> dcache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(tc.dcc))</span><br><span class="line">	require(tc.dcc.mc.width == td.icc.mc.width)</span><br><span class="line">	require(tc.bcc.iqc.mc.width == tc.bcc.lsqc.mc.width)</span><br><span class="line">	require(tc.dcc.mc.width == tc.bcc.lsqc.mc.width)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这一系列的<strong>require</strong>声明是非常脆弱的，因为我们设计的层次结构发生任何变化都需要大量重写这些声明。忽略这些<strong>require</strong>声明并不是可行的方法；这些声明对于强制基础设计要求是非常重要的。<br>配置对象的这个缺点引领我们向用户参数化方案靠近，即<strong>Parameters</strong>类型字典的拷贝/修改。我们使用这种key-value结构来存储模块的参数。<br>为了参数化上图的设计，我们隐式地传递<strong>Parameters</strong>对象，如果需要修改，则向<strong>Module</strong>工厂方法提供偏函数。回顾前面的<strong>ChiselConfig</strong>那一节，<strong>MyConfig</strong>类(继承自<strong>ChiselConfig</strong>)必须被传递给Chisel编译器，通过<strong>–configInstance</strong>选项来配置顶层参数:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultConfig</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> top:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123;</span><br><span class="line">		(pname, site, here) =&gt; pname <span class="keyword">match</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="type">IQ_depth</span> =&gt; <span class="number">10</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">LSQ_depth</span> =&gt; <span class="number">10</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Ic_sets</span> =&gt; <span class="number">128</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Ic_ways</span> =&gt; <span class="number">2</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Dc_sets</span> =&gt; <span class="number">512</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Dc_ways</span> =&gt; <span class="number">4</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">64</span></span><br><span class="line">			<span class="comment">// 因为任何模块查询Width都会返回64，所以它的名字不应该对模块是唯一的</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>)(params)</span><br><span class="line">	<span class="keyword">val</span> ic_sets = params(<span class="type">Ic_sets</span>)</span><br><span class="line">	<span class="keyword">val</span> ic_ways = params(<span class="type">Ic_ways</span>)</span><br><span class="line">	<span class="keyword">val</span> icache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>, &#123;<span class="keyword">case</span> <span class="type">Sets</span> =&gt; ic_sets; <span class="keyword">case</span> <span class="type">Ways</span> =&gt; ic_ways&#125;)</span><br><span class="line">	<span class="comment">// we can rename Ic_sets to Sets, effectively isolating Cache’s query keys from any design hierarchy dependence </span></span><br><span class="line">	<span class="keyword">val</span> dc_sets = params(<span class="type">Dc_sets</span>) </span><br><span class="line">	<span class="keyword">val</span> dc_ways = params(<span class="type">Dc_ways</span>) </span><br><span class="line">	<span class="keyword">val</span> dcache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>, &#123;<span class="keyword">case</span> <span class="type">Sets</span> =&gt; dc_sets; <span class="keyword">case</span> <span class="type">Ways</span> =&gt; dc_ways&#125;) </span><br><span class="line">	<span class="comment">// similarly we rename Dc_sets to Sets and Dc_ways to Ways</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> iqdepth = params(<span class="type">IQ_depth</span>) </span><br><span class="line">	<span class="keyword">val</span> iq = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Queue</span>, &#123;<span class="keyword">case</span> <span class="type">Depth</span> =&gt; iqdepth&#125;) </span><br><span class="line">	<span class="keyword">val</span> lsqdepth = params(<span class="type">LSQ_depth</span>) </span><br><span class="line">	<span class="keyword">val</span> lsq = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Queue</span>, &#123;<span class="keyword">case</span> <span class="type">Depth</span> =&gt; lsqdepth&#125;) </span><br><span class="line">	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> depth = params(<span class="type">Depth</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>,&#123;<span class="keyword">case</span> <span class="type">Size</span> =&gt; depth&#125;) </span><br><span class="line">	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> sets = params(<span class="type">Sets</span>) </span><br><span class="line">	<span class="keyword">val</span> ways = params(<span class="type">Ways</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>,&#123;<span class="keyword">case</span> <span class="type">Size</span> =&gt; sets*ways&#125;) </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> size = params(<span class="type">Size</span>) </span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管这种参数化方法相当冗长，但是它在添加参数时能表现出较好的扩展性，也不需要改变源代码，并允许单个参数，如<strong>Width</strong>改变所有的叶子模块。  </p>
<h2 id="3-4-特定位置参数"><a href="#3-4-特定位置参数" class="headerlink" title="3.4 特定位置参数"></a>3.4 特定位置参数</h2><p>我们在前一节看到拷贝并修改一个<strong>Parameters</strong>对象会非常冗长。如果我们想要添加一个<strong>ECC</strong>参数到我们的<strong>Memory</strong>模块，而这个参数取决于<strong>Memory</strong>实例化的位置，这时候我们需要修改多个父模块的中的代码来重命名每个参数(如: ECC_icache =&gt; ECC)  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/location-specific-parameters.png" alt=""></div>

<p>如上图所示，我们采用<strong>Parameters</strong>对象的<strong>site</strong>功能来获取特定位置信息，从而定制我们想要返回给特定位置值的值。在添加了特定位置信息之后，我们彻底减少了必须要改动的代码的数量:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultConfig</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> top:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Depth</span> =&gt; site(<span class="type">Queue_type</span>) <span class="keyword">match</span> &#123; </span><br><span class="line">				<span class="keyword">case</span> <span class="symbol">'i</span>q' =&gt; <span class="number">20</span> </span><br><span class="line">				<span class="keyword">case</span> <span class="symbol">'ls</span>q' =&gt; <span class="number">10</span> </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Sets</span> =&gt; site(<span class="type">Cache_type</span>) <span class="keyword">match</span> &#123; </span><br><span class="line">				<span class="keyword">case</span> 'i' =&gt; <span class="number">128</span></span><br><span class="line">				<span class="keyword">case</span> 'd' =&gt; <span class="number">512</span></span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Ways</span> =&gt; site(<span class="type">Cache_type</span>) <span class="keyword">match</span> &#123; </span><br><span class="line">				<span class="keyword">case</span> 'i' =&gt; <span class="number">2</span> </span><br><span class="line">				<span class="keyword">case</span> 'd' =&gt; <span class="number">4</span> </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">64</span> </span><br><span class="line">			<span class="comment">// since any module querying Width should return 64, the name should NOT be unique to modules </span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">ECC</span> =&gt; site(<span class="type">Location</span>) <span class="keyword">match</span> &#123; </span><br><span class="line">				<span class="symbol">'incor</span>e' =&gt; <span class="literal">false</span> </span><br><span class="line">				<span class="symbol">'incach</span>e' =&gt; <span class="literal">true</span> </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> (<span class="params">val params:<span class="type">Parameters</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>,&#123;<span class="type">Location</span> =&gt; ’incore’&#125;) </span><br><span class="line">	<span class="comment">// we can give core and its child modules a location identifier</span></span><br><span class="line">	<span class="keyword">val</span> cacheparams = params.alter(&#123;<span class="type">Location</span> =&gt; ’incache’&#125;) </span><br><span class="line">	<span class="comment">// we can give both caches and all their child modules a location identifier </span></span><br><span class="line">	<span class="keyword">val</span> icache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">ICache</span>)(cacheparams) </span><br><span class="line">	<span class="keyword">val</span> dcache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">DCache</span>)(cacheparams)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> iq = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">IQ</span>) </span><br><span class="line">	<span class="keyword">val</span> lsq = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">LSQ</span>) </span><br><span class="line">	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IQ</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> depth = params(<span class="type">Depth</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>, &#123;<span class="type">Size</span> = depth&#125;) </span><br><span class="line">	<span class="comment">// in some cases, using copy/alter is preferred instead of \code&#123;site&#125; (see Design Heuristics for more details) </span></span><br><span class="line">	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LSQ</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> depth = params(<span class="type">Depth</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>, &#123;<span class="type">Size</span> = depth&#125;) </span><br><span class="line">	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICache</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> sets = params(<span class="type">Sets</span>) </span><br><span class="line">	<span class="keyword">val</span> ways = params(<span class="type">Ways</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>,&#123;<span class="type">Size</span> =&gt; sets*ways&#125;) </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DCache</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> sets = params(<span class="type">Sets</span>) </span><br><span class="line">	<span class="keyword">val</span> ways = params(<span class="type">Ways</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>, &#123;<span class="type">Size</span> =&gt; sets*ways&#125;) </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> size = params(<span class="type">Size</span>) </span><br><span class="line">	<span class="keyword">val</span> ecc = params(<span class="type">ECC</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-5-派生参数"><a href="#3-5-派生参数" class="headerlink" title="3.5 派生参数"></a>3.5 派生参数</h2><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/derivative-parameter.png" alt=""></div>

<p>如上图所示，我们总是希望我们的ROB可以是物理寄存器数量和体系结构寄存器数量差异的大小的4/3。如果我们在<strong>MyConfig.top</strong>中写明，可能就是这样的:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">NUM_arch_reg</span> <span class="keyword">extends</span> <span class="title">Field</span>[<span class="type">Int</span>] </span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">NUM_phy_reg</span> <span class="keyword">extends</span> <span class="title">Field</span>[<span class="type">Int</span>] </span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">ROB_size</span> <span class="keyword">extends</span> <span class="title">Field</span>[<span class="type">Int</span>] </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DefaultConfig</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> top:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NUM_arch_reg</span> =&gt; <span class="number">32</span> </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NUM_phy_reg</span> =&gt; <span class="number">64</span> </span><br><span class="line">			<span class="keyword">case</span> <span class="type">ROB_size</span> =&gt; <span class="number">4</span>*(<span class="number">64</span><span class="number">-32</span>)/<span class="number">3</span> </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，如果我们之后增加了物理寄存器的数量，我们需要记得更新在ROB尺寸中的派生值。为了避免这种潜在的出错，可以使用<strong>here</strong>功能来查询同级的参数:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultConfig</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> top:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NUM_arch_reg</span> =&gt; <span class="number">32</span> </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NUM_phy_reg</span> =&gt; <span class="number">64</span> </span><br><span class="line">			<span class="keyword">case</span> <span class="type">ROB_size</span> =&gt; <span class="number">4</span>*(here(<span class="type">NUM_phy_reg</span>) </span><br><span class="line">			here(<span class="type">NUM_arch_reg</span>))/<span class="number">3</span> </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-6-重命名参数"><a href="#3-6-重命名参数" class="headerlink" title="3.6 重命名参数"></a>3.6 重命名参数</h2><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/renaming-parameter.png" alt=""></div>

<p>上图所示，两个cache模块查询一个<strong>sets</strong>参数。然而，<strong>Tile</strong>有<strong>ic_sets</strong>和<strong>dc_sets</strong>参数。为了重命名这些参数，我们可以读取父模块的值并修改子模块中的<strong>Parameters</strong>对象:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> ic_sets = params(<span class="type">Ic_sets</span>) </span><br><span class="line">	<span class="keyword">val</span> ic = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>,&#123;<span class="keyword">case</span> <span class="type">Sets</span> =&gt; ic_sets&#125;)</span><br><span class="line">	<span class="keyword">val</span> dc_sets = params(<span class="type">Ic_sets</span>) </span><br><span class="line">	<span class="keyword">val</span> dc = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>,&#123;<span class="keyword">case</span> <span class="type">Sets</span> =&gt; dc_sets&#125;) </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一种方法就是，我们可以在<strong>Parameters.alter</strong>方法中使用<strong>up</strong>机制来查询父模块的<strong>Parameters</strong>对象:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> ic_params = params.alter( </span><br><span class="line">		(pname,site,here,up) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Sets</span> =&gt; up(<span class="type">Ic_sets</span>) </span><br><span class="line">		&#125; </span><br><span class="line">	) </span><br><span class="line">	<span class="keyword">val</span> ic = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>)(ic_params)</span><br><span class="line">	... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常一般不使用<strong>up</strong>机制，因为它会变得更加冗余。但是，如果父模块对子模块的<strong>Parameters</strong>对象做了非常大的改动时，<strong>up</strong>机制会非常有用，因为所有的改变会包含在<strong>Parameters.alter</strong>方法中，这个方法可以访问所有三种机制(<strong>up</strong>, <strong>site</strong>, <strong>here</strong>).</p>
<h1 id="4-外部接口"><a href="#4-外部接口" class="headerlink" title="4 外部接口"></a>4 外部接口</h1><p>到目前为止，本文只描述了一些在顶层类(<strong>ChiselConfig</strong>)操作参数的机制。但是，为了能够实际生成多个C++或Verilog设计，我们需要手动改变这些参数。<br>我们还要明确设计的约束(参数范围，依赖，约束)以及把一个特定设计的实际实例从有效设计空间表达中分离出来。<br>带着这些动机，Chisel具一个额外的特征，其基于一个叫做<strong>Knobs</strong>的概念或者用于探索设计空间的特定参数。这一节将会介绍<strong>Knobs</strong>以及其使用方法，<strong>Dump</strong>对象，参数和<strong>Knob</strong>的约束添加，以及运行Chisel编译器的两种模式: <strong>-configCollect</strong>和<strong>-configInstance</strong>.  </p>
<h2 id="4-1-Knobs"><a href="#4-1-Knobs" class="headerlink" title="4.1 Knobs"></a>4.1 Knobs</h2><p>生成器会有一些参数是固定的，其他的则指示了生成的特定设计节点。这些生成器级的参数，称之为<strong>Knobs</strong>，其具有一个额外的key-value映射以允许外部程序和用户来轻易地重写它们的值。<br><strong>Knobs</strong>只能在<strong>ChiselConfig</strong>的子类<strong>TopDefinitions</strong>中被实例化:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> topDefinitions:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NTiles</span> =&gt; <span class="type">Knob</span>(<span class="symbol">'NTILE</span>S') </span><br><span class="line">			<span class="keyword">case</span> .... =&gt; .... </span><br><span class="line">			<span class="comment">// other non-generator parameters go here </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> <span class="type">NTILES</span>' =&gt; <span class="number">1</span> <span class="comment">// generator parameter assignment </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当查询<strong>NTiles</strong>在<strong>topDefinitions</strong>中匹配时，<strong>Knob(‘NTLES’)</strong>会被返回。内部地，Chisel会在<strong>MyConfig.knobValues</strong>中查找并返回1。2.5节所示，执行生成器时需要指定特定的config:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbt run ... --configInstance example.MyConfig</span><br></pre></td></tr></table></figure></p>
<p>假设我们想要实例化一个新的设计，该设计有两个tile: 可以简单地使用Scala的类继承并重写<strong>knobValues</strong>的值:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig2</span> <span class="keyword">extends</span> <span class="title">MyConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> <span class="symbol">'NTILE</span>S' =&gt; <span class="number">2</span> </span><br><span class="line">		<span class="comment">// will generate new design with 2 tiles </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，两个类都可以存在于源代码中，因此两个设计都可以通过命令行被实例化。对于有两个tile的新设计:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbt run --configInstance exmaple.MyConfig2</span><br></pre></td></tr></table></figure></p>
<h2 id="4-2-Dump"><a href="#4-2-Dump" class="headerlink" title="4.2 Dump"></a>4.2 Dump</h2><p>顺着Chisel而下，其他的工具可能需要知道特定的参数/Knob赋值。如果需要，只要将Knob/value传给<strong>Dump</strong>对象，该对象会把name和value写入一个文件，然后返回Knob/value:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> topDefinitions:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="type">Dump</span>(<span class="symbol">'Widt</span>h',<span class="number">64</span>) </span><br><span class="line">			<span class="comment">// will return 64. Requires naming the parameter as the 1st argument </span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">NTiles</span> =&gt; <span class="type">Dump</span>(<span class="type">Knob</span>(<span class="symbol">'NTILE</span>S')) </span><br><span class="line">			<span class="comment">// will return Knob('NTILES'), no name needed </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> <span class="symbol">'NTILE</span>S' =&gt; <span class="number">1</span> </span><br><span class="line">		<span class="comment">// generator parameter assignment </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个废弃的参数的name和value会被重写到一个<em>.knb文件，文件在<em>*–targetDir path</em></em>指定的目录中。  </p>
<h2 id="4-3-约束"><a href="#4-3-约束" class="headerlink" title="4.3 约束"></a>4.3 约束</h2><p>现在外部程序/用户可以很容易地重写一个配置的<strong>knobValue</strong>方法，我们提供了一种机制可以定义合法的<strong>Knobs</strong>范围。在<strong>ChiselConfig</strong>中，可以重写另一个称为<strong>topConstraint</strong>的方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> topDefinitions:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NTiles</span> =&gt; <span class="type">Knob</span>(’<span class="type">NTILES</span>’) </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> topConstraints:<span class="type">List</span>[<span class="type">ViewSym</span>=&gt;<span class="type">Ex</span>[<span class="type">Boolean</span>]] </span><br><span class="line">		= <span class="type">List</span>( &#123; ex =&gt; ex(<span class="type">NTiles</span>) &gt; <span class="number">0</span> &#125;, </span><br><span class="line">				&#123; ex =&gt; ex(<span class="type">NTiles</span>) &lt;= <span class="number">4</span> &#125;) </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> <span class="symbol">'NTILE</span>S' =&gt; <span class="number">1</span> <span class="comment">// generator parameter assignment </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，如果有人想要用以下的配置和命令实例化我们的设计，会无法通过:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> <span class="symbol">'NTILE</span>S' =&gt; <span class="number">5</span> </span><br><span class="line">		<span class="comment">// would violate our constraint, throws an error </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// throws <span class="string">'Constriant failed'</span> error </span><br><span class="line">sbt run ... --configInstance example.BadConfig</span><br></pre></td></tr></table></figure>
<p>约束可以在设计中的任何位置声明，并不只是在顶层，通过调用<strong>Parameters</strong>的<strong>constant</strong>方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> topDefinitions:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NTiles</span> =&gt; <span class="type">Knob</span>(<span class="symbol">'NTILE</span>S') </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> <span class="symbol">'NTILE</span>S' =&gt; <span class="number">1</span> </span><br><span class="line">		<span class="comment">// generator parameter assignment </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	params.constrain( ex =&gt; ex(<span class="type">NTiles</span>) &gt; <span class="number">0</span> ) </span><br><span class="line">	params.constrain( ex =&gt; ex(<span class="type">NTiles</span>) &lt;= <span class="number">4</span> ) </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Run</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line">		chiselMain.run(args, () =&gt; <span class="keyword">new</span> <span class="type">Tile</span>())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbt runMain example.Run ... --configInstance example.MyConfig</span><br></pre></td></tr></table></figure>
<p>最后，如果设计者想要知道设计约束，他们可以执行Chisel，用<strong>–configCollect project_name.config_name</strong>选项，这会把一系列约束打印到一个<em>.cst文件中，该文件的位置由<em>*–targetDir path</em></em>指定:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbt runMain example.Run ... --configCollect example.MyConfig --targetDir &lt;path&gt;</span><br></pre></td></tr></table></figure>
<p>（完）</p>
<p>[参考]<br>[1] Bachrach,J.,Vo,H.,Richards,B.,Lee,Y.,Waterman, A., Avižienis, Wawrzynek, J., Asanovic´ Chisel: Constructing Hardware in a Scala Embedded Language in DAC ’12.<br>[2] Odersky, M., Spoon, L., Venners, B. Programming in Scala by Artima.<br>[3] Payne, A., Wampler, D. Programming Scala by O’Reilly books.  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2016/10/15/food-in-beijing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="包楚权">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/slamdunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="包楚权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/15/food-in-beijing/" itemprop="url">【美食北京】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-15T22:31:28+08:00">
                2016-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生活/" itemprop="url" rel="index">
                    <span itemprop="name">生活</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>博客的目的就是为了记录自己的生活和成长。本篇博文将会持续更新以记录我在北京所探索并尝试的美食，当然曾经也发现过不少美食，虽然饱了口福，却没有充实记忆。</p>
<h1 id="江边城外烤"><a href="#江边城外烤" class="headerlink" title="江边城外烤"></a>江边城外烤</h1><hr>
<h2 id="连锁-五道口店"><a href="#连锁-五道口店" class="headerlink" title="连锁(五道口店)"></a>连锁(五道口店)</h2><h2 id="2016-10-15"><a href="#2016-10-15" class="headerlink" title="2016-10-15"></a>2016-10-15</h2><p>之前就来过两次，这次来体验一下五道口店。不愧是名声在外，每一次光顾江边城外，门口都是排满了顾客。排号的时候，也可先点菜，毕竟从活鱼到处理完毕再到烹饪完成还是需要比较久的时间的。和妹子两个人，点了份<em>香辣烤鱼</em>(一个香辣盘底和一条2.8斤的清江鱼)，外加几个辅助菜: 乌笋，腐竹。<br>鱼很新鲜，汤汁浓郁鲜美，鱼肉蘸着吃，入口就是一种正宗的重庆味道。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/food001.jpg" alt=""><br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/food002.jpg" alt=""><br><strong>评分: 4.5</strong></p>
<h1 id="小吊梨汤"><a href="#小吊梨汤" class="headerlink" title="小吊梨汤"></a>小吊梨汤</h1><hr>
<h2 id="连锁-畅春园店"><a href="#连锁-畅春园店" class="headerlink" title="连锁(畅春园店)"></a>连锁(畅春园店)</h2><h2 id="2016-10-16"><a href="#2016-10-16" class="headerlink" title="2016-10-16"></a>2016-10-16</h2><p><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/food009.jpg" alt=""><br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/food003.jpg" alt=""><br>京城官府菜的代表，每次来都需要排号，受欢迎程度可见一斑。店内装饰别具一格，无论是桌椅还是墙纸灯饰都非常具有古韵，置身店内就有一种神游古都的感觉。<br>深秋，夜幕降至，和女神一起来体验一回京城官府菜。招牌<em>传统小吊梨汤</em>是每次必点饮品，<em>小煎仔鸡</em>、<em>原汤西红柿焖牛腩</em>、<em>椒麻排骨</em>作为热菜，以甜食<em>果粒蜂窝煤</em>为主食，足矣。事实证明，这几个菜对两个人来说稍略显多。<br><em>小吊梨汤</em>：非常适合寒冷的季节饮用，就像寒冬饮热酒一般。梨汤虽然不是很甜，但是正是这样，喝一壶也不腻。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/food005.jpg" alt=""><br><em>小煎仔鸡</em>：青椒片煎鸡柳，酱汁不错，味道鲜美。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/food007.jpg" alt=""></p>
<p><em>原汤西红柿焖牛腩</em>：土豆和萝卜炖得非常入味，牛肉的味道自然不必多说。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/food008.jpg" alt=""></p>
<p><em>椒麻排骨</em>：排骨中渗透着花椒的味道，感觉还不够入味。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/food004.jpg" alt=""></p>
<p><em>果粒蜂窝煤</em>：甜食，用杂粮做成煤球的形状，内掺火龙果，什锦等果粒。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/food006.jpg" alt=""><br><strong>评分: 4.5</strong></p>
<h1 id="金谷园"><a href="#金谷园" class="headerlink" title="金谷园"></a>金谷园</h1><hr>
<h2 id="连锁-北邮南门"><a href="#连锁-北邮南门" class="headerlink" title="连锁(北邮南门)"></a>连锁(北邮南门)</h2><h2 id="2016-10-22"><a href="#2016-10-22" class="headerlink" title="2016-10-22"></a>2016-10-22</h2><p>周五傍晚永远都是一周中最轻松愉悦、充满期待的一段时光，显然，用美食来消遣这段时光是最佳选择之一。小雨夜，女神带我穿街走巷来到北邮门的一个小胡同。虽说是个连锁店，但却像个小作坊，门面很小。不过里面的空间还是挺大的，特别是屋内的装饰，令人耳目一新，像个咖啡厅，甚至还有长条沙发作座椅。<br><em>皮蛋瘦肉粥</em>：我人生中喝过的最好的皮蛋瘦肉粥。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bayujiaozi01.png" alt=""><br><em>日式土豆泥沙拉</em>：土豆泥很细，掺和着沙拉，对于深秋季节还是有点凉。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bayujiaozi03.jpeg" alt=""><br><em>葱麻鸡</em>：葱油鸡上浇了层麻酱，鸡肉的味道不够足，总体还是满意的。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bayujiaozi05.png" alt=""><br><em>孜然羊肉饺子</em>：肉馅的分量很足，羊肉磨的很细，饺子皮内还有羊肉汤汁，味道鲜美。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bayujiaozi04.png" alt=""><br><em>鲅鱼饺子</em>：毕竟招牌饺子，饺子皮很劲道，饺子馅鲜美多汁，美味无需多言。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bayujiaozi02.png" alt=""><br><strong>评分: 4.5</strong></p>
<h1 id="东来顺"><a href="#东来顺" class="headerlink" title="东来顺"></a>东来顺</h1><hr>
<h2 id="连锁-中关村"><a href="#连锁-中关村" class="headerlink" title="连锁(中关村)"></a>连锁(中关村)</h2><h2 id="2016-11-26"><a href="#2016-11-26" class="headerlink" title="2016-11-26"></a>2016-11-26</h2><p>在中国的冬季，想必绝大多数人都会把火锅列为好友聚会兄弟小酌的首选之一。而在北方，涮肉的地位等同于南方人心中的火锅。今天就来体验一下，北京大名鼎鼎的东来顺。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/donglaishun01.jpeg" alt=""><br>铜锅的造型就是影视作品里的经典形象，里面有一堆碳木用以保持外面的水沸腾。我们两个人，点了羊肚、蔬菜拼盘、肥牛、肥羊、菌菇拼盘还有两个小烧饼。<br>说实话，实际品尝后心里落差还是蛮大的。关于羊肚，羊肚的劲道和牛肚完全不是一个档次，食材选择的失误直接导致我放弃好评。蔬菜拼盘、菌菇用清水烫，味道中规中矩。肥牛和肥羊只需要稍微涮一下就可出锅，实际上效果和火锅是一样的。<br>唯一值得称赞的也许就是涮肉必备的麻酱了。以前吃过各式各样的麻酱，不过东来顺的麻酱可能是最香的。麻酱浓厚可以掩盖锅底味道的不足。<br>建议吃火锅的时候还是应该选择人多的时候比较合适，能够品尝到各类食材，这样才能达到最高的性价比。<br><strong>评分: 3.8</strong></p>
<h1 id="牛十一海鲜馆"><a href="#牛十一海鲜馆" class="headerlink" title="牛十一海鲜馆"></a>牛十一海鲜馆</h1><hr>
<h2 id="连锁-交大店"><a href="#连锁-交大店" class="headerlink" title="连锁(交大店)"></a>连锁(交大店)</h2><h2 id="2016-11-26-1"><a href="#2016-11-26-1" class="headerlink" title="2016-11-26"></a>2016-11-26</h2><p>“吃”一直都是一个难以抉择的问题。和女神在交大附近游玩，好不容易在大众点评上看到一个距离又近，评分也不错的馆子，随即决定以身试分。<br><em>辣炒花蛤</em>: 花蛤肉很饱满，味道微辣，属于来店推荐一档。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/niushisan002.jpeg" alt=""><br><em>碳烤羊肉串</em>: 属于羊肉串中的上等，价格良心，值得一试。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/niushisan005.jpeg" alt=""><br><em>烤大鱿鱼</em>: 切开大鱿鱼绝对是提高用户体验的一道手续。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/niushisan003.jpeg" alt=""><br><em>牛十三特色生串</em>: 这个绝对是本店特色，生肉的品相和嚼劲，难以描述的特别味道。克服心理障碍后此处应点赞。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/niushisan001.jpeg" alt=""><br><em>烤茄子</em>: 茄子上的微辣细腻的蒜泥绝对能改变有些人对大蒜的偏见。铺在茄子的上层，蒜泥和茄子充分融合，这是爱茄人士的福利。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/niushisan004.jpeg" alt=""><br>事实上这家店还有一道特色菜——海鲜大拼盘，但由于这次下馆子只有两个人，点海鲜大拼盘绝对是不理智的选择，希望有机会和更多朋友来试试这道菜。<br><strong>评分: 4.3</strong></p>
<h1 id="南京大排档"><a href="#南京大排档" class="headerlink" title="南京大排档"></a>南京大排档</h1><hr>
<h2 id="连锁-中关村-1"><a href="#连锁-中关村-1" class="headerlink" title="连锁(中关村)"></a>连锁(中关村)</h2><h2 id="2016-12-4"><a href="#2016-12-4" class="headerlink" title="2016-12-4"></a>2016-12-4</h2><p>以前在合肥经常吃重庆大排档，来北京两年多了没吃过一次大排档。今天来美嘉看新海诚新作《你的名字》，突然发现这里有家南京大排档，果断来店品尝。<br>店里的装饰和工作人员的服饰都是精心设计的，以营造一种年代感。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/dapaidang009.jpeg" alt=""><br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/dapaidang008.jpeg" alt=""><br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/dapaidang001.jpeg" alt=""><br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/dapaidang003.jpeg" alt=""><br><em>街坊炒螺蛳</em>: 久违的家乡味道，如何能让一个水乡游子不予以赞许？<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/dapaidang005.jpeg" alt=""><br><em>家乡臭豆腐</em>: 并不是长沙臭豆腐的烹饪方法制作而成，而是用烂咸菜汁做的。小时候家里也做过这种咸菜，那时的我却是非常讨厌吃这种咸菜，而如今却只是慢慢的回忆。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/dapaidang004.jpeg" alt=""><br><em>江南水乡一同鲜</em>: 里面的食材有大闸蟹，鱼丸子，明虾，花蛤，豆皮。所谓的“鲜”味还有所欠缺。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/dapaidang006.jpeg" alt=""><br><em>鸭血粉丝砂锅</em>: 切碎的小块鸭血和少许鸭肝、鸭胗，加上香菜和粉丝煲成的砂锅。味道不错，可惜这个砂锅在我心中还是没有超越回味的鸭血粉丝汤。<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/dapaidang007.jpeg" alt=""><br><strong>评分: 4.3</strong></p>
<h1 id="重八牛府"><a href="#重八牛府" class="headerlink" title="重八牛府"></a>重八牛府</h1><hr>
<h2 id="连锁-之初入江湖店"><a href="#连锁-之初入江湖店" class="headerlink" title="连锁(之初入江湖店)"></a>连锁(之初入江湖店)</h2><h2 id="2017-1-7"><a href="#2017-1-7" class="headerlink" title="2017-1-7"></a>2017-1-7</h2><p>女神快要放假回家了，为了庆祝寒假的到来，我们一个星期前就预想着来重八牛府吃一次火锅。周六下午三点开始预约，三点刚过几分钟，已有六桌已预约，火爆程度可见一斑。<br>来到双榆树店，数十米外就能闻到浓郁开胃的火锅飘香。门面是一套木质古风的装饰，迈进门槛，入眼就是十张八仙桌，所幸我们预约得早，很快就排上了座。<br>与我之前吃过的火锅都不一样，这里有专门的服务员为我们配置火锅酱，而且不同的食材会有不同的蘸酱，比如：火锅面就有专门的一碗类似炸酱面的拌酱，对于肥牛肥羊之类的褶皱较多的食材则有对应的酱汁。<br>一个大铜锅盛满清汤锅底，相较于其他火锅也算是独具一格。<br>至于火锅的味道，两点令我印象深刻：酱料、飘香。尽管我没去过火锅之都重庆，但是好歹我也吃过不少火锅：海底捞、澳门豆捞、傣妹…对于重八牛府，我能出给的评价是：这是我迄今为止吃过最好吃的火锅。听朋友说重庆还有更好吃的火锅，因此我们已经盘算着上半年去重庆旅游，毕竟美食对于吃货来说是旅游的最大动力。<br>这次的照片数量有点少，因为这次光顾着吃而没有拍下多少照片，囧…<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chongbaniufu001.png" alt=""><br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chongbaniufu002.png" alt=""><br><strong>评分: 4.8</strong></p>
<p><strong>（未完待续）</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2016/08/29/my-paintings/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="包楚权">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/slamdunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="包楚权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/29/my-paintings/" itemprop="url">【我的绘画作品】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-29T23:59:55+08:00">
                2016-08-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生活/" itemprop="url" rel="index">
                    <span itemprop="name">生活</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>小时候，我的梦想是成为一个画家。在幼儿园之前，曾经有机会接触绘画教育，很遗憾却因为一些小意外而错失了。不过，这并不能阻止我热爱绘画。<br>我的画作其实并不多，现在一年能画一幅已然是奢侈。用一篇持续更新的博文来展示我的画作其实也足够了。</p>
<h1 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h1><h2 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h2><p>和bluestory风格类似，不过符合我的口味。</p>
<div align="center"><img src="http://images.chuquan.me/blog-images/bluestory01.jpeg" alt="bluestory01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/bluestory02.jpeg" alt="bluestory01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/bluestory03.jpeg" alt="bluestory01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/bluestory04.jpeg" alt="bluestory01"></div>

<h1 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h1><h2 id="2月-1"><a href="#2月-1" class="headerlink" title="2月"></a>2月</h2><p>非常喜欢DJ Okawarri的flowerdance专辑以及专辑封面。</p>
<div align="center"><img src="http://images.chuquan.me/blog-images/flowerdance01.png" alt="flowerdance01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/flowerdance02.png" alt="flowerdance01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/flowerdance03.jpeg" alt="flowerdance01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/flowerdance04.jpeg" alt="flowerdance01"></div>

<h1 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h1><h2 id="2月-2"><a href="#2月-2" class="headerlink" title="2月"></a>2月</h2><p>百无聊赖。</p>
<div align="center"><img src="http://images.chuquan.me/blog-images/slam01.png" alt="slam01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/slam02.png" alt="slam02"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/slam03.png" alt="slam03"></div>

<h2 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h2><p>想画画，但不知道画什么，突然想到好友喜欢海贼王，那就来个路飞吧。</p>
<div align="center"><img src="http://images.chuquan.me/blog-images/lufei01.png" alt="lufei01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/lufei03.png" alt="lufei03"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/lufei02.png" alt="lufei02"></div>

<h1 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h1><p>一天时间重新回味了一遍《变形金刚》三部曲，心血来潮的作品。</p>
<div align="center"><img src="http://images.chuquan.me/blog-images/transformer01.png" alt="transformer01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/transformer02.png" alt="transformer01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/transformer03.png" alt="transformer01"></div>

<div align="center"><img src="http://images.chuquan.me/blog-images/transformer04.png" alt="transformer01"></div>

<p><strong>（未完待续）</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2016/08/26/matrix-code-rain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="包楚权">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/slamdunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="包楚权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/26/matrix-code-rain/" itemprop="url">源码解读——Matrix-Code-Rain</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-26T10:59:37+08:00">
                2016-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近自己的博客刚刚建起来，想好好经营一下。内容比较少，另外希望能产出一些高质量的文章，所以不想将CSDN博客上的文章迁移过来。那么就得自己发点干货了。废话不多说，转入正题。  </p>
<p>数个月前在github上阅读过一个小项目的源码——<a href="https://github.com/neilcarpenter/Matrix-code-rain" target="_blank" rel="noopener">Matrix-code-rain</a>。其效果是黑客帝国中代码在屏幕上从上至下滑落。<a href="http://neilcarpenter.com/demos/canvas/matrix/" target="_blank" rel="noopener">DEMO</a>见此链接。如下截图所示即代码雨效果图: </p>
<div align="center"><img src="http://images.chuquan.me/blog-images/matrix-code-rain.png" alt="代码雨"></div>  

<p>首先观察效果图，大致分为三个部分: 左上角的<code>帧频监测模块</code>、左下角的<code>快照工具栏</code>、<code>代码雨</code>主体。  </p>
<p>项目的index.html文件中的body部分包含了两个主要的元素:  </p>
<ul>
<li>id=”info”的div元素  </li>
<li>id=”canvas”的画布<br>前者提供了<code>快照</code>功能，以旋转方式显示/隐藏的特效（该效果是以CSS3实现的）；后者实现了<code>帧频检测</code>功能以及主效果<code>代码雨</code>。</li>
</ul>
<p>下面先把JS主干代码贴出，并做简要解读。  </p>
<h1 id="主干代码"><a href="#主干代码" class="headerlink" title="主干代码"></a>主干代码</h1><p>这里仅标出代码主干，具体细节请查看源码。代码的主干很简单，如下所示:  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stats = <span class="keyword">new</span> Stats();</span><br><span class="line">stats.domElement.style.position = <span class="string">'absolute'</span>;</span><br><span class="line">stats.domElement.style.left = <span class="string">'0px'</span>;</span><br><span class="line">stats.domElement.style.top = <span class="string">'0px'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild( stats.domElement );</span><br><span class="line"><span class="keyword">var</span> M = &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventListenerz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	M.init();</span><br><span class="line">	eventListenerz();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先简单分析一下主干代码，然后再分析具体细节:<br>开头五行代码，引用了一个外部JS文件(stats.min.js)定义的一个构造函数<code>Stats()</code>，然后初始化一个对象，这个对象的功能就是<code>帧频检测</code>，最后把它放到左上角。<br>接着初始化一个对象M，这个对象内部定义了很多属性和方法: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> M = &#123;</span><br><span class="line">	<span class="comment">// 属性</span></span><br><span class="line">	<span class="comment">// 关于每一栏canvas的属性设置</span></span><br><span class="line">	setting: &#123;</span><br><span class="line">		COL_WIDTH: <span class="number">15</span>,	<span class="comment">// 每一栏的宽度</span></span><br><span class="line">		COL_HEIGHT: <span class="number">25</span>, <span class="comment">// 每一栏的高度</span></span><br><span class="line">		VELOCITY_PARAMS: &#123;</span><br><span class="line">			min: <span class="number">4</span>, <span class="comment">// 代码雨的最小速度</span></span><br><span class="line">			max: <span class="number">8</span>	<span class="comment">// 代码雨的最大速度</span></span><br><span class="line">		&#125;,</span><br><span class="line">		CODE_LENGTH_PARAMS: &#123;</span><br><span class="line">			min: <span class="number">20</span>,<span class="comment">// 代码雨的最小长度</span></span><br><span class="line">			max: <span class="number">40</span>	<span class="comment">// 代码雨的最大长度</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	animation: <span class="literal">null</span>,</span><br><span class="line">	</span><br><span class="line">	c: <span class="literal">null</span>,</span><br><span class="line">	ctx: <span class="literal">null</span>,</span><br><span class="line">	</span><br><span class="line">	lineC: <span class="literal">null</span>,</span><br><span class="line">	ctx2: <span class="literal">null</span>,</span><br><span class="line">	</span><br><span class="line">	video: <span class="literal">null</span>,</span><br><span class="line">	</span><br><span class="line">	WIDTH: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">	HEIGHT: <span class="built_in">window</span>.innerHeight,</span><br><span class="line">	</span><br><span class="line">	COLUMNS: <span class="literal">null</span>,	<span class="comment">// canvas列数</span></span><br><span class="line">	canvii: [],</span><br><span class="line">	font: <span class="string">'30px matrix-code'</span>,</span><br><span class="line">	letters: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, ...],</span><br><span class="line">	</span><br><span class="line">	codes: [],</span><br><span class="line">	</span><br><span class="line">	createCodeLoop: <span class="literal">null</span>,</span><br><span class="line">	codesCounter: <span class="number">0</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 方法  </span></span><br><span class="line">	init(),  </span><br><span class="line">	loop(),  </span><br><span class="line">	draw(),  </span><br><span class="line">	createCode(),  </span><br><span class="line">	createCanvii(),  </span><br><span class="line">	createLines(),  </span><br><span class="line">	assignColumn(),  </span><br><span class="line">	randomFromInterval(),</span><br><span class="line">	snapshot()  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后定义一个添加事件监听的函数<code>eventListenerz</code>。  </p>
<p>当页面加载后执行如下代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = &#123;</span><br><span class="line">	M.init();	<span class="comment">// 初始化M</span></span><br><span class="line">	eventListenerz();	<span class="comment">//添加事件监听</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>M.init()</code>做了以下这些事:</p>
<ol>
<li>将canvas元素赋值给M.c；</li>
<li>获取画布上的绘图环境，并赋值给M.ctx（后面称之为<code>画布</code>）；</li>
<li>获取页面的高度、宽度并设置画布的高度和宽度，让画布充满整个页面；</li>
<li>设置画布背景色为黑色；</li>
<li>设置画布的字体为<code>30px matrix-code</code>；</li>
<li>创造屏幕质感，画一条条的横线。这里动态创建了一个canvas元素，并设置画布的宽高与页面一致，通过调用<code>M.createLines()</code>方法来绘制满屏的横线，其实为了效果更好每条横线下面紧挨一条颜色更淡的横线，达到色差缓冲的效果；  </li>
<li>根据网页的宽度、预设的canvas宽度，计算网页横向能放多少个canvas；</li>
<li><p>针对每一栏canvas初始化一个codes数组，数组的0索引的值是一个对象:   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">'open'</span>: <span class="literal">true</span>, </span><br><span class="line">	<span class="string">'position'</span>: &#123;<span class="string">'x'</span>, <span class="number">0</span>, <span class="string">'y'</span>: <span class="number">0</span>&#125;,</span><br><span class="line">	<span class="string">'strength'</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>M.loop()</code>方法，该方法内部调用了<code>requestAnimationFrame</code>，并把其任务ID赋值给<code>M.animation</code>。然后是loop方法的主体，调用<code>M.draw()</code>——想必就是绘制代码雨的效果。此外，同时更新<code>帧频检测器</code>的数据状态，达到循环动画的效果。</p>
</li>
<li>调用<code>M.createCode()</code>方法，该方法什么作用？请继续往下阅读。</li>
</ol>
<p>这时候，代码的大体流程已经知道了，我们只要了解<code>M.draw()</code>是如何绘制代码雨，以及<code>M.createCode()</code>是如何初始化的即可。</p>
<h1 id="代码雨"><a href="#代码雨" class="headerlink" title="代码雨"></a>代码雨</h1><p>先来看我绘制的一张图，改图简要的介绍了代码雨的组成，在看具体分析之前大家可以先自己想想其实现方式。  </p>
<div align="center"><img src="http://images.chuquan.me/blog-images/matrix-code-rain-framework.png" alt="代码雨原理图"></div>

<p>要了解代码雨原理，首先了解<code>M.draw()</code>是如何工作的。</p>
<p><strong>M.draw()</strong><br><code>M.draw()</code>做了以下工作:  </p>
<ol>
<li>清理画布，避免之前绘制的图像遗留在画布上产生重影；</li>
<li>设置如何将新图像绘制到已有图像之上，默认为<code>source-over</code>；</li>
<li>对每一canvas进行处理。<br> 1). 当其codes[0]包含canvas属性时，获取其速度值、canvas的高度，x、y坐标，canvas元素，canvas画布。然后根据其位置将这个canvas添加到主canvas上。  <pre><code>a. 当y坐标小于网页高度时（即canvas的y坐标还在网页范围内），更新y坐标(y减去速度值)；
b. 否则，将y坐标设为0，这就达到了同一列不停的循环的效果。  
</code></pre></li>
</ol>
<p>看到第3步，对比<strong>代码主干</strong>一节中第8步，我们发现：<code>M.draw()</code>阶段时每一栏的canvas的codes数组根本没有canvas属性。这种情况下，第3步中的处理条件根本无法达到。所以肯定缺少初始化的一步，这肯定包含在<code>M.createCode()</code>中，其实看方法名也能看出来。</p>
<p><strong>M.createCode()</strong><br><code>M.createCode()</code>做了以下工作:  </p>
<ol>
<li>判断<code>M.codesCounter</code>是否大于canvas列数。如果是，清除M.createCodeLoop的定时任务，并返回。否则，继续往下执行。推断一下：毕竟网页横向被分解成了很多个canvas，有多少个canvas，<code>M.createCode()</code>就会被调用多少次吧。  </li>
<li>给局部变量randomInterval赋值为<code>M.randomFromInterval(0,100)</code>的执行结果。直接跳到这段代码看看，哦，生成一个0到100之间的随机数。  </li>
<li>给局部变量colum赋值为<code>M.assignColumn()</code>的执行结果。直接跳到这段代码看看：随机获取一个canvas的索引，如果该canvas的codes[0]的open属性为true，则置为false，并返回canvas的索引；否则直接返回false。仔细想想，这段代码把open置为false后，并没有还原成true。   </li>
<li>根据column索引值，对对应一列的canvas进行处理。<br> 1). 随机获取一个代码雨长度值，并赋值给codeLength；<br> 2). 随机获取一个代码雨速度值，并赋值给codeVelocity；<br> 3). 获取代码雨字符表的长度，并赋值给lettersLength；<br> 4). 设置该canvas的codes[0].position属性，起始的x坐标与列索引有关，y坐标都为0；<br> 5). 设置该canvas的codes[0].velocity属性，为随机获取的速度值；<br> 6). 设置该canvas的codes[0].strength属性，为其速度/速度上限值，这个到底什么作用呢？先放着继续往下看；<br> 7). 根据代码雨长度值，获取相应数量的字符，这是通过在字符表中随机获取的，并将字符依次赋值给该canvas的codes[1], codes[2]…<br> 8). 调用<code>M.createCanvii(column)</code>。这里把canvas的列索引值传递进去了，想必就是进行绘制操作了。<br> 9). <code>M.codesCount</code>++，这一步验证了第1步的猜想。</li>
<li>根据局部变量randomInterval来设置另一列canvas的初始化。</li>
</ol>
<p><strong>M.createCanvii()</strong><br>上面一节第8步对<code>M.createCanvii(col)</code>的作用进行了猜想，下面我们来看看是不是符合我们的猜想。<br><code>M.createCanvii(col)</code>做了以下工作:  </p>
<ol>
<li>获取该列canvas要显示的字符数，赋值给codeLen；</li>
<li>获取该列canvas的高度，通过字符数*每个字符的高度即可得到；</li>
<li>获取该列canvas的速度，通过codes[0].velocity即可得到；</li>
<li>获取该列canvas的strength，此时我们还是不知道这是个什么参数；</li>
<li>创建一个canvas元素，并获取其画布环境，并设置其宽度和高度；</li>
<li>根据codeLen，绘制所有字符，这里并不是单纯的绘制。前5个和最后4个不太一样，哪里不一样呢？之前不明白其含义的strength出现了，原来是为了让两端的颜色变淡一些。</li>
<li>绘制完毕后，将该列canvas的codes[0].canvas的值赋为这里绘创建的canvas元素。哦，这时候，<strong>M.draw()</strong>一节的第3步的条件就成立了，就可以把这个创建的canvas添加到网页的主canvas了。</li>
</ol>
<p>现在一切就明了了，接下来有兴趣的话可以看看<code>快照工具栏</code>的效果实现。</p>
<h1 id="快照工具栏"><a href="#快照工具栏" class="headerlink" title="快照工具栏"></a>快照工具栏</h1><p>先来看看CSS3提供的几个动画方法和特性:   </p>
<p><strong>transform</strong>: <em>none | transform-functions</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix():		<span class="comment">/*定义转换*/</span>  </span><br><span class="line">translate():	<span class="comment">/*原点坐标偏移*/</span></span><br><span class="line">scale():		<span class="comment">/*缩放*/</span>  </span><br><span class="line">rotate():		<span class="comment">/*沿轴旋转*/</span>   </span><br><span class="line">skew():		<span class="comment">/*沿轴倾斜*/</span>   </span><br><span class="line">perspective():	<span class="comment">/*定义透视*/</span></span><br></pre></td></tr></table></figure></p>
<p><strong>transition</strong>: <em>property duration timing-function delay</em><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transition-property: none|all|property;  </span><br><span class="line">transition-duration: time(s/ms);  </span><br><span class="line">transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n)</span><br></pre></td></tr></table></figure></p>
<p>transform属性的是transform-function，上述只列出了6类方法，每一类方法对应还有针对2D, 3D的方法。 </p>
<p>很明显，快照工具栏的旋转显示/隐藏方式是以<code>tramsform</code>分别对<code>显示时定义一个状态</code>，<code>隐藏时定义一个状态</code>，然后通过CSS3的<code>transition</code>属性来进行状态切换设置。  </p>
<p>果然代码中也是以这种方式实现的:<br><strong>显示状态</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform-origin</span>: <span class="selector-tag">bottom</span> <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(0<span class="selector-tag">deg</span>);</span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 1<span class="selector-tag">s</span> <span class="selector-tag">ease-in-out</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>隐藏状态</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(180<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>状态转移方式</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 1<span class="selector-tag">s</span> <span class="selector-tag">ease-in-out</span>;</span><br></pre></td></tr></table></figure></p>
<p>两个状态、转移方式都定义好了，那么就可以通过事件了切换这两者的状态了。用toggle的方法来添加/删除类来达到状态切换的效果。果然，JS代码中有一个函数<code>eventListenerz()</code>就包含了状态切换的处理。<br>此外，快照工具栏还有一个主要功能: 快照。还是在上面那个函数里面，包含了这两行代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> snapshotBtn = <span class="built_in">document</span>.getElementById(<span class="string">'snapshot'</span>);</span><br><span class="line">snapshotBtn.addEventListener(<span class="string">'click'</span>, M.snapshot, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>第一行代码获取了<code>快照</code>按钮的buttn元素；第二行代码则是对该按钮添加了一个click事件监听以及相应的回调函数。<br><code>M.snapshot</code>是其内部定义的一个方法。其源码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">snapshot: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	M.createLines(M.ctx);</span><br><span class="line">	<span class="built_in">window</span>.open(M.c.toDataURL());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>M.c为页面的主canvas，对其调用<code>toDataURL()</code>方法，该方法将canvas进行转化成一个特定格式的图片（默认PNG），并返回一个data URI。最后新开一个窗口显示该图片。</p>
<p>（完）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/slamdunk.png"
               alt="包楚权" />
          <p class="site-author-name" itemprop="name">包楚权</p>
           
              <p class="site-description motion-element" itemprop="description">吸收、沉淀、积累</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/baochuquan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/baochuquan" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">包楚权</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>

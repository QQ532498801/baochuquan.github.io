<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楚权的世界</title>
  
  <subtitle>Seek the wonder of life.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chuquan.me/"/>
  <updated>2018-04-10T16:25:48.842Z</updated>
  <id>http://chuquan.me/</id>
  
  <author>
    <name>Bao Chuquan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MVC、MVP、MVVM的演化</title>
    <link href="http://chuquan.me/2018/04/11/mvc-mvp-mvvm/"/>
    <id>http://chuquan.me/2018/04/11/mvc-mvp-mvvm/</id>
    <published>2018-04-10T16:23:49.000Z</published>
    <updated>2018-04-10T16:25:48.842Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中苹果定义了一套MVC的软件架构。前几天，同事们聊起了MVC、MVP、MVVM等架构的区别。今天，我也来对此给出一些自己的理解。</p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="基本MVC模式"><a href="#基本MVC模式" class="headerlink" title="基本MVC模式"></a>基本MVC模式</h2><p>如下图所示为基本的MVC（Model-View-Controller）模式结构图，可分为三部分：模型（Model）、视图（View）、控制器（Controller）。其在MVC模式中所扮演的角色分别为：</p><ol><li>Model：模型管理应用程序的数据，响应有关其状态信息（通常来自View）的请求，并响应指令以更改状态（通常来自Controller）。</li><li>View：视图管理数据的展示。</li><li>Controller：控制器解释用户的输入，并通知模型、视图进行状态更新。</li></ol><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/basic-MVC.png" alt=""></p><p>其中，View和Controller依赖于Model，而Model并不依赖于View和Controller。这种设计模式的优点在于允许Model不受View的影响，从而能够进行独立的构建和测试。</p><p>此外，根据Model的具体实现还可以进一步分为：<strong>主动型Model</strong>、<strong>被动型Model</strong>。</p><h3 id="被动型Model-MVC模式"><a href="#被动型Model-MVC模式" class="headerlink" title="被动型Model MVC模式"></a>被动型Model MVC模式</h3><p>当只有一个Controller操控着Model时可以采用<strong>被动型Model</strong>。Controller定义Model，并在Model发生改变时通知View，后者再进行更新。在这种场景下，Model完全独立于View和Controller。实际上，被动型Model MVC模式就基本的MVC模式。</p><h3 id="主动型Model-MVC模式"><a href="#主动型Model-MVC模式" class="headerlink" title="主动型Model MVC模式"></a>主动型Model MVC模式</h3><p>当Model的状态未受Controller干扰的情况下发生变化时，使用<strong>主动型Model</strong>。当其他来源正在更改数据并且必须立刻反应到View中时，可能会发生这种情况。</p><p>为了实现主动型Model，通常使用Observer模式来提供了一种机制来提醒其他对象的状态变化，避免引入依赖关系。各个View实现Observer接口并向Model注册。当Model发生变化时，Model会遍历所有注册的观察者并通知他们相关的变化。这种方法通常被称为“发布 - 订阅”。Model从不需要关于任何View的任何信息。事实上，在Controller需要被告知Model变化的情况下（例如，启用或禁用菜单选项），所有Controller必须通过实现Observer接口并订阅Model的变化。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/active-model-MVC.png" alt=""></p><h2 id="传统版MVC"><a href="#传统版MVC" class="headerlink" title="传统版MVC"></a>传统版MVC</h2><p>上述主动型Model MVC模式通过加入Observer模式进行了改良。事实上，随着业务需求的变化，MVC模式通过不断加入一些更基本的设计模式采演化成现在经典的MVC模式。这些基本模式协同工作，定义了MVC应用程序特有的功能分离和通信路径。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/traditional-MVC.png" alt=""></p><p>上图所示为传统MVC设计模式，其通过Composition、Strategy、Observer等基本设计模式协同工作以实现。用户操作在复合结构的某个层次上操作View，生成一个事件。Controller接收事件，并进行解释。这个过程使用Strategy模式实现，可以是通过消息请求一个Model对象来更新其状态或请求一个View对象来更新其行为或外观。Model对象则在其状态改变时通知所有已注册为观察者的对象。如果观察者是对象，则可以相应更新其外观。</p><h2 id="苹果版MVC"><a href="#苹果版MVC" class="headerlink" title="苹果版MVC"></a>苹果版MVC</h2><p>苹果认为传统的MVC模式中，View通过Observer模式直接观察Model对象以获取相关的通知，而这样的设计会导致View和Model对象不能被广泛复用，因为View与其观察的Model之间存在耦合关系。因此，苹果版MVC与传统MVC基本一致，只是隔离了View和Model。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/apple-MVC.png" alt=""></p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>MVP（Modell-View-Presenter）模式其实和苹果版MVC是一样的。两者的优点很明确，解耦View和Model，提高了View和Model的复用程度。缺点也是很明显，即Presenter（Controller）会变得非常臃肿，毕竟其不仅包含了业务逻辑，还负责View和Model之间的通信。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/MVP.png" alt=""></p><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>MVVM（Model View View-Model）就是为了解决MVP中Presenter过于臃肿的问题。MVVM的思想是将Controller中UI控制逻辑与业务逻辑进行分离，并抽离出一个View-Model来完成UI控制的逻辑。而Controller只需要负责业务逻辑即可。如下图便是MVC（MVP）转换成MVVM之后的结构图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/MVVM-based-on-MVC.png" alt=""></p><p>通常，View-Model可以调用Model定义的方法，从Model中获取数据以用于View，并对数据进行预处理，使View可以直接使用。View又可以向View-Model发出用户的操作命令，从而更改Model。MVVM实现了一种双向绑定机制。</p><p>MVVM的优点在于：降低了View和Model之间的耦合；分离了业务逻辑和视图逻辑。缺点在于：View和Model双向绑定导致bug难以定位，两者中的任何一方出现问题，另一方也会出现问题；增加了胶水代码。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://msdn.microsoft.com/en-us/library/ff649643.aspx" target="_blank" rel="noopener">Model-View-Controller</a></li><li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html" target="_blank" rel="noopener">Concepts in Objective-C Programming</a></li><li><a href="https://msdn.microsoft.com/en-us/library/hh848246.aspx" target="_blank" rel="noopener">The MVVM Pattern</a></li><li><a href="https://www.jianshu.com/p/caaa173071f3" target="_blank" rel="noopener">iOS 关于MVC和MVVM设计模式的那些事</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC, MVP和MVVM</a></li><li><a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="noopener">被误解的MVC和被神化的MVVM</a></li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在iOS开发中苹果定义了一套MVC的软件架构。前几天，同事们聊起了MVC、MVP、MVVM等架构的区别。今天，我也来对此给出一些自己的理解。&lt;/p&gt;
&lt;h1 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="软件" scheme="http://chuquan.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="设计模式" scheme="http://chuquan.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="MVC" scheme="http://chuquan.me/tags/MVC/"/>
    
      <category term="MVP" scheme="http://chuquan.me/tags/MVP/"/>
    
      <category term="MVVM" scheme="http://chuquan.me/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>基于树的iOS页面路径转换设计</title>
    <link href="http://chuquan.me/2018/04/01/ios-tree-based-path-conversion-design/"/>
    <id>http://chuquan.me/2018/04/01/ios-tree-based-path-conversion-design/</id>
    <published>2018-04-01T06:32:18.000Z</published>
    <updated>2018-04-01T06:43:29.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h1><p>在iOS客户端采集用户操作页面的完整路径，如：”首页” -&gt; “搜题历史页” -&gt; “题目详情页1” -&gt; “名师大招”。</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ol><li>易用性</li><li>可靠性</li></ol><h1 id="方案分析"><a href="#方案分析" class="headerlink" title="方案分析"></a>方案分析</h1><p>考虑到上述两个设计原则，路径转换在每个页面中的使用都不应该受限于其相对于其他页面的位置或关系。简而言之，即具备独立性和通用性。以view controller为例，路径转换在特定的生命周期阶段使用，就是符合设计原则的。</p><p>以下有两种方案：基于栈的设计、基于多叉树的设计。下面依次进行分析。</p><h2 id="基于栈的设计"><a href="#基于栈的设计" class="headerlink" title="基于栈的设计"></a>基于栈的设计</h2><p>下图所示为两个View Controller切换时，各个VC的生命周期的切换顺序，其中A为父VC，B为子VC。为遵循上述设计原则，我们希望能够在特定生命周期进行push/pop操作。合法的push/pop组合应该遵循如下的调用顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A push -&gt; B push -&gt; B pop -&gt; A pop</span><br></pre></td></tr></table></figure></p><p>然而，我们在下图中找不到一个合法的push/pop组合，除了【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】这种情况。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vcs-lifecycle.png?x-oss-process=image/resize,w_570" alt=""></p><p>那么，在【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】是不是真能应对所有场景呢？</p><p>试想如下图所示这样一种场景，当一个VC包含多个VC对象时，其中一个VC再调用子VC。这时候，我们期望得到的路径应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; D -&gt; E</span><br></pre></td></tr></table></figure></p><p>然而在很多情况下，A会在<code>init</code>/<code>viewDidLoad</code>阶段初始化多有VC对象。这时候如果使用的是【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】这种组合，在E中得到的路径会是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; D -&gt; E</span><br></pre></td></tr></table></figure></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-multisubvcs-structure.png?x-oss-process=image/resize,w_250" alt=""></p><p>综合上述，使用栈结构很难实现一种易用、可靠的设计方案。</p><h2 id="基于树的设计"><a href="#基于树的设计" class="headerlink" title="基于树的设计"></a>基于树的设计</h2><p>于是，我们使用多叉树实现了一个易用、可靠的路径转换方案。如下左图所示，为一个app经常会面临的vc结构。我们使用多叉树来描述app的vc结构。在任何时候，页面总是能够返回到根页面（tab页），所以树节点不会形成环，即可以使用树结构来进行描述，如右图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tree-based-path-conversion-design.png" alt=""></p><p>其中，树节点包括四个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface TreeNode : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) NSInteger parentId;   // 记录创建本节点的父节点ID</span><br><span class="line">@property (nonatomic, assign) NSInteger nodeId;     // 本节点ID</span><br><span class="line">@property (nonatomic, strong) NSString *keyfrom;      // 节点信息</span><br><span class="line">@property (nonatomic, strong, nullable) NSMutableArray&lt;TreeNode *&gt; *subNodes;   // 子节点指针</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>使用单例来保存一个全局的根节点（<code>root</code>）以及一个动态变更的全局父节点ID（<code>parentId</code>）。</p><p>使用的方法是：</p><ol><li>在<code>viewDidLoad</code>阶段，创建节点，将其<code>parentId</code>属性设置为全局父节点ID（<code>parentId</code>）的值，与vc绑定。</li><li>在<code>viewWillAppear/viewDidAppear</code>阶段或者在进入新页面之前，将全局父节点ID（<code>parentId</code>）设置为当前vc节点的<code>nodeId</code>。</li><li>在<code>dealloc</code>阶段，将全局父节点ID（<code>parentId</code>）设置为本节点<code>parentId</code>属性的值，并从树中删除本节点。</li></ol><p>提供的接口如下所示：</p><pre><code>// 创建根节点- (void)createKeyfromRootNode;// 设置全局父节点ID（parentID）- (void)setParentNodeWithNodeId:(NSInteger)nodeId;// 向树中添加子节点（keyfromType，param用于描述节点信息）- (TreeNode *)addKeyfromNodeWithKeyfromType:(KeyfromType)keyfromType                                       param:(nullable NSString *)param;// 从树中删除子节点- (void)removeKeyfromNodeWithNodeId:(NSInteger)nodeId;// 更新指定节点的节点信息- (void)updateKeyfromNodeWithNodeId:(NSInteger)nodeId                        keyfromType:(KeyfromType)keyfromType                              param:(nullable NSString *)param;// 获取从根节点到指定节点的路径- (NSString *)keyfromPathWithNodeId:(NSInteger)nodeId;// 获取从根节点到当前节点的路径- (NSString *)keyfromPath;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实践证明，这种设计方案还能够非常简单地应用到一下这些场景之中。</p><ol><li>view Controller、View混合路径；</li><li>统跳；</li><li>view Controller多处复用、节点信息不同；</li><li>忽略路径中特定节点</li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;需求场景&quot;&gt;&lt;a href=&quot;#需求场景&quot; class=&quot;headerlink&quot; title=&quot;需求场景&quot;&gt;&lt;/a&gt;需求场景&lt;/h1&gt;&lt;p&gt;在iOS客户端采集用户操作页面的完整路径，如：”首页” -&amp;gt; “搜题历史页” -&amp;gt; “题目详情页1” -&amp;gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="路径转化" scheme="http://chuquan.me/tags/%E8%B7%AF%E5%BE%84%E8%BD%AC%E5%8C%96/"/>
    
      <category term="设计" scheme="http://chuquan.me/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《徐彬说投资》笔记</title>
    <link href="http://chuquan.me/2018/02/23/xubing-investment/"/>
    <id>http://chuquan.me/2018/02/23/xubing-investment/</id>
    <published>2018-02-23T14:58:22.000Z</published>
    <updated>2018-02-23T15:01:44.211Z</updated>
    
    <content type="html"><![CDATA[<p>几个月前，在脉脉上订阅了一个付费的音频课程——《徐彬说投资》。课程每天更新（工作日），共48节。虽然课程内容的连贯性不是非常强，但是对于非专业人士来说，这是一个非常好的理财入门课程。以下内容是我在听完该课程后做的一些笔记和总结。原始笔记<a href="https://note.youdao.com/share/?id=ce6a0c26ad775e2ac31665738ebfc131&amp;type=note#/" target="_blank" rel="noopener">在这里</a></p><h1 id="如何计算自己有多少钱可以用于理财？"><a href="#如何计算自己有多少钱可以用于理财？" class="headerlink" title="如何计算自己有多少钱可以用于理财？"></a>如何计算自己有多少钱可以用于理财？</h1><p>对于我们普通人来说，每个月能够剩余下来的钱（<strong>自由现金流</strong>）均可以用于理财。自由现金流计算公式如下：</p><blockquote><p><strong>自由现金流 = 收入 - 支出</strong><br><strong>收入</strong> = 劳动收入（工资）<br><strong>支出</strong> = 必需支出（房租、房贷、生活费等） + 可选支出（娱乐费用）  </p></blockquote><p>因此，要想有多余的钱理财，必须保证自由现金流为正。如何保证自由现金流为正？两个方法：</p><ul><li><strong>开源</strong>：增加收入</li><li><strong>节流</strong>：减少支出</li></ul><p>很明显，自己容易控制的便是减少支出，其中<strong>可选支出</strong>可控程度是比较大的。</p><p>生活处处有风险，常见有两种风险可能会导致自由现金流为负：<strong>重大疾病</strong>、<strong>失业</strong>。为应对这两种风险，一般我们的措施是：</p><ul><li><strong>重大疾病</strong>：购买重疾险</li><li><strong>失业</strong>：预存应急资金。假设失业以后6个月后必能找到工作。可以将6个月的总支出定为应急资金。应急资金需要充分利用，应该放在货币基金，风险相对较小。</li></ul><p>一般而言，理财收入不能算入收入，各种奖金也不应该算入收入。通过上述公式便可计算出自己有多少钱可用于理财。</p><h1 id="理财的基本概念"><a href="#理财的基本概念" class="headerlink" title="理财的基本概念"></a>理财的基本概念</h1><p>在理财前，投资者需要了解一下这些概念：</p><ol><li><p>任何理财产品都是具有风险的，而风险的本质便是<strong>波动</strong>。比如：股票价格的涨跌波动。</p></li><li><p><strong>风险与收益成正比</strong>。另外还需要有充分的<strong>时间</strong>进行保障。</p></li><li><p><strong>可投资标的</strong>：哪些资产可以在自己的投资期限内进行投资。</p></li><li><p><strong>风险承受能力</strong>：评估可投资标的在投资期限内的最大投资亏损。很多投资亏损就是由于投资前没有评估好自己的风险承受能力，心态受到市场情绪影响导致的。</p></li></ol><h1 id="股票与债券"><a href="#股票与债券" class="headerlink" title="股票与债券"></a>股票与债券</h1><p>我们都知道股票和债券，那么这两者是什么？有什么区别呢？</p><p>一切要从<strong>价值分配模型</strong>说起，价值分配模型包含两部分，分别是<strong>劳动价值</strong>、<strong>剩余价值</strong>。</p><p>一般来说，一个公司的资本分为两类：<strong>债券</strong>、<strong>股票</strong>。相应的投资人也分为两类：<strong>债券投资人</strong>、<strong>股票投资人</strong>（股东）。公司将其运营产生的<strong>剩余价值</strong>通过债券、股票分配给投资人。</p><blockquote><p>假设公司不用交税，一年挣了3千万（即剩余价值）。假设去年发行了一个亿3年期，每年利息10%的债券。那么公司的3千万，债券投资人拿走1千万（1亿 x 10%）。其他全部分给股票投资人。</p><p>如果一年收益1亿，债券投资人只能拿1千万，而股票投资人则可以拿9千万。</p></blockquote><p>相比而言，债券投资人获取收益的优先级更高，收益比股票投资人更明确。即无论有多少剩余价值，都优先分给债券投资人。在上述例子中，债券的收益是每年10%。而股票的风险比较大，对应的收益也可能更高。</p><p>通常，大企业的优势是收益稳定，劣势是发展空间有限；中小企业的优势是发展潜力，劣势是收益。因此，大企业的债券比较可靠，股票的增值空间相对较小；中小企业的债券短期内不一定有收益，长期来看其股票增值空间相对较大。</p><p>关于股票，公司分配给股票投资者的价值有两种方式：</p><ol><li><strong>发放现金分红</strong></li><li><strong>股票价格上涨</strong>：如果公司在一段时间内的收益越高，希望投资的人越多，股票价格会变得越高。</li></ol><h1 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h1><p>如果投资期限为一年，最好的投资标的是<strong>货币基金</strong>，如余额宝。货币基金是<strong>公募基金</strong>的一种。货币基金有以下优点：</p><ul><li>货币基金的门槛很低，一块钱都可以</li><li>货币基金的各种费用很低</li><li>风险极低</li><li>每天都有收益，包括节假日</li><li>货币基金非常灵活，买入后立刻产生收益。</li><li>货币基金往往在其他投资标的表现不好时，收益会更好。</li></ul><p>货币基金主要有两个指标:</p><ul><li><strong>七日年化收益率</strong>：过去七天平均每天的收益如果持续一年可以产生的收益</li><li><strong>万份收益</strong>：货币基金会保持每份一元的净值水平。因此，货币基金的总资产等于货币基金的总份数。每一万份货币基金，在过去一天产生的收益。</li></ul><p>那么为什么货币基金风险很低？这是因为货币基金的投资标的是<strong>短期国债</strong>、<strong>中央银行票据</strong>、<strong>银行背书的商业汇票</strong>、<strong>银行承兑汇票</strong>、<strong>银行定存</strong>、<strong>大额可转让存单</strong>等。这些都是金融投资风险最低。另一方面，货币基金的管理要求非常高，如果基金经理的货币基金做亏了，基本职业生涯完了。所以，货币基金的风险非常低。</p><p>货币基金适合投资期限小于一年，随取随存的场景，对于应急资金和工资来说非常适合。我们平时所用的余额宝、活期宝便是货币基金。相对其它投资标的，货币基金收益也较低，一年的收益率大概为4%左右。</p><h2 id="货币基金的4个投资技巧"><a href="#货币基金的4个投资技巧" class="headerlink" title="货币基金的4个投资技巧"></a>货币基金的4个投资技巧</h2><ul><li>季度末，半年末，年末，货币基金的收益率比较高。</li><li>关注央行的行为。其会影响金融市场的流动性。央行加息，提高存款准备金率，会造成市场的钱变少，从而提高货币基金的收益率。</li><li>当股市、债市表现不好时候，往往货币基金表现较好（目前市场共有616支货币基金）。</li><li>平时买规模大（5亿元以上）的基金，收益比较稳定。在季度末、年底买规模较小（2亿~5亿）的基金博取高收益。</li></ul><h1 id="银行理财与货币基金"><a href="#银行理财与货币基金" class="headerlink" title="银行理财与货币基金"></a>银行理财与货币基金</h1><p>根据如下2017年的数据显示，理财产品的期限越长，予以的收益也越多。</p><ul><li>银行活期存款利息：一年0.35%</li><li>一年期定期存款：一年1.5%</li><li>三年期定期存款：每年2.75%</li></ul><p>通常，银行理财都是定期，且5万元起购，这与货币基金的差距较大。另一方面，货币基金的监管比银行理财更严格。网上也经常爆出银行理财的一些骗局，我们可以通过网上银行来进行真伪辨认。</p><h1 id="国债逆回购"><a href="#国债逆回购" class="headerlink" title="国债逆回购"></a>国债逆回购</h1><p>国债逆回购，本质就是一种短期贷款。也就是说，个人通过国债回购市场把自己的资金借出去，获得固定的利息收益；而回购方，也就是借款人用自己的国债作为抵押获得这笔借款，到期后还本付息。</p><p>投资者通过股票账户即可投资国债逆回购，国债逆回购具有以下几个基本特点：</p><ul><li><strong>国债逆回购的门槛</strong>：上证交易所，金额必须是10万的整数倍；深证交易所，金额必须是1000的整数倍。</li><li><strong>国债逆回购的价格</strong>：任何股票软件都可查询。</li><li><strong>国债逆回购的收益</strong>：价格、实际占款天数（1、2、3、7）。</li><li><strong>国债逆回购价格的规律</strong>：季度末、年末的利率较高。一般上午高于下午。</li></ul><h1 id="债券基金"><a href="#债券基金" class="headerlink" title="债券基金"></a>债券基金</h1><p>根据2006至2016的数据显示，债券基金平均每年的收益大约为7%。债券的本质是发行债券的机构向投资者借钱，债券基金的收益主要包含两部分：</p><ul><li>利息</li><li>债券的价格波动</li></ul><p>目前市场中的债券基金一共有1000多只。通常而言，债券基金和股票基金呈跷跷板效应，两者的表现是相反的。</p><p><strong>通常不建议自选债券基金进行投资</strong>，其知识门槛较高。此外，债券基金进行为期1~2年的投资。长期投资债券基金必然是赚钱的。</p><h2 id="债券涨跌原理"><a href="#债券涨跌原理" class="headerlink" title="债券涨跌原理"></a>债券涨跌原理</h2><p>在金融体系中钱多（收紧或加速流动性）的时候，债券就会上涨；反之，则下跌。</p><p>金融体系受两方面影响：</p><ul><li><strong>中央银行（中国人民银行，简称央行）货币政策</strong>：如加息降息</li><li><strong>影响金融机构买债的监管政策</strong></li></ul><p>央行主要有两个职能：控制物价（通货膨胀CPI）、维持经济增长（GDP增长率）。如果发生矛盾，以第一项为准。当CPI突破3%，表示通货膨胀过快，需要注意；GDP增长率较低时是投资债券的好时机。</p><h2 id="债券基金投资方法"><a href="#债券基金投资方法" class="headerlink" title="债券基金投资方法"></a>债券基金投资方法</h2><p>债券基金有一个指标——<strong>到期收益率</strong>，表示如果债券没有出现违约，每年的收益率。债券收益率越高，则债券的估值越低。如果在三年期AA+企业债到期收益率超过5%时，投资债券基金，则未来三年，每年收益率大约为8%~10%。</p><p>相关数据表明，长期投资债券基金，亏钱的概率极低。对于债券基金的投资有两个建议：</p><ul><li>债券基金的到期收益率越高，投资债券基金赚得越多</li><li>债券基金应该越跌越买</li></ul><h1 id="什么决定了股票的价格"><a href="#什么决定了股票的价格" class="headerlink" title="什么决定了股票的价格"></a>什么决定了股票的价格</h1><p>前面说到股票投资者的收益主要有两部分：<strong>分红</strong>、 <strong>股票价格的变化</strong>。那么股票的价格是由什么决定的呢？股票的价格可以通过如下公式进行计算：</p><blockquote><p><strong>股票的价格</strong> = <strong>盈利</strong>（每股的盈利） <em>  <em>*市盈率</em></em>（每股市价与每股盈利的比率）</p></blockquote><p>比如，某公司一年盈利1000万元，该公司有一亿股股票，则平均每股的盈利为0.1元。如果市盈率是10倍，即每1元的盈利能力是10元。通过公式计算得出，股票的价格为1元。</p><blockquote><p>1元（股票价格） = 0.1（每股的盈利）* 10（市盈率）</p></blockquote><p>因此，市盈率是衡量股票价格高低的重要指标。<strong>市盈率是由股票市场中所有的股票投资者决定的</strong>。在绝大多数情况下，投资者的情绪比较稳定，市盈率也比较稳定。在某些情况下，投资者的情绪会出现集体波动，在投资者投资情绪乐观时，市盈率偏高；投资情绪悲观时，市盈率偏低。</p><h2 id="如何投资股票"><a href="#如何投资股票" class="headerlink" title="如何投资股票"></a>如何投资股票</h2><p>首先需要评估市场的情绪，乐观、平稳还是悲观？因为投资者的情绪决定了市盈率。有两种评估方法：</p><ul><li><strong>定量分析</strong>：分析历史数据进行总结，对于沪深300指数，市盈率为12-14倍是合理的；对于中证500指数，市盈率为30-35倍是合理的。高于则是乐观，低于则是悲观。</li><li><strong>定性分析</strong>：观察财经媒体和大众市场的情绪。情绪乐观时会多买入，情绪悲观时会多卖出。比如：当很多不懂市场的投资者也在争相买入，则是非常乐观。</li></ul><p>在了解市场情绪之后，只需要做到三点：</p><ul><li>在市场情绪平稳时进行投资，但是不要把所有的前都投进去</li><li>在市场情绪悲观时，不仅自己不能恐慌，而应该鼓起勇气追加投资</li><li>在市场情绪乐观时，不应该追加投资，应该准备卖出</li></ul><h2 id="股票选择"><a href="#股票选择" class="headerlink" title="股票选择"></a>股票选择</h2><p>一般而言，优质、稳定的投资标的应该会产生持续、稳定的<strong>内生收益</strong>。公司的盈利、收益是内生收益的来源。股票投资最重要的收益来源就是内生收益。持续、稳定的内生收益会让投资标的有不断上涨的动力。但是在单只股票中寻找能够产生持续、稳定内生收益的股票非常难。</p><p>投资者可以通过市场表现来挑选股票，比如每半年对A股上市公司进行市值排名，只投资排名前300的公司。A股市场最常用的两个指数是：<strong>沪深300指数</strong>、<strong>中证500指数</strong>。前者包含A股中市值最大的前300家公司；后者包含市值排名第301至800的500家公司。一般排名靠前的大公司，内生收益比较低，稳定性较高，长期收益低。 相对而言，中证500指数包含的公司内生收益相对较高，稳定性一般。</p><h2 id="50AH优选"><a href="#50AH优选" class="headerlink" title="50AH优选"></a>50AH优选</h2><p><strong>上证50指数</strong>：表示上海证券交易所上市的市值最大的50家公司。<br><strong>50AH优选指数</strong>：看上证50指数中哪些公司在大陆和香港同时上市，挑选价格便宜的进行投资。</p><p>根据2015至2017年数据显示，50AH优选指数跑赢了上证50指数8个百分数。因此，投资者也可以根据50AH优选指数来进行股票选择</p><h1 id="基金的选择"><a href="#基金的选择" class="headerlink" title="基金的选择"></a>基金的选择</h1><p>目前市场中共有3485只基金，其从投资标的上来分可分为三种：</p><ul><li><strong>货币基金</strong></li><li><strong>债券基金</strong></li><li><strong>股票基金</strong>：变数最大，主要是对比业绩基准。</li></ul><p>根据管理方式来分类，基金可以分为两类：</p><ul><li><strong>被动管理型基金</strong>（指数基金）：其跟随沪深300指数。管理费较低，每年0.7%。 </li><li><strong>主动管理型基金</strong>：想尽一切办法打败业绩基准。研究员使用数据模型定量分析，管理费相对较高，每年1.5%。</li></ul><p>国外一个惊人的理论：绝大多数主动管理型基金很难跑过大盘指数。然而，在中国则截然相反，这是因为美国绝大部分的投资者是投资机构。中国股市有大量的散户，投资机构很容易跑赢散户。在中国，主动型管理基金更好。港股和美股则相反。在中国，股票基金平均收益率约为20%，沪深300每年约为10%。</p><h1 id="如何选择基金"><a href="#如何选择基金" class="headerlink" title="如何选择基金"></a>如何选择基金</h1><p>股票基金的收益有两个来源：</p><ul><li>对标的股票指数的股票收益</li><li>股票基金跑赢股票指数的跑赢收益，即<strong>跑赢收益</strong>。跑赢收益是真正衡量基金经理能力的指标。</li></ul><p>选择基金的完整流程：</p><ul><li>第一步，选择未来会上涨的股票指数。只要股票指数的市盈率处于合理或偏低的水平，都可以选择。</li><li>第二步，在所有以这个股票指数为业绩基准，即对标的股票指数的股票基金里，选择跑赢收益比较高，且稳定性比较好的股票基金。量化基金的跑赢收益更低，稳定性更好。传统基金的跑赢收益更好，稳定性更差。</li><li>第三步，研究基金的策略，判断基金收益是否可持续。比如：通过基金经理访谈。</li></ul><h1 id="股票基金收益来源的“终极”公式"><a href="#股票基金收益来源的“终极”公式" class="headerlink" title="股票基金收益来源的“终极”公式"></a>股票基金收益来源的“终极”公式</h1><blockquote><p><strong>股票基金的收益</strong> = <strong>对标股票指数的收益</strong> + <strong>跑赢收益</strong></p></blockquote><p><strong>股票指数</strong>是由若干股票组成，可以用于分析股票。每只股票都是一个公司的代表，绝大部分长期来说，其价值在不断提升。通常使用<strong>内生收益</strong>表示股票价值提升带来的收益。但是有内生收益不一定会带来投资收益。</p><p>股票价格的终极计算公式为，其中内生收益代表盈利的上升速度，长期来说内生收益都是正的。</p><blockquote><p><strong>股票价格</strong> = <strong>盈利</strong> <em> <em>*市盈率</em></em> </p></blockquote><p>那么应该如何确定内生收益？沪深300指数的内生收益和名义GDP增速差不多，稍微高一点。名义GDP和统计局公布的GDP不是一回事，后者是实际GDP增速，前者在实际GDP增速的基础上加上物价增速（即CPI）。名义GDP更多的体现实际的经济发展，更适合描述企业收入和盈利的增长速度。中国的GDP大概维持在6-7%，CPI大概在2%，所以名义GDP大概维持在8-9%。因此，沪深300指数的内生收益大约8-9%（非客观）。</p><p>另一方面，市盈率会围绕着合理水平波动。投资者给出的价格水平，乐观时比较高，悲观时比较低。当市盈率回归到合理水平的过程中，产生的收益叫<strong>储备收益</strong>。因此，可以得到股票指数的收益的公式。</p><blockquote><p><strong>股票指数的收益</strong> = <strong>内生收益</strong> + <strong>储备收益</strong></p></blockquote><p>进一步得出股票基金的收益公式：</p><blockquote><p><strong>股票基金的收益</strong> = <strong>内生收益</strong>（经济发展） + <strong>储备收益</strong>（投资者心理波动） + 跑赢收益（基金经理的能力）</p></blockquote><h1 id="定投"><a href="#定投" class="headerlink" title="定投"></a>定投</h1><p>定投：表示定期、定额地投资某一个理财产品的投资方式。这是一种兼顾省心、高收益的投资方式。其适用于长期投资。例如：每个月买1000元的公募基金。</p><p>定投为何会赚钱？这是定投可以大幅降低投资风险，只要坚持就能赚钱。定投期间如果基金曲线呈现微笑曲线，则必然是赚钱的，即<strong>定投第一定理</strong>。</p><p>定投是一种守株待兔的方式，经济是由周期的，只要耐心定投，就肯定能赚钱。</p><h2 id="定投开始时机"><a href="#定投开始时机" class="headerlink" title="定投开始时机"></a>定投开始时机</h2><p>在低于市盈率合理值时投资。在沪深300市盈率14倍或中证500市盈率35倍以下可以投。</p><h2 id="定投结束时机"><a href="#定投结束时机" class="headerlink" title="定投结束时机"></a>定投结束时机</h2><p>3个原则：</p><ul><li>定投还没开始赚钱，永远不要考虑结束</li><li>只要股市估值还没有达到正常水平以上，就不要考虑退出。</li><li>当股市估值回到正常水平以上，应该跟随市场不断变化、计划卖出的点位，即止盈点。比如，当这轮行情市盈率跌倒最高点10%以下，止盈。</li></ul><h2 id="一个真实的定投案例"><a href="#一个真实的定投案例" class="headerlink" title="一个真实的定投案例"></a>一个真实的定投案例</h2><p>3-5年长期的准备，定投。<br>2011年开始，定投沪深300指数4年，总收益80%，平均每年收益15.2%。 分为七个阶段</p><ul><li>2011年4月开始定投到A点，截止2011年12月27日累计亏损19%。从2011年4月开始，中国经济增长率从每年10%下调至8%。同时CPI很高，在2011年年终，达到了6%以上。央行通过加息来降低CPI。沪深300指数从2011年4月的3400点一路跌到年底的2300点，跌幅达到32%。</li><li>A点到B点，截止2012年5月累计盈利0.1%。从2011年底到2012年5月，沪深300指数从2300点反弹到2700点，赚0.1%。</li><li>B点到C点，截止2012年12月累计亏损17.5%。从2012年5月到2012年12月，沪深300指数开启长达8个月的下跌。从2700点跌至2100点，跌幅达到22%。创出了3年新低。</li><li>C点到D点，两年累计盈利8.7%。2012年12月5日的大涨，开启了一波小牛市。沪深300指数用了两个月一口气从2100点涨到了2800点附近，涨幅达到33%。</li><li>D点到E点，累计亏8.5%。2013年2月之后，沪深300指数开始调整，2013年6月开始从2600到2300，跌幅达到22%。2014年7月底，市盈率只有8.2倍，储备收益高达70%。</li><li>F点到完美结局，累计大赚80%。2014年7月到2015年6月，沪深300指数从2200点一路上涨到5380点，上涨幅度达到145%。</li></ul><p>定投总共4年2个月中，有3年3个月是处于亏损状态。是否掌握一定的定投知识将决定成败。经济每五年一个周期，对应到股市就是每5年一个大牛市。定投就是抓住这5年一次的牛市。定投很有可能三年不开张，开张顶三年！</p><h1 id="如何做投资决策"><a href="#如何做投资决策" class="headerlink" title="如何做投资决策"></a>如何做投资决策</h1><p>做投资决策前需要做到以下几点：</p><ul><li>分析一笔钱可能出现的结果有哪几类？</li><li>对每一种结果评估概率</li><li>对每一种结果给出一种应对措施<ul><li>如果赚钱了是否止盈，什么时候止盈</li><li>如果亏钱了是否止损，什么时候止损</li><li>如果赚钱了是否追加投资，什么时候</li><li>如果亏钱了是否追加投资，什么时候</li></ul></li></ul><p>在投资前思考风险可以让我们在投资过程中保持良好的心态。另外，还需要评估好投资周期、盈亏幅度。</p><p>关于如何控制风险？这里也有两种参考方式：</p><ul><li>选择一条移动平均线，一旦大盘跌破这条线就止损。根据历史数据显示，60天移动平均线是最优化的选择。</li><li>设定一个自己愿意接受的亏损比例，如10%。每天记录总资产额。当某天的总资产额比最高总资产额低10%时，可以止损了。</li></ul><h1 id="关于投资笔记"><a href="#关于投资笔记" class="headerlink" title="关于投资笔记"></a>关于投资笔记</h1><p>投资笔记是执行投资、学习投资过程中一个非常重要且有意义的方式。投资笔记有以下优点：</p><ul><li>投资笔记可以帮我们指定投资决策，包括分析过程，思考逻辑，决策分析。投资是不能随机应变的。这是因为，一方面，投资相对比较复杂，需要实现做好预案。另一方面，投资是逆直觉，逆决策的。</li><li>投资笔记可以更好地帮助我们复盘。比如在投资过程中哪些地方做对了，结果及其原因又是什么。通过投资笔记，可以对每一个节点的行为逻辑和心态，复盘结果，更重要的是原因。</li><li>投资笔记可以帮助我们获得更多的知识。</li></ul><h1 id="投资时需要掌握的重要数据"><a href="#投资时需要掌握的重要数据" class="headerlink" title="投资时需要掌握的重要数据"></a>投资时需要掌握的重要数据</h1><p>投资标的一定是不停生长出价值的投资标的。</p><ul><li><strong>经济增长率</strong>：经济增长率分为两种：<strong>季度增长率</strong>、<strong>年度增长率</strong>。GDP同比前一年同期增长多少。绝对值。增长率。实现国家经济调控的部门是央行，其主要有两个职责：<strong>控制物价</strong>、<strong>促进经济增长</strong>。当两者冲突时，往往以第一个为主。物价增长率（CPI），中文学名：通货膨胀率。和GDP不同，CPI是每个月都公布的。<strong>如何解读CPI数据：在中国如果CPI达到3%以上，说明物价增长过快了。这时候央行会通过加息，提高存款准备金率等方法来收紧货币。如果CPI跌倒了1%以下，说明物价增长过慢，意味着经济比较低迷，这时候央行会通过降息、降低存款金率等手段来刺激经济。如果CPI处于1~3%为健康状态，央行一般不会进行干涉</strong>。<strong>GDP在6.5%是合适的；CPI在1-3%是合适的。经济增长率的数据由国家统计局公布，www.stats.gov.cn</strong>。GDP和CPI能够勾勒出四个不同的经济周期，见下文。</li></ul><p>股票、债券方面的数据。</p><p>关于股票，A股共有3000多支股票，关注股票指数就够了，包括：<strong>上证50</strong>（超大规模）、<strong>沪深300</strong>（大规模）、<strong>中证500</strong>（中小规模）。平时需要关注着三个指数的盈利增长率和估值水平</p><ul><li><strong>估值水平</strong>：对于估值水平的描述一般用市盈率这个指标，<strong>对于上证50（10-12倍是合理的），对于沪深300（12-15倍是合理的），对于中证500（30-35倍是合理的）</strong>。如果低于，越跌越买；如果处理合理区间，继续持有；如果高于，原则上是不能追加，应该持有+设置好止盈条件等策略。</li><li><strong>盈利增长率</strong>：必须等每个季度上司公司的财报都公布了以后才知道。与GDP类似，盈利增长的趋势比绝对值更加重要。如果盈利增长在减速，股市的增长水平（市盈率水平）就会下降。如果盈利增长在加速，市盈率就会上升。由于关注的是指数的盈利增长，而这些指数包含的公司都是整个经济体系中的中流砥柱，因此可以用GDP的增长趋势来估计指数盈利增长的趋势。</li></ul><blockquote><p>估值水平：每周六公众号公布；盈利增长率：可以用GDP估算。</p></blockquote><p>债券</p><ul><li><strong>到期收益率</strong>：如果持有债券到期，并且借钱的机构没有耍赖不还钱的情况，投资者平均每年能赚百分之多少。不同期限，不同评级的债券的到期收益率都不一样。一般来说，关注三年期，AA+的企业债券的到期收益率就够了。只要这个数据高于5%，投资债券基金都是比较安全的，未来1-2年的收益也是比较可观的。</li></ul><h1 id="美林团队判断经济周期转折点的重点理论"><a href="#美林团队判断经济周期转折点的重点理论" class="headerlink" title="美林团队判断经济周期转折点的重点理论"></a>美林团队判断经济周期转折点的重点理论</h1><p><strong>美林时钟理论</strong>：只用经济增长率（GDP增速）和通货膨胀率（CPI增速）两个宏观经济指标来描述复杂的经济周期。</p><p>运用美林时钟理论，在2006年至2016年，通过资产配置获得11.5倍的收益。全国房价平均每年的年化收益率只有8%。北京的房价平均每年的年化收益率15%。之所以房子赚钱，是因为房价稳定，愿意长期持，复利使得房子显得很赚钱。数据显示，资产配置如果做好了，可以比投资房产更赚钱。</p><p>美林时钟理论用到两个宏观经济指标：<strong>GDP增长率</strong>（描述经济增长速度），<strong>CPI增长率</strong>（描述通货膨胀速度）</p><ul><li><strong>GDP增长率高、CPI增长率低：复苏期</strong></li><li><strong>GDP增长率高、CPI增长率高：过热期</strong></li><li><strong>GDP增长率低、CPI增长率高：滞障期</strong></li><li><strong>GDP增长率低、CPI增长率低：衰退期</strong></li></ul><p><strong>1 -&gt; 2 -&gt; 3 -&gt; 4：美林时钟</strong></p><blockquote><p>复苏期：重仓股票基金（下一周期GDP仍高）。债券的表现不会差（一时半会不会加息，持有债券去赚利息），应该紧盯通胀，高通货膨胀来了应该减仓。</p><p>过热期：中国股市会快速、甚至疯狂上涨。股票继续持有。不应该持有债券基金。关注熊市出现。</p><p>滞涨期：股票基金表现不会，不应该持有。债券不太好。这个时期的目标是不亏钱。应该投资货币基金。</p><p>衰退期：其末期是特别好的抄底机会。重仓持有债券基金。密切关注股票基金。关注股票基金减仓机会。</p></blockquote><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;几个月前，在脉脉上订阅了一个付费的音频课程——《徐彬说投资》。课程每天更新（工作日），共48节。虽然课程内容的连贯性不是非常强，但是对于非专业人士来说，这是一个非常好的理财入门课程。以下内容是我在听完该课程后做的一些笔记和总结。原始笔记&lt;a href=&quot;https://no
      
    
    </summary>
    
      <category term="投资理财" scheme="http://chuquan.me/categories/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="投资" scheme="http://chuquan.me/tags/%E6%8A%95%E8%B5%84/"/>
    
      <category term="理财" scheme="http://chuquan.me/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Logos基础语法</title>
    <link href="http://chuquan.me/2018/02/22/logos-syntax/"/>
    <id>http://chuquan.me/2018/02/22/logos-syntax/</id>
    <published>2018-02-22T05:48:39.000Z</published>
    <updated>2018-02-22T06:54:56.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hook"><a href="#hook" class="headerlink" title="%hook"></a><code>%hook</code></h1><blockquote><p>该指令指定需要hook的class，必须以<code>%end</code>结尾</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">- (void)_menuButtonDown:(id)down &#123;</span><br><span class="line">    NSLog(@&quot;Home Button Pressed&quot;);</span><br><span class="line">    %orig;     // call the original _menuButtonDown:</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="log"><a href="#log" class="headerlink" title="%log"></a><code>%log</code></h1><blockquote><p>该指令在%hook内部使用，将函数的类名、参数等信息写入syslog，可以以<code>%log([(&lt;type&gt;)&lt;expr&gt;, ...])</code>的格式追加其他打印信息。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">- (void)_menuButtonDown:(id)down &#123;</span><br><span class="line">    %log((NSString *)@&quot;iOSRE&quot;, (NSString *)@&quot;Debug&quot;);</span><br><span class="line">    %orig;      // call the original _menuButtonDown:</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="orig"><a href="#orig" class="headerlink" title="%orig"></a><code>%orig</code></h1><blockquote><p>该指令在<code>%hook</code>内部使用，执行被hook的函数的原始代码。此外，还可以利用<code>%orig</code>更改原始函数的参数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%hook SBLockScreenDateViewController</span><br><span class="line">- (void)setCustomSubtitleText:(id)arg1 withColor:(id)arg2 &#123;</span><br><span class="line">    %orig(@&quot;iOS 8 App Reverse Engineering&quot;, arg2);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="group"><a href="#group" class="headerlink" title="%group"></a><code>%group</code></h1><blockquote><p>该指令用户将<code>%hook</code>分组，便于代码管理及按条件初始化分组，必须以<code>%end</code>结尾。一个<code>%group</code>可以包含多个<code>%hook</code>，所有不属于某个自定义group的<code>%hook</code>都会被隐式归类到<code>%group_ungrouped</code>中。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%group iOS7Hook </span><br><span class="line">%hook iOS7Class </span><br><span class="line">- (id)iOS7Method &#123;</span><br><span class="line">    id result = %orig;</span><br><span class="line">    NSLog(@&quot;This class &amp; method only exist in iOS 7.&quot;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">%end // iOS7Hook </span><br><span class="line"></span><br><span class="line">%group iOS8Hook </span><br><span class="line">%hook iOS8Class </span><br><span class="line">- (id)iOS8Method &#123;</span><br><span class="line">    id result = %orig;</span><br><span class="line">    NSLog(@&quot;This class &amp; method only exist in iOS 8.&quot;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">%end // iOS8Hook </span><br><span class="line"></span><br><span class="line">%hook SpringBoard </span><br><span class="line">-(void)powerDown &#123;</span><br><span class="line">    %orig; </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="init"><a href="#init" class="headerlink" title="%init"></a><code>%init</code></h1><blockquote><p>该指令用于初始化某个<code>%group</code>，必须在<code>%hook</code>或<code>%ctor</code>内调用；如果带参数，则初始化指定的group；如果不带参数，则初始化_ungroupded。<strong>只有调用了<code>%init</code>，对应的<code>%group</code>才能起作用</strong>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0</span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 </span><br><span class="line">#endif</span><br><span class="line">%hook SpringBoard</span><br><span class="line">- (void)applicationDidFinishLaunching:(id)application &#123;</span><br><span class="line">    %orig;</span><br><span class="line">    %init; // Equals to %init(_ungrouped) </span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp;</span><br><span class="line">        kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS7Hook);</span><br><span class="line">        </span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS8Hook); </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="ctor"><a href="#ctor" class="headerlink" title="%ctor"></a><code>%ctor</code></h1><blockquote><p>tweak的constructor，完成初始化工作；如果不显示定义，Theos会自动生成一个<code>%ctor</code>，并在其中调用<code>%init(_ungrouped)</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard </span><br><span class="line">- (void)reboot &#123;</span><br><span class="line">    NSLog(@&quot;If rebooting doesn&apos;t work then I&apos;m screwed.&quot;);</span><br><span class="line">    %orig; </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>上述实例可以成功生效，是因为Theos隐式定义了如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%ctor </span><br><span class="line">&#123;</span><br><span class="line">    %init(_ungrouped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>%ctor</code>一般可以用来初始化<code>%group</code>，以及进行<code>MSHookFunction</code>等操作。<code>%ctor</code>不需要以<code>%end</code>结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0</span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 </span><br><span class="line">#endif</span><br><span class="line">%ctor</span><br><span class="line">&#123;</span><br><span class="line">    %init;</span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp; </span><br><span class="line">        kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS7Hook);</span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS8Hook); </span><br><span class="line">    </span><br><span class="line">    MSHookFunction((void *)&amp;AudioServicesPlaySystemSound, </span><br><span class="line">                   (void *)&amp;replaced_AudioServicesPlaySystemSound, </span><br><span class="line">                   (void **)&amp;original_AudioServicesPlaySystemSound); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="new"><a href="#new" class="headerlink" title="%new"></a><code>%new</code></h1><blockquote><p>在<code>%hook</code>内部使用，给一个现有class添加一个新函数，功能与<code>class_addMethod</code>相同。<strong>注意，Objective-C的Category语法也可以给现有的class添加新函数。但区别在于category是静态的，<code>class_addMethod</code>是动态的</strong>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">%new</span><br><span class="line">- (void)namespaceNewMethod &#123;</span><br><span class="line">    NSLog(@&quot;We&apos;ve added a new method to SpringBoard.&quot;); </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="c"><a href="#c" class="headerlink" title="%c"></a><code>%c</code></h1><p>该指令的作用等同于<code>objc_getClass</code>或<code>NSClassFromString</code>，即动态获取一个类的定义，在<code>%hook</code>或<code>%ctor</code>内使用。</p><p>(完)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《iOS应用逆向工程（第2版）》</li><li><a href="http://iphonedevwiki.net/index.php/Logos" target="_blank" rel="noopener">Logos</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hook&quot;&gt;&lt;a href=&quot;#hook&quot; class=&quot;headerlink&quot; title=&quot;%hook&quot;&gt;&lt;/a&gt;&lt;code&gt;%hook&lt;/code&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;该指令指定需要hook的class，必须以&lt;code&gt;%end&lt;/c
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Logos语法" scheme="http://chuquan.me/tags/Logos%E8%AF%AD%E6%B3%95/"/>
    
      <category term="Theos" scheme="http://chuquan.me/tags/Theos/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向工程——基础篇</title>
    <link href="http://chuquan.me/2018/02/06/ios-reverse-engineering-basis/"/>
    <id>http://chuquan.me/2018/02/06/ios-reverse-engineering-basis/</id>
    <published>2018-02-06T14:03:03.000Z</published>
    <updated>2018-02-08T10:27:20.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS文件系统"><a href="#iOS文件系统" class="headerlink" title="iOS文件系统"></a>iOS文件系统</h1><p>iOS由OSX演化而来，而OSX又是基于UNIX的，它们都是类UNIX操作系统。类UNIX操作系统有一套标准的文件系统——<a href="https://wylmer.gitbooks.io/filesystem-hierarchy-standard/content/" target="_blank" rel="noopener">Filesystem Hierarchy Standard（FHS）</a>，其常用目录结构如下所示：</p><ul><li><code>/</code>：根目录</li><li><code>/bin</code>：binary，存放用户级基础功能的二进制文件，如<code>ls</code>、<code>ps</code>等</li><li><code>/boot</code>：存放能使系统成功启动的所有文件。<strong>iOS中此目录为空</strong></li><li><code>/dev</code>：device，存放BSD设备文件。每个文件代表系统的一个块设备或字符设备。块设备以块为单位传输数据，如硬盘；字符设备以字符为单位传输数据，如调制解调器</li><li><code>/sbin</code>：system binaries，存放提供系统级基础功的二进制文件，如<code>netstat</code>、<code>reboot</code>等</li><li><code>/etc</code>：法语Et Cetera（and so on的意思），存放系统脚本及配置文件，如<code>passwd</code>、<code>hosts</code>。iOS中，<code>/etc</code>是一个符号链接，实际指向<code>/private/etc</code></li><li><code>/lib</code>：存放系统库文件、内核模块及设备驱动等。<strong>iOS中此目录为空</strong></li><li><code>/mnt</code>：mount，存放临时的文件系统挂载点。<strong>iOS中此目录为空</strong></li><li><code>/private</code>：存放两个目录，分别是<code>/private/etc</code>和<code>/private/var</code></li><li><code>/tmp</code>：临时目录。iOS中，<code>/tmp</code>是一个符号链接，实际指向<code>/private/var/tmp</code></li><li><code>/usr</code>：包含大多数用户和程序。<ul><li><code>/usr/bin</code>：包含那些<code>/bin</code>和<code>/sbin</code>中未出现的基础功能，如<code>nm</code>、<code>killall</code>等</li><li><code>/usr/include</code>：包含所有的标准C头文件</li><li><code>/usr/lib</code>：存放库文件</li></ul></li><li><code>/var</code>：variable，存放一些经常更改的文件，如日志、用户数据、临时文件等。<ul><li><code>/var/mobile</code>：存放了mobile用户的文件。<strong>逆向工程重点关注目录</strong></li><li><code>/var/root</code>：存放了root用户的文件</li></ul></li></ul><h2 id="iOS独有目录"><a href="#iOS独有目录" class="headerlink" title="iOS独有目录"></a>iOS独有目录</h2><p>下图所示分别是OSX和iOS的根目录结构，与FHS还是有一定的区别。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-reverse-fhs001.png" alt=""></div><p>对于iOS，其独有的目录如下思维导图所示：</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-reverse-fhs002.png?x-oss-process=image/resize,w_500" alt=""></div><ul><li><code>/Applications</code>：存放所有的<strong>系统App</strong>和<strong>来自于Cydia的App</strong>，不包括StoreApp</li><li><code>/Developer</code>：如果一台设备连接Xcode后被指定为调试机，Xcode就会在iOS中生成该目录<ul><li><code>/Developer/Applications</code></li><li><code>/Developer/Library</code></li><li><code>/Developer/Tools</code></li><li><code>/Developer/usr</code></li></ul></li><li><code>/Library</code>：存放一些提供系统支持的数据<ul><li><code>/Library/MobileSubstrate/DynamicLibraries</code>：<strong>存放Cydia安装程序的<code>.plist</code>和<code>.dylib</code>文件</strong></li></ul></li><li><code>/System/Library</code>：iOS文件系统中最重要的目录之一，存放大量系统组件<ul><li><code>/System/Library/Frameworks</code>：<strong>存放iOS中各种日常使用的framework</strong></li><li><code>/System/Library/PrivateFrameworks</code>：<strong>存放iOS中未公开的私有framework</strong></li><li><code>/System/Library/CoreServices/SpringBoard.app</code>：iOS桌面管理器</li></ul></li><li><code>/User</code>：用户目录（<code>mobile</code>用户的<code>home</code>目录），实际指向<code>/var/mobile</code>，存放大量用户数据<ul><li><code>/var/mobile/Media/DCIM</code>：存放照片</li><li><code>/var/mobile/Media/Recording</code>：存放录音文件</li><li><code>/var/mobile/Library/SMS</code>：存放短信数据库</li><li><code>/var/mobile/Library/Mail</code>：存放邮件数据</li><li><code>/var/mobile/Containers</code>：<strong>存放StoreApp</strong>。<ul><li><code>/var/mobile/Containers/Bundle</code>：<strong>存放所有StoreApp的可执行文件和相关资源</strong></li><li><code>/var/mobile/Containers/Data</code>：<strong>存放所有StoreApp的数据，沙盒目录的真实目录</strong></li></ul></li></ul></li></ul><h2 id="iOS应用（StoreApp）沙盒"><a href="#iOS应用（StoreApp）沙盒" class="headerlink" title="iOS应用（StoreApp）沙盒"></a>iOS应用（StoreApp）沙盒</h2><p>出于安全考虑，iOS系统把每个应用（StoreApp）以及数据都放到一个沙盒（sandbox）里面，应用只能访问自己沙盒目录里面的文件、网络资源等（也有例外，比如系统通讯录、照相机、照片等能在用户授权的情况下被第三方应用访问）。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-reverse-fhs004.png?x-oss-process=image/resize,w_500" alt=""></div><p>上图所示为沙盒结构，沙盒在逻辑上包含两个部分：<code>Bundle Container</code>和<code>Data Container</code>，两者在iOS文件系统中的位置是平行的，分别是<code>/var/mobile/Containers/Bundle</code>和<code>/var/mobile/Containers/Data</code>。实际开发中，通过<code>NSHomeDirectory()</code>方法获取到沙盒根目录对应的是<code>Data Container</code>的路径。</p><h3 id="Bundle-Container"><a href="#Bundle-Container" class="headerlink" title="Bundle Container"></a>Bundle Container</h3><p>bundle的概念源自于NeXTSTEP，它是一个按某种标准结构来组织的目录，其中包含了二进制文件及运行所需的资源。正向开发中常见的App和framework都是以bundle的形式存在。在越狱iOS中常见的PreferenceBundle是一种依附于Settings的App，结构与App类似，本质也是bundle。Framework也是bundle，但framework的bundle中存放的是一个dylib（动态库），而非可执行文件。</p><p>在正向开发时，我们上传至App Store的ipa（iPhone Application）包，解压后会有一个<code>Payload</code>目录，其内部又包含一个<code>.app</code>目录，这个目录就是一个App的目录结构，也是一个bundle。</p><p><code>Bundle Container</code>位于<code>/var/mobile/Containers/Bundle/Application/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/</code>主要用于存放静态资源，主要包含以下目录和文件：</p><ul><li><p><strong><code>MyApp.app</code></strong><br>  存放可执行文件和资源文件，包括：打包时的资源文件、本地文件、可执行文件、<code>.plist</code>文件。这个目录不会被iTunes同步。</p></li><li><p><strong><code>iTunesArtWork</code></strong></p></li><li><strong><code>iTunesMetadata.plist</code></strong></li></ul><h3 id="Data-Container"><a href="#Data-Container" class="headerlink" title="Data Container"></a>Data Container</h3><p><code>Data Container</code>位于<code>/var/mobile/Containers/Data/Application/YYYYYYYY-YYYY-YYYY-YYYYYYYYYYYY/</code>，主要用于存放App运行时产生的动态数据，其主要包含以下目录和文件：</p><ul><li><strong><code>Documents</code></strong><br>  存放应用运行时生成的并且需要保存的不可再生数据。注：iTunes或iCloud同步设备时会备份该目录</li><li><strong><code>Library</code></strong> <ul><li><strong><code>Library/Caches</code></strong><br>  存放应用运行时生成且需要保存的可再生数据，比如网络请求，用户需要负责删除对应文件。iTunes或iCloud不同步。</li><li><strong><code>Library/Preferences</code></strong><br>  存放偏好设置。使用<code>NSUserDefaults</code>写的设置数据都会保存在该目录下的一个<code>plist</code>文件中。iTunes或iCloud同步设备时备份该目录。</li></ul></li><li><strong><code>tmp</code></strong><br>  存放应用下次启动不再需要的临时文件。当应用不再需要这些文件的时候，需要主动将其删除。（当应用不再运行的时候，系统可能会将此目录清空。）这个目录不会被iTunes同步。</li></ul><p>在正向开发时，沙盒目录路径均有相应的获取方式，具体如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 沙盒目录</span><br><span class="line">NSLog(@&quot;%@&quot;,NSHomeDirectory());</span><br><span class="line">  </span><br><span class="line">// MyApp.app</span><br><span class="line">NSLog(@&quot;%@&quot;,[[NSBundle mainBundle] bundlePath]);</span><br><span class="line">  </span><br><span class="line">// Documents</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *docPath = [paths objectAtIndex:0];</span><br><span class="line">NSLog(@&quot;%@&quot;,docPath);</span><br><span class="line">  </span><br><span class="line">// Library</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *libPath = [paths objectAtIndex:0];</span><br><span class="line">NSLog(@&quot;%@&quot;,libPath);</span><br><span class="line">  </span><br><span class="line">// tmp</span><br><span class="line">NSLog(@&quot;%@&quot;,NSTemporaryDirectory());</span><br></pre></td></tr></table></figure></p><p>在逆向工程中，可以通过以下方式获取相关的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取App的Bundle路径</span><br><span class="line">iphone: root# ps -e | grep appname</span><br><span class="line">  </span><br><span class="line">// 获取App的Data路径</span><br><span class="line">iphone: root# cycript -p appname</span><br><span class="line">cy# directory = NSHomeDirectory()</span><br></pre></td></tr></table></figure></p><h1 id="iOS二进制文件类型"><a href="#iOS二进制文件类型" class="headerlink" title="iOS二进制文件类型"></a>iOS二进制文件类型</h1><p>iOS逆向的目标主要包含三类二进制文件：<code>Application</code>、<code>Dynamic Library</code>、<code>Daemon</code>。</p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>Application，即我们最熟悉的App。App的Bundle目录有以下三个部分比较重要：</p><ul><li><p><code>Info.plist</code><br>  Info.plist记录了App的基本信息，如：<strong><code>bundle identifier</code></strong>、<strong>可执行文件名</strong>、<strong>图标文件名</strong>等。</p></li><li><p>可执行文件<br>  查看Info.plist，即可定位可执行文件</p></li><li><p>lproj目录<br>  lproj目录下存放的是各种本地化的字符串。</p></li></ul><h3 id="系统App-VS-StoreApp"><a href="#系统App-VS-StoreApp" class="headerlink" title="系统App VS. StoreApp"></a>系统App VS. StoreApp</h3><p><code>/Applications/</code>目录下存放<strong>系统App</strong>（包括CydiaApp）；<code>/var/mobile/Containers/</code>目录下存放<strong>StoreApp</strong>。其区别在于：</p><ul><li><p>目录结构<br>  两种App的Bundle目录区别不大，都含有Info.plist、可执行文件、lproj目录等。只是Data目录的位置不同：StoreApp的数据目录在<code>/var/mobile/Containers/Data/</code>下，以mobile权限运行的系统App的数据目录在<code>/var/mobile/</code>下，以root权限运行的系统App的数据目录在<code>/var/root/</code>下。</p></li><li><p>安装格式和权限<br>  Cydia App的安装格式一般是deb，StoreApp的安装格式一般是ipa。前者的属主用户和属主组一般是root和admin，能够以root权限运行；后者的属主用户和属主组都是mobile，只能以mobile权限运行。</p></li></ul><h2 id="Dynamic-Library"><a href="#Dynamic-Library" class="headerlink" title="Dynamic Library"></a>Dynamic Library</h2><p>Dynamic Library简称dylib，即动态链接库。在正向开发中，在Xcode工程中导入的各种framework，链接的各种lib，其本质都是dylib。</p><p>在iOS中，lib分为static和dynamic两种，其中static lib在编译阶段成为App可执行文件的一部分，会增加可执行文件的大小。dylib则不会改变可执行文件的大小，只有当App运行时调用到dylib时，iOS才会把它加载进内存，成为App进程的一部分。</p><p><strong>dylib是逆向工程的重要目标类型</strong>，但其本身并不是可执行文件，不能独立运行，只能为别的进程服务，而且它们寄生在别的进程里，成为这个进程的一部分。因此，dylib的权限是由它寄生的那个App决定的，同一个dylib寄生在系统App和StoreApp里时的权限是不同的。</p><p>越狱iOS中，Cydia里的各种tweak无一不是以dylib的形式工作的。</p><h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><p>iOS的daemon主要由一个可执行文件和一个plist文件构成。iOS的根进程是launchd，其会在开机时检查<code>/System/Library/LaunchDaemons</code>和<code>/Library/LaunchDaemons</code>下所有格式符合规定的plist文件，然后启动对应的daemon。这里的plist文件与App中的<code>Info.plist</code>文件作用类似，即记录Daemon的基本信息。</p><p>(完)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《iOS应用逆向工程（第2版）》</li><li><a href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html" target="_blank" rel="noopener">File System Programming Guide</a></li><li><a href="http://www.cnblogs.com/wujy/archive/2016/02/13/5188302.html" target="_blank" rel="noopener">iOS底层基础知识-文件目录结构</a></li><li><a href="https://www.jianshu.com/p/9cc4f0975d1d" target="_blank" rel="noopener">iOS APP沙盒目录</a></li><li><a href="https://bbs.feng.com/read-htm-tid-249.html" target="_blank" rel="noopener">Mac OS X 术语表</a></li><li><a href="http://www.cocoachina.com/mac/20150122/10988.html" target="_blank" rel="noopener">了解iOS上的可执行文件和Mach-O格式</a></li><li><a href="http://oncenote.com/2015/06/01/How-App-Launch/" target="_blank" rel="noopener">由App的启动说起</a></li><li><a href="https://objccn.io/issue-6-3/" target="_blank" rel="noopener">Mach-O 可执行文件</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS文件系统&quot;&gt;&lt;a href=&quot;#iOS文件系统&quot; class=&quot;headerlink&quot; title=&quot;iOS文件系统&quot;&gt;&lt;/a&gt;iOS文件系统&lt;/h1&gt;&lt;p&gt;iOS由OSX演化而来，而OSX又是基于UNIX的，它们都是类UNIX操作系统。类UNIX操作系统有
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="逆向工程" scheme="http://chuquan.me/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="沙盒原理" scheme="http://chuquan.me/tags/%E6%B2%99%E7%9B%92%E5%8E%9F%E7%90%86/"/>
    
      <category term="文件系统" scheme="http://chuquan.me/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>现代浏览器工作原理（一）</title>
    <link href="http://chuquan.me/2018/01/21/browser-architecture-overview/"/>
    <id>http://chuquan.me/2018/01/21/browser-architecture-overview/</id>
    <published>2018-01-20T16:01:06.000Z</published>
    <updated>2018-02-09T03:47:13.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>这些天在考虑选择什么主题在即将来临的公司技术分享会上进行分享。思来想去，也没找到什么比较好的主题。逆向？已经有人分享过了…框架？不是针对特定需求的框架，介绍起来感觉也没有太大的意义…</p><p>恍惚间，想起之前@展哥在调高考真题Hybrid页面时，似乎在前端代码方面遇到一些麻烦。于是，我就想到了UIWebView。就此进行思维发散，感觉可以介绍一下浏览器的工作原理。毕竟，iOS和前端同属于大客户端。对于iOS的同学，也算是对知识面的扩展吧。</p><p>于是，我查阅了一些与浏览器原理相关的资料。在这个过程中，找到很多优秀的资料。但是，大多数资料的组织结构，不是特别清晰。因此，我想借此机会，结合参考资料，来重新梳理一下浏览器的原理。由于浏览器的结构非常复杂，一篇文章想介绍清楚，真的太难。本文将使用总-分-总的形式，使用一系列文章来进行介绍。如有纰漏，欢迎纠正。</p><h1 id="浏览器历史"><a href="#浏览器历史" class="headerlink" title="浏览器历史"></a>浏览器历史</h1><p>1990年，<a href="https://zh.wikipedia.org/wiki/%E8%92%82%E5%A7%86%C2%B7%E4%BC%AF%E7%BA%B3%E6%96%AF-%E6%9D%8E" target="_blank" rel="noopener">蒂姆·伯纳斯·李</a>开发了第一个网页浏览器<a href="https://zh.wikipedia.org/wiki/WorldWideWeb" target="_blank" rel="noopener">WorldWideWeb</a>，后改名为<strong>Nexus</strong>。WorldWideWeb浏览器支持早期的HTML标记语言，功能比较简单，只能支持文本、简单的样式表、电影、声音、图片等资源的显示。</p><p>1993年，<a href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%85%8B%C2%B7%E5%AE%89%E5%BE%B7%E6%A3%AE" target="_blank" rel="noopener">马克·安德森</a>领导的团开发了一个真正有影响力的浏览器<a href="https://zh.wikipedia.org/wiki/Mosaic" target="_blank" rel="noopener">Mosaic</a>，这就是后来世界上最流行的浏览器<a href="https://zh.wikipedia.org/wiki/Netscape_Navigator" target="_blank" rel="noopener">Netscape Navigator</a>。</p><p>1995年，微软推出了闻名于世的浏览器<a href="https://zh.wikipedia.org/wiki/Internet_Explorer" target="_blank" rel="noopener">Internet Explorer</a>。</p><p>1998年，Netscape公司开放Netscape Navigator源代码，成立了Mozilla基金会。</p><p>2003年，苹果公司发布了Safari浏览器。</p><p>2004年，Netscape公司发布了著名的开源浏览器<a href="https://zh.wikipedia.org/wiki/Firefox" target="_blank" rel="noopener">Mozilla Firefox</a></p><p>2005年，苹果公司开源了浏览器中的核心代码，基于此发起了一个新的开源项目WebKit（Safari浏览器的内核）。</p><p>2008年， Google公司已WebKit为内核，创建了一个新的浏览器项目<a href="https://zh.wikipedia.org/zh-hant/Chromium" target="_blank" rel="noopener">Chromium</a>。以Chromium为基础，谷歌发布了<a href="https://zh.wikipedia.org/wiki/Google_Chrome" target="_blank" rel="noopener">Chrome</a>浏览器。至于这两者的关系，可以简单地理解为：Chromium为实验版，具有众多新特性；Chrome为稳定版。</p><h1 id="浏览器特性"><a href="#浏览器特性" class="headerlink" title="浏览器特性"></a>浏览器特性</h1><p>现代浏览器的特性主要包含如下几部分：</p><ul><li><strong>网络</strong><br>  浏览器通过网络模块下载各种资源，如：HTML文档、JavaScript代码、样式表、图片、音频视频文件等。 网络模块是浏览器最重要的模块之一。</li><li><strong>资源管理</strong><br>  浏览器通过高效的管理机制来管理网络资源和本地资源。比如如何避免重复下载资源、缓存资源等。</li><li><strong>网页浏览</strong><br>  浏览器最核心的功能。浏览器通过网络下载资源，并从资源管理器获得资源，然后将其转化为可视化结果。</li><li><strong>多页面管理</strong><br>  浏览器支持多页面浏览，因此支持多页面同时加载。浏览器需要多页面管理机制来解决例如多页面的相互影响和安全等问题。</li><li><strong>插件和扩展</strong><br>  现代浏览器的重要特征。插件可以用来显示网页特定内容；扩展则是增加浏览器新功能的软件或压缩包。</li><li><strong>账户和同步</strong><br>  现代软件的普遍特性。浏览器将用户的浏览信息，例如历史记录、书签等信息同步到服务器，提供多系统下的统一体验。</li><li><strong>安全机制</strong><br>  现代软件的重要特性。浏览器的安全机制需要提供一个安全的浏览环境，例如：避免用户信息被窃取或破坏、防止浏览器被恶意代码攻破等。</li><li><strong>开发者工具</strong><br>  开发者工具是浏览器提供给网页开发者的工具，可以帮助审查HTML元素、调试JavaScript代码、改善网页性能等。</li></ul><h1 id="浏览器结构"><a href="#浏览器结构" class="headerlink" title="浏览器结构"></a>浏览器结构</h1><p>目前，常用的浏览器主要有：Chrome、IE（Edge）、Safari、Firefox等。不同的浏览器在结构方面虽然有所差异，但是整体的设计理念是相似的。因此，可以抽象得到如下图所示的参考结构：</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/browser-architecture001.png" alt=""></div><p>浏览器的抽象分层结构图中将浏览器分成了以下8个子系统：</p><ul><li><strong>用户界面（User Interface）</strong><br>  用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。<br>  用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。</li><li><strong>浏览器引擎（Browser Engine）</strong><br>  浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。<br>  浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。<br>  浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。<br>  浏览器引擎还允许查询/修改渲染引擎设置。</li><li><strong>渲染引擎（Rendering Engine）</strong><br>  渲染引擎为指定的URI生成可视化的表示。<br>  渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。<br>  渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。<br>  渲染引擎内部包含HTML解析器。</li><li><strong>网络（Networking）</strong><br>  网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。</li><li><strong>JavaScript解释器（JavaScript Interpreter）</strong><br>  JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。  为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。</li><li><strong>XML解析器（XML Parser）</strong><br>  XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。</li><li><strong>显示后端（Display Backend）</strong><br>  显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。</li><li><strong>数据持久层（Data Persistence）</strong><br>  数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。</li></ul><p>这里可能会产生一个疑问：功能相似的HTML解析器和XML解析器为什么前者划分在渲染引擎中，后者作为独立的系统？<br>原因：XML解析器对于系统来说，其功能并不是关键性的，但是从复用角度来说，XML解析器是一个通用的，可重用的组件，具有标准的，定义明确的接口。相比之下，HTML解析器通常与渲染引擎紧耦合。</p><h1 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h1><p>浏览器的组成模块众多，而渲染引擎则是浏览器中最重要的模块（渲染引擎有时候也被称为“浏览器内核”，这种说法并不严谨，不推荐使用）。目前，常见的渲染引擎有Trident、Gecko、WebKit等。下表所示为几种渲染引擎在不同浏览器中的应用：</p><table><thead><tr><th style="text-align:left">渲染引擎</th><th style="text-align:left">浏览器</th></tr></thead><tbody><tr><td style="text-align:left">Trident</td><td style="text-align:left">IE、Edge</td></tr><tr><td style="text-align:left">Gecko</td><td style="text-align:left">Firefox</td></tr><tr><td style="text-align:left">WebKit</td><td style="text-align:left">Safari、Chromium/Chrome</td></tr></tbody></table><h2 id="渲染引擎工作流程"><a href="#渲染引擎工作流程" class="headerlink" title="渲染引擎工作流程"></a>渲染引擎工作流程</h2><p>如下图所示为渲染引擎的渲染流程示意图，其以HTML/JavaScript/CSS等文件作为输入，以可视化内容作为输出。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/browser-architecture002.png" alt=""></div><ol><li><p><strong>Parsing HTML to Construct DOM Tree</strong><br>渲染引擎使用HTML解析器（调用XML解析器）解析HTML（XML）文档，将各个HTML（XML）元素逐个转化成DOM节点，从而生成DOM树。<br>同时，渲染引擎使用CSS解析器解析外部CSS文件以及HTML（XML）元素中的样式规则。元素中带有视觉指令的样式规则将用于下一步，以创建另一个树结构：渲染树。  </p></li><li><p><strong>Render Tree construction</strong><br>渲染引擎使用第1步CSS解析器解析得到的样式规则，将其附着到DOM树上，从而构成渲染树。<br>渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p></li><li><p><strong>Layout of Render Tree</strong><br>渲染树构建完毕之后，进入本阶段进行“布局”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。</p></li><li><p><strong>Painting Render Tree</strong><br>渲染引擎将遍历渲染树，并调用显示后端将每个节点绘制出来。</p></li></ol><h2 id="渲染引擎组成模块"><a href="#渲染引擎组成模块" class="headerlink" title="渲染引擎组成模块"></a>渲染引擎组成模块</h2><p>下图所示为渲染引擎工作流程中各个步骤所对应的模块，其中第1步和第2步涉及到多个模块，并且耦合程度较高。这样的设计会为了达到更好的用户体验，渲染引擎尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后，就可以开始渲染树构建和布局设置。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/browser-architecture003.png" alt=""></div><p>从图中可以看出，渲染引擎主要包含（或调用）的模块有：</p><ul><li><strong>HTML（XML）解析器</strong><br>  解析HTML（XML）文档，主要作用是将HTML（XML）文档转换成DOM树。</li><li><strong>CSS解析器</strong><br>  将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建。</li><li><strong>JavaScript解释器</strong><br>  使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果。</li><li><strong>布局</strong><br>  DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。</li><li><strong>绘图</strong><br>  使用图形库将布局计算后的渲染树绘制成可视化的图像结果。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了浏览器的主要特性以及抽象结构，并选择其中最为核心的渲染引擎进行了介绍。渲染引擎是浏览器中最为复杂的部件，后续将对渲染引擎中的各个模块依次进行介绍。</p><p>（完）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">Web Browser-Wikipedia</a></li><li>Adam Barth, Collin Jackson, Charles Reis, Google Chrome Team. The Security Architecture of the Chromium Browser.</li><li>Andre Campos, Bryan Lane, Neal Clark, Sunpreet Jassal, Stephen Hitchner. Conceptual Architecture of Firefox.</li><li>Alan Grosskurth and Michael Godfrey. A case study in architectural analysis: The evolution of the modern web browser.</li><li><a href="http://web.jobbole.com/84826/" target="_blank" rel="noopener">主流浏览器内核介绍（前端开发值得了解的浏览器内核历史）</a></li><li>朱永盛. 《WebKit技术内幕》.</li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li>Alan Grosskurth, Michael W.Godfrey. A Reference Architecture for Web Browsers.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;p&gt;这些天在考虑选择什么主题在即将来临的公司技术分享会上进行分享。思来想去，也没找到什么比较好的主题。逆向？已经有人分享过了…框架？不是针对特定需求的框
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="浏览器原理" scheme="http://chuquan.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    
      <category term="渲染引擎" scheme="http://chuquan.me/tags/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>2017年总结</title>
    <link href="http://chuquan.me/2018/01/02/2017-summary/"/>
    <id>http://chuquan.me/2018/01/02/2017-summary/</id>
    <published>2018-01-01T16:21:20.000Z</published>
    <updated>2018-02-08T07:21:18.552Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/maimai-2017-summary.png?x-oss-process=image/resize,w_400" alt=""></div><a id="more"></a><p>这几天，脉脉上有一个年度总结的活动。2017年，我对自己的总结便是一个字——<strong>变</strong>。</p><h1 id="关于论文毕设"><a href="#关于论文毕设" class="headerlink" title="关于论文毕设"></a>关于论文毕设</h1><p>2017的上半年是我硕士生涯，也是我学生生涯的最后一个学期。这半年真的是一直处于焦虑中，毕业总是令人如鲠在喉。有人可能会问硕士毕业有这么难吗？如果我说我们是在毕业答辩前两个月才开的题你信吗？</p><p>关于毕业论文，我是经历过换题的。研二期间，一直在做碳纳米管计算机项目。然而，到了毕业选题的时候，才发现这个项目根本没有可深入研究的、与计算机体系结构相关的东西。不得已，只能换题。此时，恰逢2016年的10月，校招还在如火如荼地进行。而我已经没有心情继续找工作了。</p><p>2017年年初，@易老师给了我一个毕业选题的大方向——RISC-V &amp; TLB &amp; 安全。参考往年类似的毕业选题（如：@天一师兄、@翁东旭师兄的毕业论文），我大致规划出了毕业论文的框架。然而，往年论文的相关实验都是基于完整的项目平台，研究及评测环境相对来说都是比较完备的。我的毕业选题采用的实验平台则是基于RISC-V的开源处理器生成器——Rocket Chip Generator，该平台是2014年由UCB推出的，其研究及评测环境都还不完善，不足以提供标准且完整的论述、验证、评估的能力。</p><p>为了让论文能有更多的干货，我还去探索了TLB/MMU在安全方面研究的可能性。不过，这个想法在后来的预开题中被否决了。好在，预开题时，@佟老师给了我很多的建设性的意见，比如：研究Generator自动化生成硬件的原理、Chisel原理等。我能够在6月份顺利毕业，真的要感谢我的导师@佟老师、@易老师，在毕设期间予以我的帮助和建议。</p><h1 id="关于科研项目"><a href="#关于科研项目" class="headerlink" title="关于科研项目"></a>关于科研项目</h1><p>2月底春季的开学阶段，我提前了一周回了学校。因为，在做毕业的同时，我还要和物理电子所的同学对接碳纳米管项目。为了能让项目顺利结题，春节前后和@海涛师兄、@司佳师姐、@东维师弟一起忙活了一段时间。项目最后顺利结题，也算是了却了一桩心事。在4月份左右，@彭老师、@程老大又来了一次巨头会议，要在北大120周年献礼。也就是说，碳纳米管项目继续进行。当然，我知道自己不能继续跟进，便把工作交接了@李宁师妹和@东维师弟了。希望明年的五四，能给大家带来一个惊喜。</p><h1 id="关于毕业答辩"><a href="#关于毕业答辩" class="headerlink" title="关于毕业答辩"></a>关于毕业答辩</h1><p>3月底，实验室进行了开题答辩会。这个开题时间放眼整个北大，也算是晚的了。不知道@老大作何感想，可能真的是日理万机吧。不过，从开题答辩会上老大的表述，能看出@老大对于我们这一届还是抱有歉意，希望我们都能顺利毕业。</p><p>6月2日，毕业答辩会如期进行。答辩会上有校外专家，当我们有遇到答不上的问题或被专家刁难的时候，@老大能够及时救场，果然护犊子！手动点赞！结果是显而易见的，所有人都顺利毕业。</p><p>答辩过后，和@小威威、@大帅、@赵璐、@昊泽去了南门翅客吃了烧烤，果然是前所未有的轻松。</p><h1 id="关于毕业旅行"><a href="#关于毕业旅行" class="headerlink" title="关于毕业旅行"></a>关于毕业旅行</h1><p>6月3日是我们的发出时间，一个月前订机票时也是非常忐忑，毕竟答辩时间是6月2日，就怕答辩时间更改。关于毕业旅行的详细内容，可以看<a href="http://chuquan.me/2017/06/16/tailand/">这里</a>。</p><h1 id="关于毕业典礼"><a href="#关于毕业典礼" class="headerlink" title="关于毕业典礼"></a>关于毕业典礼</h1><p>毕业旅行回来，能感受到浓厚的离别气息。拍毕业照、毕业典礼、谢师宴…从今往后，同窗同门都要各奔东西。</p><h1 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h1><p>校招时，我投递的岗位是前端开发工程师，后来HR跟我沟通有没有转岗iOS开发工程师的意愿。在考虑了几天后，我选择了转岗。我当时的想法是这样的：</p><ul><li>前端的门槛比较低，从业人员比较很多，想真正脱颖而出还是比较困难的，感觉硕士毕业从事前端的优势并不大。</li><li>前端的技术更新迭代速度太快，没有一个统一的行业标准，不同的公司可能采用完全不同的技术栈。所以，前端岗需要不断地学习，一旦松懈，可能就会被淘汰，压力比较大。</li><li>程序员都知道所谓的“程序员鄙视链”，前端是处于“鄙视链”的下游的。虽然前端已经今非昔比了，但是总的来说，职业天花板比较低。</li></ul><p>出于这些考虑，我选择了转岗。</p><p>7月初，办完了毕业手续，我和@撸神便搬家到了我们的整租房。在学校呆了20年，离开时真的很不习惯。</p><p>7月10日，在紧张和期待中办理了入职手续。期间，遇到了校友@家骏、@仲雪。中午，我的mentor@展哥接待了我，然后便组织大家在云海肴来了一波TB。</p><p>@展哥已经有7年的工作经验了，作为小猿搜题iOS端负责人，他的技术能力的确是很强的。作为mentor，他也是尽心尽力，真的非常nice。相比于我在某度的mentor，真是不知道高到哪里去了，无论是技术能力，还是个人修养。然而，没想到@展哥年后要离职，真的有点不舍啊。</p><p>我工位的右边是@展哥，左边是@琳洁——一位iOS程序媛。她虽然话不多，但是只要有问题，她都能悉心指导我。而且做事特别细致，从code review就能看出来。</p><p>我的leader@邱瑞，也是我的校友师兄。为人非常nice，说话语气很平和，平时分配任务、交谈时完全没有一种上下级的感觉。对于产品需求的评估、事务的处理都是非常到位。</p><p>有人说：想要在职场上快速成长，可以尝试学习你领导的做事方式。我个人非常赞同这种观点，希望新的一年，我能够像@展哥、@邱瑞、@琳洁他们一样做人做事。</p><h1 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h1><p>上半年写的代码基本都是服务于毕业设计，都是与硬件相关。下半年学的都是工程相关：</p><ul><li>在编程语言方面，学习了两门新的语言：Objective-C、Swift。</li><li>在版本管理方面，能够熟练使用git的各种常用命令。</li><li>在项目管理方面，了解了公司的项目管理流程以及敏捷开发模式，自己还搭建了Gerrit代码审核服务器。</li></ul><h1 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h1><p>2017年1月1日，我计划开始记录自己的阅读轨迹，其实主要原因是希望能够督促自己保持阅读（阅读轨迹<a href="http://chuquan.me/2017/01/05/read-books/">在这里</a>）。2017年总共阅读了不到10本书。希望新的一年，在阅读时能够有更多的自我思考，尽可能产出一些读书笔记。虽然，我读书的时候喜欢使用有道云来做笔记，但是缺少整理、总结和发布。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>对于公司来说，都会有年度目标，这样公司才能够健康成长。对于个人也是一样，给自己定一个目标，希望能够激励自己成长。2018年伊始，我也想给自己定一些小目标。</p><ul><li>至少看完两个iOS开源框架源代码（向大神靠拢）</li><li>至少看12本书，非工具类的书，需要有读书笔记（向@巧叔学习）</li><li>在技术方面，能够hold住产品经理提出来的所有需求（向@琳洁@展哥学习</li><li>在业务方面，了解小猿搜题的所有业务代码（向@邱瑞@琳洁@展哥学习）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/maimai-2017-summary.png?x-oss-process=image/resize,w_400&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="http://chuquan.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>SSH 协议实践</title>
    <link href="http://chuquan.me/2017/12/27/ssh-protocol-practice/"/>
    <id>http://chuquan.me/2017/12/27/ssh-protocol-practice/</id>
    <published>2017-12-26T17:09:02.000Z</published>
    <updated>2018-02-09T03:30:34.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH概述"><a href="#SSH概述" class="headerlink" title="SSH概述"></a>SSH概述</h1><p>类似于HTTP，SSH（Secure Shell）是一种加密的网络传输协议，常用于加密远程登录。</p><p>1995年，芬兰赫尔辛基理工大学的塔图·于勒宁因为发现自己学校存在嗅探密码的网络攻击，设计了一套保护信息传输的程序，即Secure Shell（简称SSH），其目标是取代先前的<code>rlogin</code>、<code>Telnet</code>、<code>FTP</code>、<code>rsh</code>等安全性不足的协议。如今，最为广泛使用的<code>OpenSSH</code>便是SSH协议的一种免费开源实现。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>SSH使用非对称加密算法实现身份验证，即采用<strong>公钥-私钥对</strong>来进行加密网络连接。私钥由用户（本地主机）自行保管，公钥由远程主机（如：服务器）保管。</p><h1 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h1><p>下面使用<code>OpenSSH</code>进行具体实践。</p><h2 id="SSH协议语法格式"><a href="#SSH协议语法格式" class="headerlink" title="SSH协议语法格式"></a>SSH协议语法格式</h2><p>SSH主要用于远程登录，如下所示为SSH协议的语法格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [&lt;username&gt;@]&lt;server&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure></p><h2 id="关于SSH公钥认证"><a href="#关于SSH公钥认证" class="headerlink" title="关于SSH公钥认证"></a>关于SSH公钥认证</h2><p>为实现公钥认证，作为认证的客户端一方需要拥有两个文件，即<strong>公钥-私钥对</strong>。一般公钥-私钥对文件创建在用户的主目录下的<code>.ssh</code>目录中。如果用户主目录下不存在<code>.ssh</code>目录，说明SSH公钥-私钥对尚未创建。</p><h3 id="创建公钥-私钥对"><a href="#创建公钥-私钥对" class="headerlink" title="创建公钥-私钥对"></a>创建公钥-私钥对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure><p>该命令会在用户主目录下创建<code>.ssh</code>目录，并在其中创建两个文件：</p><ul><li><code>id_rsa</code>：私钥文件。是基于RSA算法创建的。</li><li><code>id_rsa.pub</code>：公钥文件。</li></ul><h3 id="分发公钥"><a href="#分发公钥" class="headerlink" title="分发公钥"></a>分发公钥</h3><p>创建了公钥-私钥对后，需要将公钥交给远程主机保管，这样才能在之后的登录实现无口令登录。如下命令，会将<code>.ssh</code>目录下指定的公钥文件拷贝至远程服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id -i .ssh/id_rsa.pub &lt;user&gt;@&lt;server&gt;</span><br></pre></td></tr></table></figure></p><ul><li>该命令会提示输入用户user在server上的SSH登录口令  </li><li>此命令执行成功后，再以user用户用ssh命令登录server远程主机时，不必输入口令可直接登录</li><li>该命令实际上是<code>.ssh/id_rsa.pub</code>公钥文件拷贝到远程主机server的user主目录下的<code>.ssh/authorized_keys</code>文件中，内容类似如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHJu4oVxIbLS2LBH5wI7htvDxuIMZ5IFUaZjbWI8z...M4yGEWcr7OVPdQa4DIEbrrl8MzsAZ baochuquan@baochuquandeMacBoo    k-Pro.local</span><br></pre></td></tr></table></figure></li></ul><h2 id="关于SSH主机别名"><a href="#关于SSH主机别名" class="headerlink" title="关于SSH主机别名"></a>关于SSH主机别名</h2><p>在实际应用中，有时需要使用多套公钥/私钥对。然而，上述创建公钥-私钥对的命令只会生成默认名为<code>id_rsa</code>的密钥对。</p><h3 id="创建公钥-私钥对-1"><a href="#创建公钥-私钥对-1" class="headerlink" title="创建公钥-私钥对"></a>创建公钥-私钥对</h3><p>为了创建不同的公钥/私钥对，在使用<code>ssh-keygen</code>命令时就需要通过<code>-f</code>参数指定不同的私钥名称。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -f ~/.ssh/&lt;filename&gt;</span><br></pre></td></tr></table></figure></p><p>命令会在<code>.ssh/</code>目录下创建指定的公钥/私钥对：文件<code>&lt;filename&gt;</code>是私钥，文件<code>&lt;filename&gt;.pub</code>是公钥。</p><h3 id="分发公钥-1"><a href="#分发公钥-1" class="headerlink" title="分发公钥"></a>分发公钥</h3><p>将新生成的公钥添加到远程主机登录用户主目录下的<code>.ssh/authorized_keys</code>文件中，就可以使用新创建的公钥建立到远程主机<server>的<user>账户的无口令登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id -i .ssh/&lt;filename&gt;.pub &lt;user&gt;@&lt;server&gt;</span><br></pre></td></tr></table></figure></user></server></p><p>在有多个公钥/私钥对时，默认使用<code>~/.ssh/id_rsa.pub</code>。那么如何使用新建的公钥连接server呢？</p><h3 id="管理本地私钥"><a href="#管理本地私钥" class="headerlink" title="管理本地私钥"></a>管理本地私钥</h3><p>SSH的客户端配置文件<code>~/.ssh/config</code>可以通过创建主机别名，连接主机时选择用指定的私钥。例如<code>/.ssh/config</code>文件中的下列配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用默认的id_rsa私钥</span></span><br><span class="line">Host gerrit.zhenguanyu.com</span><br><span class="line">    Hostname gerrit.zhenguanyu.com</span><br><span class="line">    Port 29418</span><br><span class="line">    User baocq</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用指定的chuquan01私钥</span></span><br><span class="line">Host chuquan</span><br><span class="line">  user root</span><br><span class="line">  hostname 115.28.167.128</span><br><span class="line">  port 22</span><br><span class="line">  identityfile ~/.ssh/chuquan01</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 使用指定的gerrit01私钥</span></span><br><span class="line">Host gerrit</span><br><span class="line">  user gerrit</span><br><span class="line">  hostname 115.28.167.128</span><br><span class="line">  port 22</span><br><span class="line">  identityfile ~/.ssh/gerrit01</span><br></pre></td></tr></table></figure></p><h3 id="无口令远程登录"><a href="#无口令远程登录" class="headerlink" title="无口令远程登录"></a>无口令远程登录</h3><p>执行下面的SSH登录命令，即可登录Host为<code>chuquan</code>的主机：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh chuquan</span><br></pre></td></tr></table></figure></p><p>（完）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">Secure Shell</a>  </li><li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">SSH原理与运用（一）：远程登录</a>  </li><li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="noopener">SSH原理与运用（二）：远程操作与端口转发</a>  </li><li>《Git权威指南》，蒋鑫</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSH概述&quot;&gt;&lt;a href=&quot;#SSH概述&quot; class=&quot;headerlink&quot; title=&quot;SSH概述&quot;&gt;&lt;/a&gt;SSH概述&lt;/h1&gt;&lt;p&gt;类似于HTTP，SSH（Secure Shell）是一种加密的网络传输协议，常用于加密远程登录。&lt;/p&gt;
&lt;p&gt;19
      
    
    </summary>
    
      <category term="软件" scheme="http://chuquan.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="SSH" scheme="http://chuquan.me/tags/SSH/"/>
    
      <category term="公钥/私钥" scheme="http://chuquan.me/tags/%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu + Gerrit + Apache 搭建代码审核服务器</title>
    <link href="http://chuquan.me/2017/12/12/ubuntu-gerrit-apache/"/>
    <id>http://chuquan.me/2017/12/12/ubuntu-gerrit-apache/</id>
    <published>2017-12-12T15:23:33.000Z</published>
    <updated>2018-02-09T03:31:00.917Z</updated>
    
    <content type="html"><![CDATA[<p>我们公司采用Gerrit作为代码审核服务器并结合JIRA、Jenkins等开源工具，组成了一个完整项目管理平台。某天，我兴致来了，也想在自己的服务器上搭建一个Gerrit。于是，便有了以下内容…</p><h1 id="一、Gerrit介绍"><a href="#一、Gerrit介绍" class="headerlink" title="一、Gerrit介绍"></a>一、Gerrit介绍</h1><p>Gerrit的目的是提供一个轻量级的框架来review每一个commit，review通过之后，commit会被合入代码库。</p><p>Gerrit是一个中间区域，可以看到提交至Gerrit上的代码相对于服务器代码仓库中代码的差异，从而便于检查代码的改动。Gerrit也是整个代码review的推动者。</p><p>任何拥有多个成员的团队都应该有一个中央代码仓库。 Git在理论上可以在没有这样的中心位置的情况下工作，但实际上通常有一个中央仓库库作为项目实际内容的权威副本。 开发者从该中央仓库fetch和push</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/central-source-repository.png?x-oss-process=image/resize,w_570" alt=""></div><p>Gerrit被部署在上图的中央仓库的位置，并增加一个新的概念：<strong>a store of pending changes（未决的修改）</strong>。每个人仍然可以从中央仓库fetch，但是push操作则有所变化，push操作会直接push到中央仓库，而是push到了<strong>pending changes location</strong>，以供review。只有在commit通过了review之后，才会被submit到中央仓库。如下图所示。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gerrit-in-place-of-central-repository.png?x-oss-process=image/resize,w_570" alt=""></div><p>Gerrit具有强大的访问控制模型。用户可以被授予访问权限，绕过review，直接推送到中央仓库。Gerrit甚至可以在没有代码review的情况下使用，只用于托管仓库和访问控制。</p><h1 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h1><p>在安装gerrit之前，我使用<code>node</code>在服务器上部署了一个站点，也就是本博客，其占用了<code>80</code>端口。</p><p>在安装gerrit之后，我的服务器又将多出一个站点，用户该如何访问？我又该如何部署呢？这时候，我们就需要了解一下<code>反向代理</code>和<code>端口转发</code>了。</p><h2 id="1-正向代理与反向代理"><a href="#1-正向代理与反向代理" class="headerlink" title="1. 正向代理与反向代理"></a>1. 正向代理与反向代理</h2><p>如下所示为正向代理和反向代理的示意图。一般来说，我们会把正向代理是与客户端划为一体，把反向代理和服务器划为一体。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/proxy-both.png" alt=""></div><p>此时，重新思考一下我们的应用场景：博客是一个web服务器，gerrit是一个web服务器，apache作为反向代理，这样就可以满足我们的需求了。</p><p>那么反向代理到底是如何做到的呢？答案就是<code>端口转发</code>。</p><p>我们知道在浏览器输入网址后，它会在解析后的IP地址之后加上一个默认的端口号<code>80</code>。所以，我们访问<code>chuquan.me</code>时就不需要输入完整的地址<code>chuquan.me:80</code>了。正因为如此，绝大多数服务器软件（包括apache）的默认监听端口也是<code>80</code>。</p><p>在安装了apache之后，<code>80</code>端口被apache占用了。因此，gerrit和博客都不能使用<code>80</code>端口了。这时候，我们需要给这两个站点配置使用其他的端口号，如：gerrit的HTTP协议使用<code>8081</code>端口，博客使用<code>8082</code>端口。它们与apache之间使用<code>端口转发</code>来实现<code>反向代理</code>。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/apache-gerrit-blog.png" alt=""></div><h1 id="三、开发环境"><a href="#三、开发环境" class="headerlink" title="三、开发环境"></a>三、开发环境</h1><ul><li>Ubuntu 14.04.5 LTS</li><li>Java 1.8.0_151</li><li>Git 1.9.1</li><li>Apache/2.4.7 </li></ul><h1 id="四、安装Gerrit"><a href="#四、安装Gerrit" class="headerlink" title="四、安装Gerrit"></a>四、安装Gerrit</h1><h2 id="1-新建专用用户"><a href="#1-新建专用用户" class="headerlink" title="1. 新建专用用户"></a>1. 新建专用用户</h2><p>新建一个用户来专门管理Gerrit相关内容。在root用户下新建一个gerrit用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adduser gerrit</span><br><span class="line">$ su gerrit</span><br></pre></td></tr></table></figure></p><h2 id="2-下载Gerrit安装包"><a href="#2-下载Gerrit安装包" class="headerlink" title="2. 下载Gerrit安装包"></a>2. 下载Gerrit安装包</h2><p>Gerrit下载地址：<a href="https://www.gerritcodereview.com/releases/2.14.md" target="_blank" rel="noopener">https://www.gerritcodereview.com/releases/2.14.md</a></p><p>我安装的Gerrit版本是2.14.6。在Linux环境下使用<code>wget</code>进行下载，最终得到一个<code>war</code>包，位于<code>/home/gerrit/</code>目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://gerrit-releases.storage.googleapis.com/gerrit-2.14.6.war</span><br></pre></td></tr></table></figure></p><h2 id="3-安装Gerrit"><a href="#3-安装Gerrit" class="headerlink" title="3. 安装Gerrit"></a>3. 安装Gerrit</h2><p>在<code>/home/gerrit/</code>目录下，进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar gerrit-2.14.6.war init -d review_site</span><br></pre></td></tr></table></figure></p><p>上述命令会在当前目录下创建一个<code>review_site</code>目录。接下来就开始进行对话式安装，我们可以直接回车，表示采用默认安装选项。之后还可以通过配置文件进行详细配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">*** Gerrit Code Review 2.14.6</span><br><span class="line">***</span><br><span class="line">*** Git Repositories  </span><br><span class="line">***  </span><br><span class="line">Location of Git repositories   [git]:   </span><br><span class="line">*** SQL Database  </span><br><span class="line">***  </span><br><span class="line">Database server type           [h2]:   </span><br><span class="line">*** User Authentication  </span><br><span class="line">***  </span><br><span class="line">Authentication method          [OPENID/?]: http  </span><br><span class="line">Get username from custom HTTP header [y/N]?  </span><br><span class="line">SSO logout URL                 :  </span><br><span class="line">*** Email Delivery  </span><br><span class="line">***  </span><br><span class="line">SMTP server hostname           [localhost]:  </span><br><span class="line">SMTP server port               [(default)]:  </span><br><span class="line">SMTP encryption                [NONE/?]:  </span><br><span class="line">SMTP username                  :  </span><br><span class="line">*** Container Process  </span><br><span class="line">***  </span><br><span class="line">Run as                         [gerrit]:  </span><br><span class="line">Java runtime                   [/usr/lib/jvm/java-7-openjdk-amd64/jre]:  </span><br><span class="line">Copy gerrit-2.13.4.war to /home/gerrit/review/bin/gerrit.war [Y/n]?  </span><br><span class="line">Copying gerrit-2.13.4.war to /home/gerrit/review/bin/gerrit.war  </span><br><span class="line">*** SSH Daemon  </span><br><span class="line">***  </span><br><span class="line">Listen on address              [*]:  </span><br><span class="line">Listen on port                 [29418]:  </span><br><span class="line">*** HTTP Daemon  </span><br><span class="line">***  </span><br><span class="line">Behind reverse proxy           [y/N]?   </span><br><span class="line">Proxy uses SSL (https://)      [y/N]?  </span><br><span class="line">Subdirectory on proxy server   [/]:  </span><br><span class="line">Listen on address              [*]:  </span><br><span class="line">Listen on port                 [8080]:</span><br><span class="line">*** Plugins  </span><br><span class="line">***  </span><br><span class="line">Installing plugins.  </span><br><span class="line">Install plugin download-commands version v2.11 [y/N]?  </span><br><span class="line">Install plugin reviewnotes version v2.11 [y/N]?  </span><br><span class="line">Install plugin singleusergroup version v2.11 [y/N]?  </span><br><span class="line">Install plugin replication version v2.11 [y/N]?  </span><br><span class="line">Install plugin commit-message-length-validator version v2.11 [y/N]?  </span><br><span class="line">Initializing plugins.  </span><br><span class="line">No plugins found with init steps.  </span><br><span class="line">Initialized /home/gerrit/review_site</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>安装完毕，Gerrit会自动启动，不过我们大概率会启动失败，因为默认的配置并不一定与你当前的环境相匹配。不过，没关系，我们可以根据系统环境对gerrit进行配置。</p><h2 id="4-Gerrit配置"><a href="#4-Gerrit配置" class="headerlink" title="4. Gerrit配置"></a>4. Gerrit配置</h2><p>Gerrit安装完成后，会在<code>review_site</code>目录下生成多个目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ll review_site</span><br><span class="line">./</span><br><span class="line">../</span><br><span class="line">bin/</span><br><span class="line">cache/</span><br><span class="line">data/</span><br><span class="line">db/</span><br><span class="line">etc/</span><br><span class="line">git/</span><br><span class="line">index/</span><br><span class="line">lib/</span><br><span class="line">logs/</span><br><span class="line">plugins/</span><br><span class="line">static/</span><br><span class="line">tmp/</span><br></pre></td></tr></table></figure></p><p>其中<code>etc/</code>目录下存放着gerrit的配置文件<code>gerrit.config</code>，其中已有的内容是根据安装时的选择生成的。我们可以编辑<code>gerrit.config</code>来进行配置更改。其中<code>115.28.168.118</code>是服务器的公网IP地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[gerrit]</span><br><span class="line">        basePath = git</span><br><span class="line">        serverId = 084efaf9-3bf6-401c-a4b1-8778c998bde2</span><br><span class="line">        canonicalWebUrl = http://115.28.168.118 # 指定web访问Gerrit的网址或IP地址</span><br><span class="line">[database]</span><br><span class="line">        type = h2</span><br><span class="line">        database = /home/gerrit/review_site/db/ReviewDB</span><br><span class="line">[index]</span><br><span class="line">        type = LUCENE</span><br><span class="line">[auth]</span><br><span class="line">        type = HTTP # 默认是OPENID，改成HTTP后，才能通过浏览器进行访问</span><br><span class="line">[receive]</span><br><span class="line">        enableSignedPush = true</span><br><span class="line">[sendemail]</span><br><span class="line">        smtpServer = localhost</span><br><span class="line">[container]</span><br><span class="line">        user = gerrit</span><br><span class="line">        javaHome = /usr/lib/jvm/java-8-oracle/jre</span><br><span class="line">[sshd]</span><br><span class="line">        listenAddress = *:29418</span><br><span class="line">[httpd]</span><br><span class="line">        listenUrl = proxy-http://115.28.168.118:8081/ # HTTP代理地址及端口，这里我们配置成8081</span><br><span class="line">[cache]</span><br><span class="line">        directory = cache</span><br></pre></td></tr></table></figure></p><h1 id="四、配置Apache"><a href="#四、配置Apache" class="headerlink" title="四、配置Apache"></a>四、配置Apache</h1><p>不同系统以及不同版本的Apache的配置文件可能会不一样，无外乎两种：<code>httpd.conf</code>、<code>apache2.conf</code>。本环境的配置文件是<code>apache2.conf</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc/apache2/</span><br><span class="line">$ vim apache2.conf</span><br></pre></td></tr></table></figure></p><p>在配置文件的末尾添加apache的端口转发配置。如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># Blog相关配置</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">ServerName www.chuquan.me       # 用于Apache过滤检测的域名</span><br><span class="line">ServerAlias chuquan.me</span><br><span class="line">    ProxyPass / http://115.28.168.118:8082/     # Blog正向代理转发的端口</span><br><span class="line">    ProxyPassReverse / http://localhost:8082/   # Blog反向代理转发的端口</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"># Gerrit相关配置</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerName gerrit.chuquan.me    # 用户Apache过滤检测的域名    </span><br><span class="line">    ProxyRequests Off</span><br><span class="line">    ProxyVia Off</span><br><span class="line">    ProxyPreserveHost On</span><br><span class="line">    &lt;Proxy *&gt;</span><br><span class="line">          Order deny,allow</span><br><span class="line">          Allow from all</span><br><span class="line">    &lt;/Proxy&gt;</span><br><span class="line">    &lt;Location /login/&gt;</span><br><span class="line">        AuthType Basic</span><br><span class="line">        AuthName &quot;Gerrit Code Review&quot;</span><br><span class="line">        Require valid-user</span><br><span class="line">        AuthBasicProvider file</span><br><span class="line">        AuthUserFile /home/gerrit/review_site/etc/passwords</span><br><span class="line">    &lt;/Location&gt;</span><br><span class="line">    AllowEncodedSlashes On</span><br><span class="line">    ProxyPass / http://115.28.168.118:8081/         # Gerrit正向代理转发的端口</span><br><span class="line">    ProxyPassReverse / http://115.28.168.118:8081/  # Gerrit反向代理转发端口，应该与ProxyPass一致</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p><h1 id="五、服务重启"><a href="#五、服务重启" class="headerlink" title="五、服务重启"></a>五、服务重启</h1><p>Apache和Gerrit配置（当然也包括blog的端口）完之后，我们需要重启服务，包括apache、gerrit，其重启命令分别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/gerrit/</span><br><span class="line">$ ./bin/gerrit.sh restart</span><br></pre></td></tr></table></figure><h2 id="1-Gerrit启动失败"><a href="#1-Gerrit启动失败" class="headerlink" title="1. Gerrit启动失败"></a>1. Gerrit启动失败</h2><p>在执行重启Gerrit的命令后，shell很可能会出现如下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Starting Gerrit Code Review: FAILED</span><br></pre></td></tr></table></figure></p><p>我在安装过程中页出现了这个问题，于是，我通过在<code>./bin/gerrit.sh</code>脚本中的首行添加了一个<code>-x</code>选项，以打印脚本执行的相关信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh -x</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>然后再执行该脚本，发现打印信息是一组循环信息。其中，当<code>TIMEOUT</code>的值递减至0时，启动失败。  </p><p>经过调研发现：  </p><blockquote><p>Gerrit启动慢是因为java程序启动慢，导致Gerrit启动非常慢，大概需要10分钟左右，而默认的超时时间（TIMEOUT）是90秒，导致一直提示“Starting Gerrit Code Review: FAILEDStarting Gerrit Code Review: FAILED”。对此有如下两种解决方案。</p></blockquote><p>第一种解决方案是：修改java的<code>java.security</code>文件。首先，根据<code>gerrit.config</code>中配置<code>javaHome = /user/lib/jvm/java-8-oracle/jre</code>，找到并进入该目录，然后再进入<code>lib/security/</code>目录，修改<code>java.security</code>文件。将<code>securerandom.source=file:/dev/random</code>改为<code>securerandom.source=file:/dev/urandom</code>。由此，解决gerrit启动慢的问题。</p><p>第二种解决方案是：在gerrit.conf文件中的<code>[container]</code>字段下增加`startupTimeout = 900。</p><h2 id="2-反向代理异常"><a href="#2-反向代理异常" class="headerlink" title="2. 反向代理异常"></a>2. 反向代理异常</h2><p>当我们配置结束并重启之后，在浏览器中访问很有可能会得到如下的页面：<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/gerrit-configure-error.png" alt=""></p><p>这个页面在安装过程中，出现次数不下于10次。主要是两种情况，一种是Gerrit配置文件和Apache配置文件可能配置有误。另一种情况是配置没有生效，需要多试试重启。</p><h2 id="3-创建第一个Gerrit账户"><a href="#3-创建第一个Gerrit账户" class="headerlink" title="3. 创建第一个Gerrit账户"></a>3. 创建第一个Gerrit账户</h2><p>当所有问题解决完之后，通过浏览器访问Gerrit，将不会出现上面的Error界面，而是会弹出输入对话框，需要你填写账户和密码。</p><p>这时候，我们需要为Gerrit创建一个账户，默认第一个创建的账户是管理员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ touch /home/gerrit/review_site/etc/passwords</span><br><span class="line">$ htpasswd /home/gerrit/review_site/etc/passwords &quot;admin&quot;</span><br><span class="line">New password:</span><br><span class="line">Re-type new password:</span><br><span class="line">Adding password for user root</span><br></pre></td></tr></table></figure></p><p>重启服务后，再用浏览器打开，登录后就出现久违的界面了！</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们公司采用Gerrit作为代码审核服务器并结合JIRA、Jenkins等开源工具，组成了一个完整项目管理平台。某天，我兴致来了，也想在自己的服务器上搭建一个Gerrit。于是，便有了以下内容…&lt;/p&gt;
&lt;h1 id=&quot;一、Gerrit介绍&quot;&gt;&lt;a href=&quot;#一、Ger
      
    
    </summary>
    
      <category term="软件" scheme="http://chuquan.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Gerrit" scheme="http://chuquan.me/tags/Gerrit/"/>
    
  </entry>
  
  <entry>
    <title>Git rebase与merge的区别</title>
    <link href="http://chuquan.me/2017/10/10/git-rebase-merge/"/>
    <id>http://chuquan.me/2017/10/10/git-rebase-merge/</id>
    <published>2017-10-10T06:49:03.000Z</published>
    <updated>2018-02-09T03:27:36.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git场景"><a href="#Git场景" class="headerlink" title="Git场景"></a>Git场景</h1><p>在基于Git版本控制的团队协作开发中，当同伴先于自己将新的提交push到远程分支上时，如果要想将自己新的提交push的远程分支，则需要先执行<code>git pull</code>来获取同伴的提交，如果有冲突则先处理完冲突，然后才能将自己的提交push到远程分支。这种情形是非常常见的。  </p><p>然而执行<code>git pull</code>，在默认情况下，如果远程分支与本地分支的提交线图有分叉（即不是<code>fast-forward</code>，如上述这种情形），git会执行一次merge操作（即相当于执行了<code>git pull --merge</code>），而这会产生一次没有意义的提交记录。久而久之，项目的提交线图会非常混乱，其中会有很多由merge生成的无意义提交。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>为了避免这种情况的出现，在将提交push到远程分支之前，我们一般会执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase</span><br></pre></td></tr></table></figure></p><p>通过上述命令，Git会采用rebase策略来代替默认的merge策略。从而避免生成无意义的提交。</p><h1 id="分析对比"><a href="#分析对比" class="headerlink" title="分析对比"></a>分析对比</h1><p>这时候，我们可能就会想：既然merge操作会生成无意义的提交，那它是不是没有什么价值了呢？是不是任何场景下都应该使用rebase操作？  </p><p>所以，我们对rebase和merge进行分析和对比。了解清楚了两者的区别，我们才能更好地运用这两个策略。</p><h2 id="场景设想"><a href="#场景设想" class="headerlink" title="场景设想"></a>场景设想</h2><p>假设在执行pull之前的提交线图如下所示：</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/git-rebase-merge-example.png" alt=""></div><h2 id="Merge操作"><a href="#Merge操作" class="headerlink" title="Merge操作"></a>Merge操作</h2><p>如果执行<code>git pull</code>（git默认会执行<code>git pull --merge</code>），提交线图会变成如下所示：</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/git-rebase-merge-example-merge.png" alt=""></div><p><strong>分析</strong><br>提交线图中多出了一个没有必要的提交<code>H</code></p><h2 id="Rebase操作"><a href="#Rebase操作" class="headerlink" title="Rebase操作"></a>Rebase操作</h2><p>如果执行<code>git pull --rebase</code>，提交线图会变成如下所示：</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/git-rebase-merge-example-rebase.png" alt=""></div><p><strong>分析</strong><br>提交线图中，本地的新提交<code>F</code>，<code>G</code>变成了两个新的提交<code>F&#39;</code>，<code>G&#39;</code>，拼接在了<code>C</code>后面，多余的分叉也删除了。提交线变得非常清晰。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>从上述对比可以看出，rebase操作会将本分支的新提交删除并生成新的提交。所以rebase操作比较适用于将一些零碎的提交进行合并清理。比如：在push之前进行整理。</p><p>那么merge操作意义何在呢？  </p><p>merge操作与rebase操作相反，它可以保留了提交线图的分叉，并生成一个新的提交。这种场景适合用于大的分支合并。这样，我们可以在提交线图中看到项目开发迭代过程中经历过哪些feature分支等等。</p><p><strong>注意</strong><br>如果执行merge操作之前，提交线图是分叉的（即不是<code>fast-forward</code>，如<strong>场景设想</strong>的情形），执行<code>git merge</code>操作，是会达保留分支的目的。  </p><p>但是执行merge操作之前，提交线图不是分叉的（即是<code>fast-forward</code>，如下上图所示），此时执行<code>git merge</code>操作的效果如下下图所示，分支是不会保留的。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/git-rebase-merge-example01.png" alt=""></div><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/git-rebase-merge-example03.png" alt=""></div><p>在<code>fast-forward</code>情况下进行合并，我们需要执行如下命令来保留分支。执行后的提交线图如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff</span><br></pre></td></tr></table></figure></p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/git-rebase-merge-example02.png" alt=""></div><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git场景&quot;&gt;&lt;a href=&quot;#Git场景&quot; class=&quot;headerlink&quot; title=&quot;Git场景&quot;&gt;&lt;/a&gt;Git场景&lt;/h1&gt;&lt;p&gt;在基于Git版本控制的团队协作开发中，当同伴先于自己将新的提交push到远程分支上时，如果要想将自己新的提交push
      
    
    </summary>
    
      <category term="软件" scheme="http://chuquan.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="git" scheme="http://chuquan.me/tags/git/"/>
    
      <category term="merge" scheme="http://chuquan.me/tags/merge/"/>
    
      <category term="rebase" scheme="http://chuquan.me/tags/rebase/"/>
    
  </entry>
  
  <entry>
    <title>写在入职两个月之际</title>
    <link href="http://chuquan.me/2017/09/17/graduated-for-two-month/"/>
    <id>http://chuquan.me/2017/09/17/graduated-for-two-month/</id>
    <published>2017-09-17T03:40:03.000Z</published>
    <updated>2018-02-09T03:27:44.479Z</updated>
    
    <content type="html"><![CDATA[<p>学生生涯结束至今已有两月有余，偶尔还是会念想在北大那些瞬间，好在入职的公司在各方面都非常令我满意，不至于用怀念来解忧生活。  </p><h1 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h1><hr><p>说说现在的公司吧，一家处于成长期的K12在线教育创业公司——猿辅导，坐落在阜通站旁的利星行中心。公司主要有粉笔网、猿题库、猿辅导、小猿搜题等几款在线教育App。  </p><p>7月10日刚入职，我被安排到小猿搜题研发部的iOS开发岗。作为一名无任何iOS开发经验的应届毕业生，我的压力还是蛮大的，毕竟这对我来说是一个全新的挑战。好在我的同事们都非常nice，尤其是我的mentor——展哥，还有坐我旁边的元老级程序媛——琳洁。每每我在学习以及开发过程中有任何问题，他们都会不厌其烦地给我讲解，真的非常感谢他们！相比我之前实习的那家公司（某度），就同事间的关系来说，真是不知道高到哪里去了。  </p><p>我们研发部研发人员大概不到20人，4个iOS，3个安卓，5个后台，3个前端，3个测试，当然其中也有些人前后端都做，小组内同事大都是硕士以上学历。研发部内部分为三个小团体：产品、客户端、服务器端。iOS、安卓、测试共同组成一个客户端，组内气氛每天都很欢乐，不至于每天工作得很压抑。    </p><p>公司的工作制度也是比较和谐的。朝十晚七，不打卡，无KPI，不提倡加班。每天上午会有一个几分钟的站会，每个人说一下自己前一天的任务完成情况，以及当天的任务安排。我们平时也没有那么多的会，除非PM有新的产品需求，并且不提倡大家携带笔记本开会，从而提高开会效率。在某度，几乎每天都有各种会议，开会的时候大家基本都会携带笔记本，自己干自己的事。过多的会议真的会严重碎片会工作时间，降低工作效率。在某度实习期间，一个月的代码量都不如我现在一个星期的代码量。  </p><p>周二下午我们小组会对PM提出的产品需求汇集、拆分，并进行难度评分，最后予以分配。站会也是就是对这些任务进展的汇报及安排。如此一套Scrum开发流程，可以极大地提高我们的工作效率。工作效率高了，也就没有必要加班了，生活也不是那么枯燥乏味了。  </p><p>入职两个月以来，我能感受到自己的成长非常大。真正的项目实践总是能让你对一些东西有更深入的理解，比如git、gerrit等。公司对于项目管理使用了很多开源的工具，并进行了重组。希望在之后的日子里，我能对这些工具平台也有更深一步的了解。  </p><h1 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h1><hr><p>女票家给她在塘溪津门买了一套房，首付30%，2.2w/平米。接下来由我们两来还房贷，我每个月还贷1w，房租3k多，虽说生活还没到捉襟见肘的地步，但是能省则省吧。公积金也准备提出来了，只有这样，生活还能够多出一些积蓄来。当自身背负了如此沉重的房贷后，事业的发展总是会受到一定的影响，在面临选择的时候，会变得格外谨慎、犹豫，未来的我也许也会面临这样的情境。  </p><p>该吐槽的还是要得吐槽。政府现在真的是把人往绝境里逼，虽说出台了一套又一套的房价抑制政策，然而所谓的政策只不过是稳定人心的幌子，韭菜该割还是要割，房价只是减速增长而已。房价的增长比工资的增长还快，买不起房的人永远都买不起房。</p><p>今年北京市的高考状元接受采访时的言论真的是一针见血。在教育方面上，他们享受着农村孩子无法想象的资源优势，进入名校对他们来说只是水到渠成的问题。事实上，在北大求学期间，我也意识到这个问题：周围的同学，尤其是本科生，大多数的家庭要么是高识分子，要么是高收入家庭，农村而来学生真的很少。现在社会频频出现学生入学如调查家庭背景的案例，很明显，学校在区分学生家庭所处的社会阶级，这样的情况在未来还会继续蔓延。富人越富，穷人愈穷，下一代亦是如此，阶级的固化正在酝酿。也许我们这一代还有不少能从底层往上爬，但后来的人真的将越来越难…</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学生生涯结束至今已有两月有余，偶尔还是会念想在北大那些瞬间，好在入职的公司在各方面都非常令我满意，不至于用怀念来解忧生活。  &lt;/p&gt;
&lt;h1 id=&quot;关于工作&quot;&gt;&lt;a href=&quot;#关于工作&quot; class=&quot;headerlink&quot; title=&quot;关于工作&quot;&gt;&lt;/a&gt;关于工
      
    
    </summary>
    
      <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://chuquan.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Git 分支模型</title>
    <link href="http://chuquan.me/2017/09/10/git-branching-model/"/>
    <id>http://chuquan.me/2017/09/10/git-branching-model/</id>
    <published>2017-09-10T12:01:36.000Z</published>
    <updated>2018-02-09T03:27:21.815Z</updated>
    
    <content type="html"><![CDATA[<p>我们公司的软件产品迭代采用的是scrum敏捷开发流程，代码使用git进行版本管理。在新人最初的几次开发任务中，我对于git的使用也仅限于一些基本的命令，包括：add、commit、rebase、cherry-pick、push、checkout等等。<br>直到有一天，我发现远程分支上存在着一些历史feature分支，这对于我这个初入职场的小白来说还是有些好奇：feature分支在本地建立不就行了吗？为何还需要推送到远程仓库？<br>带着这一些列的疑问，我仔细研究了一些我们基于gerrit的code review流程，终于明白了为何会有feature远程分支。这一切都与git的分支模型有关。<br>期间，我在一个英文博客上看到了一篇关于<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">git分支模型</a>的介绍，看完后觉得不错，对其进行简要地整理，以呈现给大家。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-branch-model.png?x-oss-process=image/resize,w_500" alt=""></div><h1 id="分权集中"><a href="#分权集中" class="headerlink" title="分权集中"></a>分权集中</h1><p>下图中心的仓库，是我们建立并在使用的仓库，具有分支模型，其通常会被认为是“真正的中心仓库”。然而，事实上，其仅仅是被<strong>认为</strong>是中心仓库而已，因为git作为一个分布式版本控制系统（DVCS），在技术层面并不存在哪个仓库是中心仓库。而这个被认为是“中心”的仓库，我们更愿意称之为<strong>origin</strong>，这个名字对于所有git用户都是很熟悉的。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-center-decenter.png?x-oss-process=image/resize,w_400" alt=""></div><p>每个开发者都会从origin进行pull或向其进行push操作。但是除了与origin具有push-pull关系之外，开发者们还可能从其他同级的伙伴那里pull最新的改动，从而形成一个sub team。比如，对于两个以上的开发者，在过早地向origin推送开发进展之前，其可以开辟一个新的feature分支来共同工作。如上图所示，存在着这样几个开发小组：Alice &amp; Bob，Alice &amp; David，Clair &amp; David。  </p><p>从技术角度而言，这仅仅意味着Alice定义了一个远程仓库，名字是Bob，其指向了Bob的仓库，反之亦然，仅此而已。</p><h1 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h1><p>归根到底，开发模型也受到了上述思想的影响。在中心仓库中，在其无限的生命周期中，始终存在着两条主分支：  </p><ul><li><strong>master</strong></li><li><strong>develop</strong></li></ul><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-main-branches.png?x-oss-process=image/resize,w_250" alt=""></div><p>大家对<strong>origin</strong>上的<strong>master</strong>分支应该并不陌生。而另一个与之平行的分支，我们称之为<strong>develop</strong>分支。  </p><p><strong>origin/master</strong>：在这个分支上，源代码的<strong>HEAD</strong>指针的指向始终都是就绪/可发布的产品状态。  </p><p><strong>origin/develop</strong>：在这个分支上，源代码的<strong>HEAD</strong>指针的指向始终都是下一个版本的产品状态。</p><p>当<strong>develop</strong>分支的源代码到达某一个可发布的稳定点时，所有的改动都应该合并到<strong>master</strong>分支，然后打上版本的tag标签。  </p><p>因此，每次将改动合并至<strong>master</strong>分支时，意味着一个新版本的诞生。我们往往对这个过程控制得非常严格。所以每次<strong>master</strong>分支上有commit时，我们都应该使用git hook脚本来自动编译、发布软件至产品服务器上。  </p><h1 id="支持分支"><a href="#支持分支" class="headerlink" title="支持分支"></a>支持分支</h1><p>与主分支<strong>master</strong>、<strong>develop</strong>相邻的则是各种支持分支，用于帮助团队成员之间进行平行开发，跟踪功能，准备产品发布以及帮助修复在线产品的一些Bug。与主分支不同，这些分支总是具有有限的生命周期，因为它们最终都是要被删除的。  </p><p>我们可能用到的几种不同的支持分支：  </p><ul><li><strong>Feature分支</strong></li><li><strong>Release分支</strong></li><li><strong>Hotfix分支</strong></li></ul><p>上述的每一个分支都具有特定的目的，并且必须遵守严格的规则。比如：哪些分支可以是它们的源头分支，哪些分支必须是它们的合并目标。  </p><p>当然，从技术角度来说，这些分支并没有什么特殊之处。所谓的分支类型只是我们根据如何使用它们而进行分类的。  </p><h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p><strong>规则</strong>：  </p><blockquote><p>可以源自<strong>develop</strong>分支<br>必须合并到<strong>develop</strong>分支<br>命名：除<strong>master</strong>，<strong>develop</strong>，<strong>release-*</strong>，<strong>hotfix-*</strong>之外</p></blockquote><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-feature-branches.png?x-oss-process=image/resize,w_125" alt=""></div><p>Feature分支（也称：topic分支）用来为即将发布的版本或更远的版本开发新的feature。当开发一个新的功能的时候，我们不知道这个功能会被纳入哪个目标版本。Feature分支的本质就是，只要该功能处于开发阶段，feature分支就会存在，并最终会被合并至<strong>develop</strong>分支（以确保将新功能添加到即将发布的版本中）或者丢弃（在实验失败的情况下）。  </p><p>Feature分支通常只存在与开发者自己的仓库中，而不是<strong>origin</strong>。</p><h3 id="创建feature分支"><a href="#创建feature分支" class="headerlink" title="创建feature分支"></a>创建feature分支</h3><p>当开始开发一个新的功能时，需要从<strong>develop</strong>主分支中开辟一个新分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b myfeature develop //表示切换到一个新的分支“myfeature”</span><br></pre></td></tr></table></figure></p><h3 id="将完成的功能纳入develop"><a href="#将完成的功能纳入develop" class="headerlink" title="将完成的功能纳入develop"></a>将完成的功能纳入develop</h3><p>完成的功能可以合并至develop分支，以加入即将发布的版本之中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop  //切换至develop分支</span><br><span class="line">$ git merge --no-ff myfeature //</span><br><span class="line">$ git branch -d myfeature   //删除myfeature分支</span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure></p><p><strong>–no-ff</strong>选项会在合并分支时创建一个新的commit对象，即使合并可以是一次fast-forward操作。这可以避免丢失feature分支的历史存在信息，并将该feature分支上的所有commit放在在一起。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-merge-no-ff-comare.png?x-oss-process=image/resize,w_400" alt=""></div><p>如上图所示，相比较而言，后面一种情况是不可能从git历史记录中看到哪些提交对象一起实现了一个功能，你必须手动读取所有日志信息。在后一种情况下，恢复整个功能（即一组提交）是非常困难的，而如果使用了<strong>–no-ff</strong>选项，则很容易实现。</p><p>当然，这会创建一些空的commit对象，但收益远大于成本。  </p><h2 id="Release分支"><a href="#Release分支" class="headerlink" title="Release分支"></a>Release分支</h2><p><strong>规则</strong></p><blockquote><p>可以源自<strong>develop</strong>分支<br>必须合并到<strong>develop</strong>分支和<strong>master</strong>分支<br>命名：<strong>release-*</strong></p></blockquote><p>Release分支用于支持准备新的产品版本，它们允许对版本进行小错误修复和元数据准备（版本号，构建日期等）。通过在Release分支上进行所有这些工作，<strong>develop</strong>分支会被清理以接收下一个大版本的功能。  </p><p>当<strong>develop</strong>分支达到了新版本的期望状态时，即可从<strong>develop</strong>分支开辟新的release分支。当然，必须要等到所有待发布的功能合并至<strong>develop</strong>分支之后才可以。  </p><p>正是在release分支的开始，即将发布的版本会被分配版本号。直到这一刻起，<strong>develop</strong>分支“下一个版本”的改动。但是“下一个版本”会变为0.3还是1.0，需要等到release分支开始才知道。这是在release分支开始时，由版本规则决定的。  </p><h3 id="创release分支"><a href="#创release分支" class="headerlink" title="创release分支"></a>创release分支</h3><p>Release分支从<strong>develop</strong>分支创建而来。例如，1.1.5版本是当前的产品版本，我们即将有一个大的版本。<strong>develop</strong>已经为“下一个版本”准备就绪了，并且我们已经决定这将成为1.2版本（而不是1.1.6或2.0）。所以我们开辟一个分支，并予以相应的版本号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release-1.2 develop å</span><br><span class="line">$ ./bump-version.sh 1.2 </span><br><span class="line">$ git commit -a -m <span class="string">"Bumped version number to 1.2"</span></span><br></pre></td></tr></table></figure></p><h3 id="结束release分支"><a href="#结束release分支" class="headerlink" title="结束release分支"></a>结束release分支</h3><p>当release分支的状态已经准备好成为y一个真正的版本，需要完成一些操作。首先，将release分支合并至<strong>master</strong>分支（<strong>master</strong>上的每一个commit都是一个新的版本）。然后，<strong>master</strong>上的commit必须被打上标签，以便参考历史版本。最后，将在release分支上作出的改动合并到<strong>develop</strong>分支上，以便未来的版本还包含这些错误修复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// step 1</span><br><span class="line">$ git checkout master å</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">// step 2</span><br><span class="line">$ git tag -a 1.2</span><br><span class="line">// step 3</span><br><span class="line">$ git checkout develop</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">// 完成后，我们可以将release分支删除</span><br><span class="line">$ git branch -d release-1.2</span><br></pre></td></tr></table></figure><h2 id="Hotfix分支"><a href="#Hotfix分支" class="headerlink" title="Hotfix分支"></a>Hotfix分支</h2><p><strong>规则</strong></p><blockquote><p>可以源自<strong>develop</strong>分支<br>必须合并到<strong>develop</strong>分支和<strong>master</strong>分支<br>命名：<strong>hotfix-*</strong></p></blockquote><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-hotfix-branches.png?x-oss-process=image/resize,w_250" alt=""></div><p>Hotfix分支与release分支非常相似，其也是用于为新的产品版本做准备，尽管是计划之外的。它们是对发布版本的不良状态作出的回应。当产品版本中的一个关键bug必须要被修复时，可以从<strong>master</strong>分支上相应的tag标签中开辟一个hotfix分支。</p><p>Hotfix分支的本质是可以使<strong>develop</strong>分支上的工作得以继续，而另外有人进行bug修复。</p><h3 id="创建hotfix分支"><a href="#创建hotfix分支" class="headerlink" title="创建hotfix分支"></a>创建hotfix分支</h3><p>Hotfix分支从<strong>master</strong>分支创建而来。例如，1.2版本是当前产品的版本号，正在在线运行，由于服务器bug出现了一些问题。但是<strong>develop</strong>分支上的改动还不稳定。我们需要开辟一个hotfix分支来进行bug修复。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix-1.2.1 master</span><br><span class="line">$ ./bump-version.sh</span><br><span class="line">$ git commit -a m <span class="string">"Bumped version number to 1.2.1"</span></span><br><span class="line">// 修复bug并commit</span><br><span class="line">$ git commit -m <span class="string">"Fixed server production problem"</span></span><br></pre></td></tr></table></figure><h3 id="结束hotfix分支"><a href="#结束hotfix分支" class="headerlink" title="结束hotfix分支"></a>结束hotfix分支</h3><p>当完成bug修复之后，hotfix分支需要合并到<strong>master</strong>分支，当然也需要合并至<strong>develop</strong>分支，这与release分支是非常相似的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// step 1: 合并至master，打上版本标签</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">$ git tag -a 1.2.1</span><br><span class="line">// step 2: 合并至develop</span><br><span class="line">$ git checkout develop</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">// step 3: 删除hotfix分支</span><br><span class="line">$ git branch -d hotfix-1.2.1</span><br></pre></td></tr></table></figure><p>这里有一个例外需要注意，<strong>当一个release分支当前还存在时，hotfix分支的修改应该合并至release分支，而不是develop分支</strong>。因为release分支完成后，需要合并至<strong>develop</strong>分支。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们公司的软件产品迭代采用的是scrum敏捷开发流程，代码使用git进行版本管理。在新人最初的几次开发任务中，我对于git的使用也仅限于一些基本的命令，包括：add、commit、rebase、cherry-pick、push、checkout等等。&lt;br&gt;直到有一天，我发
      
    
    </summary>
    
      <category term="软件" scheme="http://chuquan.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="git" scheme="http://chuquan.me/tags/git/"/>
    
      <category term="分支模型" scheme="http://chuquan.me/tags/%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>iOS View Controller概览</title>
    <link href="http://chuquan.me/2017/08/27/ios-viewcontroller-introduce/"/>
    <id>http://chuquan.me/2017/08/27/ios-viewcontroller-introduce/</id>
    <published>2017-08-26T16:03:41.000Z</published>
    <updated>2018-02-08T10:28:13.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><hr><p>在斯坦福CS193p课程中，白胡子老教授首先介绍了iOS开发中的<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank" rel="noopener">MVC</a>软件设计模式，这是因为iOS应用即采用此种设计模式。如下图所示，MVC模式将软件分为三个部分：  </p><ul><li><code>Model</code>：数据存储层  </li><li><code>View</code>：视图展示层  </li><li><code>Controller</code>：逻辑控制层  </li></ul><p><dic align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-mvc.png" alt=""></dic></p><p>MVC模式隔离了视图层和数据层，两者必须以控制层作为中介实现交互和通信。实际的iOS应用一般都是MVC模式的嵌套组合实现，如下图所示。其中，控制层是由<code>UIViewController</code>类及其子类（如：<code>UITableViewController</code>、<code>UINavigationController</code>、<code>UITabBarController</code>）的实例实现的。<code>UIViewController</code>自带一个根视图层（即<code>view</code>属性），以便添加和操作用户自定义的视图层。当然，我们也可以在<code>UIViewController</code>中定义数据层。这是因为<code>UIViewController</code>需要这样的接口来连通并控制M和V。但是，好的设计会尽量将数据层和视图层从<code>UIViewController</code>中解耦分离出来。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-mvcs.png" alt=""></div> <h1 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h1><hr><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>前面说到，实际的app采用MVC嵌套组合的设计模式，以此为据，app中至少包含一个视图控制器。这些视图控制器管理着app中所有的事务，包括：视图管理、事件处理、视图控制器之间的调度等等。  </p><p>既然视图控制器具有可以嵌套和组合，那么肯定有部分视图控制器可以充当视图控制器的容器。事实上，视图控制器的确可以分为以下两种：  </p><ul><li>内容视图控制器（Content View Controller）：用于管理app内容的视图控制器，也是最常用的视图控制器。  </li><li>容器视图控制器（Container View Controller）：作为其他视图控制器的容器，并以某种方式呈现这些视图控制器及其内容。  </li></ul><h3 id="内容视图控制器"><a href="#内容视图控制器" class="headerlink" title="内容视图控制器"></a>内容视图控制器</h3><p>内容视图控制器是最常用的元素，常见的有三种（后两者是前者的子类）：  </p><ul><li><code>UIViewController</code></li><li><code>UITableViewController</code></li><li><code>UICollectionViewController</code></li></ul><p>常用的在大多数情况下，app上的一个页面就是由一个视图控制器所展现的。内容视图控制器的主要任务包含：  </p><ul><li>更新视图内容，通常是响应底层数据的变化  </li><li>响应用户与视图的交互  </li><li>缩放视图、管理布局</li></ul><h3 id="容器视图控制器"><a href="#容器视图控制器" class="headerlink" title="容器视图控制器"></a>容器视图控制器</h3><p>容器视图控制器使用属性<code>viewcontrollers</code>来存储对视图控制器的引用，并且不对容器中视图控制器的数量作限制。最常见容器视图控制器的有两种（两者均是<code>UIViewController</code>的子类）：</p><ul><li><code>UINavigationController</code>  </li><li><code>UITabBarController</code>  </li></ul><p>关于<code>viewcontrollers</code>属性，<code>UINavigationController</code>采用的是stack结构，<code>UITabBarController</code>采用的是array结构。不同的数据结构，对视图控制器的调度形式也不同。  </p><p>下图所示为<code>UINavigationController</code>的应用示例，<code>UINavigationController</code>采用stack的方式调度页面（即视图控制器）。</p><p>三个视图控制器视图的顶部是<code>UINavigationController</code>的导航栏，当切换到某个内容视图控制器时，导航栏的样式可以由该视图控制器进行配置。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-uinavigationcontroller04.png" alt=""></div><p>下图所示为<code>UITabBarController</code>的应用示例，其对页面的调度和操作array一样灵活，视图的底部有四个标签，对应着4个独立的视图控制器，可任意切换。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-uitabbarcontroller03.png" alt=""></div>  <h2 id="视图管理"><a href="#视图管理" class="headerlink" title="视图管理"></a>视图管理</h2><p>视图管理器，顾名思义，其有一个重要的作用就是：管理视图的层次结构。每个视图控制器都有一个根视图，其中包含了视图控制器的所有内容，可通过<code>view</code>属性获取。通过该属性，我们可以添加更多视图。<br>内容视图管理器自身管理其所有的视图；容器视图管理器则采用分治的方式，通过子视图控制器来进行视图管理。<br>下图所示，代表性地展示了内容视图控制器及其视图之间的关系。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-relation-of-viewcontroller-and-views.png" alt=""></div> <h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p>在MVC设计模式中，视图控制器作为承担着数据和视图通信的中介角色。通过<code>UIViewController</code>的内置及自定义的属性和方法，可以完成控制器需要承担的任务。如下图所示，为视图控制器与数据、视图的关系示意图。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-relation-of-mvc.png" alt=""></div><p>在实际开发中，我们始终应该清晰地分离视图控制器和数据对象。视图控制器应该扮演逻辑控制的角色，而应该减少数据管理的角色。  </p><p>为了处理数据管理，很多设计使用了MVVM的设计模式，这种设计添加了一个View Model层来对来自Model层的原始数据进行处理，从而提供给Controller，使其可以直接使用。  </p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>如下图所示为视图控制器的生命周期，其中与视图view相关的步骤较多。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-viewcontroller-lifecycle01.png" alt=""></div>  <ul><li><strong>init</strong><blockquote><p>init阶段，通常只初始化比较关键的数据，而不会在该阶段对view进行初始化。</p></blockquote></li><li><strong>loadView</strong><blockquote><p>loadView阶段，通常只初始化view</p></blockquote></li><li><strong>viewDidLoad</strong><blockquote><p>此时view不在为nil，适合创建一些附加的view及控件。</p></blockquote></li><li><strong>viewWillAppear</strong><blockquote><p>该阶段view即将被添加到app的window对象之上。</p></blockquote></li><li><strong>viewDidAppear</strong><blockquote><p>该阶段view已经被添加到app的window对象之上，用户可以看到软件的视图，此时可以进行动画操作。</p></blockquote></li></ul><p>为了进一步了解添加到根视图<code>view</code>上的用户附加视图，我分别在<code>loadView</code>和<code>viewDidLoad</code>阶段添加了一个视图，以观察视图控制器的生命周期，如下所示，为部分代码示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)loadView &#123;</span><br><span class="line">    [super loadView];</span><br><span class="line">    NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));</span><br><span class="line">    </span><br><span class="line">    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(100, 400, 100, 50)];</span><br><span class="line">    button.backgroundColor = [UIColor blueColor];</span><br><span class="line">    [button addTarget:self action:@selector(buttonPressed) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:button];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));</span><br><span class="line">    </span><br><span class="line">    self.testView = [[TestView alloc] initWithFrame:CGRectMake(100, 100, 200, 200)];</span><br><span class="line">    self.testView.backgroundColor = [UIColor grayColor];</span><br><span class="line">    [self.view addSubview:self.testView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下图为UINavigationController中的一个视图控制器生命周期执行情况。生命周期符合前面的描述，此外还可以发现，在视图控制器中添加自定义的视图，则生命周期中还会多出两个步骤：</p><ul><li><code>viewWillLayoutSubviews</code></li><li><code>viewDidLayoutSubviews</code></li></ul><p>仔细观察，还可以发现: <code>viewWillLayoutSubviews</code>和<code>viewDidLayoutSubviews</code>均出现在<code>viewWillAppear</code>之后。在添加视图的时候，每添加一个视图就会执行这两个步骤，而移除视图时直接移除根视图直接移除根视图。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-viewcontroller-lifecycle03.png" alt=""></div> <p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在斯坦福CS193p课程中，白胡子老教授首先介绍了iOS开发中的&lt;a href=&quot;https://en.wikipedia.org
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="UIViewController" scheme="http://chuquan.me/tags/UIViewController/"/>
    
  </entry>
  
  <entry>
    <title>毕业旅行——泰国</title>
    <link href="http://chuquan.me/2017/06/16/tailand/"/>
    <id>http://chuquan.me/2017/06/16/tailand/</id>
    <published>2017-06-16T13:16:27.000Z</published>
    <updated>2018-02-18T18:15:48.664Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=33522489&auto=1&height=66"></iframe><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p><strong>6月3日，周六</strong><br>昨天下午顺利通过硕士论文答辩，必须得感谢各位老师和同学们这三年的关照才得以顺利毕业，和大家相处的三年是非常快乐的。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/dabian.jpeg" alt=""></div><p>今天是辩结束后的第一天，三年来从未像此刻一样如此轻松。遂准备本次泰国之行最后的相关事项，即如何去机场啊、酒店机票的订单截图啊之类的。  </p><p>机票的时间是21:55，晚饭过后在未名湖畔小散了一会儿步，便启程出发，差不多8点多达到首都T2航站楼。  </p><p>我们在淘宝上订了泰国的7天Happy电话卡，发货方式是机场自取。自取的地点是在国际航班出发点的某个柜台，然而我们去泰国的航班并不是直达，而是从昆明转机至清迈，显然首次航班是国内航班。电话给淘宝客服，居然还不能送出来，也罢，取消了订单，到当地再买happy卡吧。  </p><p>接下来又发生了一件意想不到的事情：取机票时，柜台说妹纸机票的订票姓名拼音与护照不符，WTF？！打开东航APP上的订单，居然还真拼错了！尴尬！遂致电客服，客服说会尽快修改，但不保证在确定时间内完成。没办法，只能等。离办理值机只剩不到二十分钟了，心情自然也是极度忐忑。遂再次致电客服，客服确认了好几便，说姓名的拼音是正确的，看来是改好了。最终也是有惊无险地办理了值机，顺利登上了飞机。有了这次遭遇，下次应该就长心眼儿了吧。  </p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p><strong>6月4日，周日</strong><br>首趟航班差不多凌晨1点达到昆明，下机后先找值机柜台，这个点柜台都已经下班了，需要等到凌晨五点。我们航班的时间是6:30，按照值机时间是来得及的。于是便寻找游客休息室，然而大厅中已经全是游客，更气的是不少人一个人占了多个座位在睡觉，不少人席地而坐，素质啊素质。  </p><p>席地打盹，好不容易熬到5点，便去值机柜台办理值机。没想到办理国际航班的值机服务，不仅要查看护照、签证，还要查找在目的国的酒店订单信息，返程机票以及钱包里的现金。所幸除了现金还需再取，其他的我们都符合要求。<br>昆明机场的确也是非常大的，据说是东航的大本营，果不其然，机场上一排排的飞机基本都是东航的。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand011.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand010.png" alt=""></div><p>第二趟航班差不多经历两个多小时，抵达清迈。刚下飞机没多久，手机时间便自动调整为了泰国时间，比北京时间早1个小时整。清迈机场真心非常小，国内随便找个机场都不知道要比它高几个档次。机场大厅里各个角落的指示牌居然同时有三种语言：泰语、英语、汉语，中国游客对于清迈旅游产业的影响可见一斑。  </p><p>出了机场，便致电给平那科酒店，以寻求接机服务。学了那么多年的英语，从这一刻开始初见成效了。大约十分钟，接机小哥便来到了机场，下车便用很流利的中文跟我确认身份，我们一度以为他是中国人。地图上，平那科酒店与机场的直线距离只有几公里，然而实际却拐了很多弯才到达酒店，这是因为泰国的很多道路是单行道，正是这单行道后面也让我们吃了不少苦。  </p><p>抵达平那科酒店大概是在泰国时间的上午8点多，由于一晚都没睡，总感觉现在是下午。Check in的时候，前台小哥便用流利的中文和我们交谈，说房间需要等到12点才会有，可以让我们先把行李寄存在前台，出去玩一会儿。遂即我们便出门去找711超市买happy卡。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand049.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand015.png" alt=""></div><p>由于时间还非常早，我们便打算打乱一下计划，逛一逛宁曼路街区。泰国的环境真的非常好，空气里透露着一股泥土的气息，蓝天和云彩的配合简直完美。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand050.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand051.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand052.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand047.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand048.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand038.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand053.jpg" alt=""></div><p>差不多到了中午，我们就近找了一家餐馆就餐，点了心心念念的芒果糯米饭和泰式酸辣海鲜河粉。第一次吃到芒果糯米饭的时候，汗毛都竖了起来，这糯米真的是入口即化！事实证明，这家店的芒果糯米饭是我们在泰国吃过的所有芒果糯米饭中最赞的！唯一遗憾，没记住店名…</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand042.png" alt=""></div><p>饭后便回酒店准备办理入住。环顾酒店大厅，其装潢还是相当不错的。  </p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand043.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand054.jpg?x-oss-process=image/resize,w_570" alt=""></div><p>前台告诉我们行李都已经搬进了房间，对此我是震惊的。在这一方面，国内同样价格的酒店可没这个待遇。我们订的房间大约200多一晚，房间的设施非常完备，吹风机、冰箱、热水壶、电视、衣柜什么都有，性价比非常高。房间的空间很大，装修也是简约大方，不多说，推荐推荐！</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand044.png" alt=""></div> <p>这一天真实特别漫长，当然也是非常累，回房便是洗澡睡觉。恰好老天爷眷顾，外面开始下起了阵雨，等到三点左右我们醒来，雨也停了，气温也降了，给力呀！</p><p>遂即按照计划步行去古城，路上遇到些水果摊显然是管不住自己的手的，榴莲、芒果、红毛丹，买买买。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand046.jpg" alt=""></div> <p>酒店到古城西门大约2公里，期间我们还晃悠进了一个公园，似乎是个马戏团，外面还摆着演出广告。就这样边吃边看边走，最终大概花了1个小时才到达古城。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand045.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand055.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand056.jpg" alt=""></div> <p>今天是周日，古城内会有周日夜市，这也是我们今晚来古城的原因。我们到古城内的街道时，小贩们已经开始陆续占领街道，支帐篷，挂吊灯，备战夜市。  </p><p>显然小吃是我们此行的重要任务。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand057.jpg" alt=""></div> <p>穿着拖鞋从酒店走到古城，着实累脚。路中央，一位马杀鸡小哥在盛情揽客，于是就此躺了半小时，腿脚也是满血复活。不吹不黑，马杀鸡，好牛逼！</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand060.jpg" alt=""></div> <p>夜幕降临之前，我们尽可能地多逛逛古城。最后来到一个广场，这似乎是古城的行政中心。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand059.jpg" alt=""></div> <p>夜市的吊灯陆续被点亮，游客也越积越多。我们沿着夜市，边吃边逛，挑选购买看上眼的异国小商品。差不多到7点半，我们回到了夜市的入口，搭了辆Tuk-Tuk，回到了平那科。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p><strong>6月5日，周一</strong><br>平那科酒店是提供早餐的，从8点提供至10点。酒店的一楼大厅便是自助餐厅，餐厅的布局很漂亮，有室内餐桌和室外餐桌。食物也非常丰盛，主要以西餐和泰式菜为主。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand061.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand062.png" alt=""></div> <p>安静地享受完早餐，便托前台小哥帮忙租辆摩托车。五分钟后，租车小哥便风尘仆仆地赶来了。用蹩脚的英语与小哥聊了聊，签了合同，抵押了护照，然后预支了一天的租金300B。小哥还提醒我，归还摩托车时需要加满油，need be full，need be full。第一次开摩托，既兴奋又紧张，戴好头盔，便以每小时30公里的速度飞奔古城，游览泰国的知名寺庙。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand063.png?x-oss-process=image/resize,w_570" alt=""></div><p>我们在古城内依次逛了帕辛寺、清迈寺、契迪龙寺等寺庙。说实话，这些寺庙的风格基本上是一致的，只是规模和颜色稍有差别。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand066.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand067.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand068.png" alt=""></div> <p>很快就到了中午，借着谷歌地图我们来到了大众点评上口碑不错的Mogo Tango餐厅。该餐厅以甜食和冰淇淋为主，平嘴而论，口味对得起评分，可以可以。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand069.png" alt=""></div> <p>因为我们预定了下午一点半去素贴山玩，所以没在餐厅久留，吃完便回酒店睡午觉。  </p><p>大概一点半左右，导游和司机便来接我们。导游的中文很不错，长得很像张家辉，很可惜没和他合影。  </p><p>此趟行程的第一站是位于素贴山最高峰的蒲屏皇宫。蒲屏皇宫有点类似于国内的承德避暑山庄，都是皇室避暑的行宫。蒲屏皇宫里面种满了各种花草，环境也是相当的静谧，显然是个避暑好去处。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand070.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand071.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand072.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand073.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand074.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand075.jpg" alt=""></div> <p>素贴山的下一站便是双龙寺，这里导游给我们讲了讲双龙寺的来历，并参观了里面的一个舍利塔。在这里可以鸟瞰整个清迈，是一个非常值得推荐的旅游景点。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand076.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand077.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand078.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand079.png" alt=""></div> <p>半日游结束后，导游便送我们回来。我们在宁曼路的玛雅购物中心下了车。玛雅购物中心应该是清迈最大的购物商场，有6层，内部设施非常现代化。我们在这里找了一家游客较多的餐厅就餐。在这里，第一次品尝了正宗的泰国菜。泰国菜，特别是汤类菜肴，基本都会放香茅。这玩意儿味道很重，吃起来就像在吃化妆品，真心不符合中国人的口味。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand080.png" alt=""></div> <h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p><strong>6月6日，周二</strong><br>7点起床，早早地便在餐厅吃完了早餐，然后就是等待导游来接我们去拜县一日游。拜县位于清迈西北方向100多公里，地处山区，一趟行程就要经历700多个弯道。对此，我们不仅准备了晕车药，还有晕车贴。一路上，不仅上下颠，还左右晃，难受得无法形容。没多久，minivan里就有游客交代了早餐。在车上煎熬了40分钟平地和2小时山路，终于抵达拜县。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand081.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand082.jpg" alt=""></div> <p>此次拜县之旅一共有8个景点，我们去了其中的7个。首先是小树屋。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand087.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand083.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand084.png?x-oss-process=image/resize,w_570" alt=""></div><p>其次是二战桥。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand085.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand086.jpg" alt=""></div> <p>二战桥之后便是草莓园。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand088.jpg" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand089.jpg" alt=""></div> <p>随后抵达小黄屋，据说是《爱在拜城》的取景地，我表示没看过…</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand090.png" alt=""></div> <p>午饭前终于达到了期待已久的大树秋千。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand091.jpg?x-oss-process=image/resize,w_570" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand092.jpg" alt=""></div> <p>等大家都排完队与大树秋千合影之后，便来到了“中华饭店”就餐，肘子、青菜豆腐汤、醋溜土豆丝…几道菜而已。据说此地是云南村，此地大量土著都是华裔，解放时期国共内战，很多人逃离至此。导游本人也是在泰国的华裔二代，所以中文说得溜也是有原因的。</p><p>午饭过后在饭店附近玩了玩土著的射箭。稍事休息，便再次踏上旅程。<br>之后依次游览了粉色房子、倒立屋、农场。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand093.jpg?x-oss-process=image/resize,w_570" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand094.png" alt=""></div> <p>差不多下午两点，景点游玩到此结束。然后便是回清迈，又是经历700多个弯。在我看来，拜县就是那种去一次再也不想去的地方，来回1400多个弯！。在快离开山区时，我们在路边买了芒果。半斤重的一个大芒果，折合成人民币仅需1元！买不了吃亏，买不了上当！</p><p>差不多四点多，我们到达玛雅购物中心。从玛雅购物中心步行至平那科酒店大概需要20分钟，在回酒店的路上，看到街边有家店叫“我爱冬阴功”，看着似乎还不错，便进去点了餐。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand095.png" alt=""></div> <h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p><strong>6月7日，周二</strong><br>在清迈这几天每天都是起早，今天准备放松一下，自由发挥。吃完早餐便租了摩托车，准备从古城西边出发，经过北部，再至东部，最后从古城东门穿越古城返回。清迈的道路真的令人很痛苦，大量的单行单，我们从古城东北角南下时基本都是在单行道上逆行。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand096.png" alt=""></div> <p>好不容易在中午抵达古城，在一个寺庙对面找了家餐馆就餐，一份芒果糯米饭，一份冬阴功汤。期间，又下起了太阳雨。好在我们吃完，雨也停了。  </p><p>清迈的下午艳阳高照，我们还是决定回酒店等到傍晚再出来。待到6点多，我们赶到古城北部的凤飞飞猪脚饭餐馆，毕竟这家店也算是名声在外。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand097.png" alt=""></div> <h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p><strong>6月8日，周三</strong><br>凌晨4点起床，因为要赶6点50的航班，飞往甲米。在前台刚刚退完房，门口的送机小哥就迎了上来，非常准时，靠谱！为了感激小哥半夜起床给我们送机，我们也给了他20B，以示感激。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand098.png" alt=""></div> <p>出了甲米机场之后，便步行了大概300米，来到minivan的候车点。大约1点半，minivan准时出现在候车的凉亭前面。Minivan中已经是满满一车人了，我们坐在最后面，虽然长途奔波很是难受，但是相比于拜县的旅程真的无比轻松了。行车1个半小时后便来到了兰塔岛的海峡入口处，经历半小时的车船联运后，抵达兰塔岛。司机依次运送乘客，我们车船联运后20分钟抵达CoCo Lanta Resort。</p><p>到达酒店，前台便是热情招待，递上两杯橙汁。CoCo Lanta的房间都是一个个的独栋小别墅。我们入住时发现只有很少的游客入住了，也许是淡季的原因吧。说实话，我们当时是有些后悔来到兰塔岛的。因为与清迈相比，这里显得十分凄凉，酒店附属的酒吧处于休业中，泳池边的遮阳伞都是收着的，躺椅、泳池也没有人。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand099.png" alt=""></div> <p>经过一天的奔波，再加上心理预期上的落差，当时的心情是非常低落的，晚饭也没不想去那个酒店的餐厅去吃，转而去了附近的一家711超市买了泡面，零食等。傍晚，在海边稍许逛了一会，心情也有所复苏。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand100.jpg" alt=""></div> <h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p><strong>6月9日，周四</strong><br>早晨9点匆忙来到前台大厅，等待今天出海一日游的minivan。上了车之后没多久便来到了汽艇停靠的港口。港口中泊着一艘红色汽艇，汽艇上的工作人员都很酷，黑皮肤（当然是亚洲人）、黑墨镜、反鸭舌。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand101.png" alt=""></div> <p>汽艇在驶出海湾过程中经过静谧美丽的兰塔红树林，导游说红树林里有猴子，但是我们运气不够好，没遇到。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand102.png" alt=""></div> <p>大约10点，到达Talabeng岛。汽艇靠近海蚀洞穴，以便大家游至洞穴中去。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand103.png" alt=""></div> <p>探索完海蚀洞穴后，汽艇来到了BUBU岛。在BUBU岛沙滩自由浮潜20分钟。  </p><p>之后便前往奈岛，奈岛是这几个岛中最美的岛屿。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand104.png" alt=""></div> <p>靠近奈岛近海处，导游便带领我们下海浮潜。浮潜了大约半小时，便上岸就餐。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand105.png" alt=""></div> <p>午餐过后便是1个半小时的海滩休闲时光。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand106.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand107.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand108.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand109.png" alt=""></div> <p>1点多，我们离开美丽的奈岛，前往MA岛和CHUEK岛，在汽艇上欣赏海岛屿风光。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand110.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand111.png" alt=""></div> <p>汽艇在海上漂游时，偶然发现一片海域的水特别清澈，于是导游带领我们下海浮潜。这里的珊瑚礁特别美丽，由各种色彩斑斓的海鱼，还有海胆。可惜没有租用GoPro进行水下摄影。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand112.png" alt=""></div> <p>一段美妙的浮潜之旅结束了本次出海。早晨汽艇从兰塔岛的东岸南下，返程从兰塔岛的西岸飞驰回港。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand113.png" alt=""></div> <h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><p><strong>6月10日，周五</strong><br>今天的计划是环岛游。早晨睡个懒觉起床，然后到海滩吹了一下海风。  </p><p>到了10点半左右，从酒店租了辆摩托车，价格要比清迈便宜，只要200B一天。我们的目的是前往老镇吃海鲜。  </p><p>CoCo Lanta Resort在兰塔岛的西岸中部，老镇则在兰塔岛的东岸南部。摩托一路狂奔，花了一个小时抵达老镇。我们寻找昨天同行游客推荐的Fresh Restaurant。餐厅很不错，架在海上。我们选了一个临海的餐桌就座。服务员递上菜单，菜单上菜品的价格相对北京的海鲜价位而言是比较便宜的。显然，来到海岛当然是点海鲜咯。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand114.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand115.png" alt=""></div> <p>饭后，我们来到了餐厅旁边的小港口转了转。之后便前往兰塔岛最南部的灯塔，一路上的山路蜿蜒陡峭，并且道路边树林密布。随着行程的深入，道路原来越窄，车辆也没了。后来开到大路的尽头，还没到达灯塔，我们便掉头回去。昨天那位游客也说路上很阴森很可怕，的确属实。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand116.png" alt=""></div> <p>傍晚照例先去了711超市，然后回来煮泡面。不同的是，今晚是在海边吃的泡面。看着日落，迎着海风，惬意的傍晚。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand117.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand118.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand119.png" alt=""></div> <p>夜色渐浓，想到远离灯火的海边是绝佳的观星地点。于是，下载了一个“星空”APP，对照着星空寻找星座，狮子座、半人马座、室女座、天平座、大熊座（含北斗七星）、天蝎座…</p><h1 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h1><p><strong>6月11日，周六</strong><br>这是在岛上最后完整的一天，准备在海边度过。  </p><p>早上来到海边，躺椅上有个五六十岁大爷主动与我们搭话：是中国人吗？之后便与他侃了起来，大爷还给我散烟，我委婉地拒绝了，后来便跟他推荐一些岛上的景点。直到11点，大爷包的车来了，海边这块地便被我占领了。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand120.png" alt=""></div> <p>午饭过后，一直在海滩边躺着，期间还打了个盹儿。  </p><video src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/videos/video-tailand001.mp4" type="video/mp4" controls="controls" width="100%" height="100%"><br></video><p>直到下午4点多，海水逐渐退去，近海的礁石都显露了出来。此时是在浅海中玩耍的好时机。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand121.png" alt=""></div> <p>临近黄昏，我们在酒店的餐厅点了一份冬阴功面、炒饭、炸软壳蟹，靠着栏杆，欣赏落日的余晖。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand122.png" alt=""></div><br><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand123.png" alt=""></div> <p>落日之后，便躺在海滩边的吊床中享受在兰塔最后的休暇时光。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand124.png" alt=""></div> <h1 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h1><p><strong>6月12日，周日</strong><br>今天将离开兰塔岛，早上去海滩看了最后一眼清晨的大海，将要离开时总会不舍，希望我们还能再见。  </p><p>再见，CoCo。<br>再见，Lanta。<br>再见，Tailand。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand125.png" alt=""></div> <p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
      <category term="旅行" scheme="http://chuquan.me/categories/%E6%97%85%E8%A1%8C/"/>
    
    
      <category term="游记" scheme="http://chuquan.me/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="自由行" scheme="http://chuquan.me/tags/%E8%87%AA%E7%94%B1%E8%A1%8C/"/>
    
      <category term="兰塔岛" scheme="http://chuquan.me/tags/%E5%85%B0%E5%A1%94%E5%B2%9B/"/>
    
      <category term="清迈" scheme="http://chuquan.me/tags/%E6%B8%85%E8%BF%88/"/>
    
  </entry>
  
  <entry>
    <title>20个强大的Sublime Text插件</title>
    <link href="http://chuquan.me/2017/05/12/powerful-sublimetext-pulgin/"/>
    <id>http://chuquan.me/2017/05/12/powerful-sublimetext-pulgin/</id>
    <published>2017-05-12T14:33:10.000Z</published>
    <updated>2018-02-09T03:29:15.202Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://inspiretrends.com/20-powerful-sublimetext-plugins/" target="_blank" rel="noopener">原文链接</a><br>SublimeText是一款非常精巧的文本编辑器，适合编写代码、做笔记、写文章。它用户界面十分整洁，功能非同凡响，性能快得出奇。这些非常棒的特性包括：  </p><ul><li>任意跳转（Goto Anything）  </li><li>多重选择（multiple selections）</li><li>指令面板（command palette）  </li><li>免打扰模式（distraction free mode）  </li><li>分区编辑（split editing）  </li><li>快速项目切换（instant project switch）  </li><li>…<br>此外，你还可以随意地自定义更多功能。更重要的是，Sublime支持Mac、Windows和Linux等多种系统平台。  </li></ul><p>SublimeText本身已经非常强大，但是更棒的是还有大量的插件支持它，给它带来更强大的功能，这就是本文要讨论的内容。不多废话，让我们看看20个强大的SublimeText插件。  </p><h1 id="20-FTPsync"><a href="#20-FTPsync" class="headerlink" title="20 FTPsync"></a>20 <a href="https://github.com/NoxArt/SublimeText2-FTPSync" target="_blank" rel="noopener">FTPsync</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin001.gif" alt=""></div>  <p>默认情况下SublimeText不具备FTP功能，如果你正在寻找能在你的SublimeText应用程序中使用的免费易用的FTP工具，你可以考虑FTPSync。这是一个非常简单的FTP同步工具，它可以控制上传目标的多重命名。  </p><h1 id="19-SASS-Build"><a href="#19-SASS-Build" class="headerlink" title="19 SASS Build"></a>19 <a href="https://github.com/jaumefontal/SASS-Build-SublimeText2" target="_blank" rel="noopener">SASS Build</a></h1><hr><p>SASS Build 是一个编写CSS的预处理器。这个插件可以帮助你妥善构建包括压缩选项在内的SASS文件。一旦你安装了这个插件，你可以很容易地通过按Ctrl+ B（MAC系统是 Command +B）来启动它。  </p><h1 id="18-Package-Control"><a href="#18-Package-Control" class="headerlink" title="18 Package Control"></a>18 <a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">Package Control</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin002.gif" alt=""></div>  <p>简而言之，这个是你在完成安装SublimeText后必须安装的东西。因为有了这个特殊的“插件”，你可以很容易地安装、升级、删除，甚至非常方便地查看你已经安装在SublimeText中的包或插件的列表。它通过菜单和对应的行为使这些过程变得非常容易和有组织。  </p><h1 id="17-Emmet"><a href="#17-Emmet" class="headerlink" title="17 Emmet"></a>17 <a href="https://emmet.io/" target="_blank" rel="noopener">Emmet</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin003.gif" alt=""></div>  <p>Emmet（前身是大名鼎鼎的Zen Coding）是一个可以让你更快更高效地编写HTML和CSS，节省你大量时间的插件。你只需按约定的缩写形式书写而不用写整个代码，然后按“扩展”键，这些缩写就会自动扩展为对应的代码内容。 比如，你只需要输入 ((h4&gt;a[rel=external])+p&gt;img[width=500 height=320])*12 ，然后它会被扩展转换成12个列表项和紧随其后的图像。然后你就可以在此基础上再填写内容，就这么简单。  </p><h1 id="16-SublimeLinter"><a href="#16-SublimeLinter" class="headerlink" title="16 SublimeLinter"></a>16 <a href="https://github.com/titoBouzout/SideBarEnhancements/tree/st3" target="_blank" rel="noopener">SublimeLinter</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin004.gif" alt=""></div>  <p>这个插件最近才为SublimeText3重建和发布。新版本带来了很多新的功能，而不是简单地把所有的Linter放在一个包中，开发者允许用户在升级时选择并安装自己经常使用的Linter。很明显，这可以节省磁盘空间。“更多的定制”，这对用户是很友好的。  </p><h1 id="15-SublimeEnhancements"><a href="#15-SublimeEnhancements" class="headerlink" title="15 SublimeEnhancements"></a>15 <a href="https://github.com/titoBouzout/SideBarEnhancements/tree/st3" target="_blank" rel="noopener">SublimeEnhancements</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin005.gif" alt=""></div>  <p>这个插件可以给SublimeText的边栏菜单带来扩充的功能，包括：在当前工程文件夹中新建文件，移动文件或文件夹，产生文件或文件夹的副本，在新窗口或浏览器中打开，刷新等。这只是概括地说，安装后探索它更多的功能吧。</p><h1 id="14-PackageResourceViewer"><a href="#14-PackageResourceViewer" class="headerlink" title="14 PackageResourceViewer"></a>14 <a href="https://github.com/skuroda/PackageResourceViewer" target="_blank" rel="noopener">PackageResourceViewer</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin006.gif" alt=""></div>  <p>通过这个特殊的插件，会给你查看和编辑SublimeText附带的不同的包带来很多方便。你也可以提取任何给定的包。这一行动将其复制到用户文件夹，以便你可以安全地对其进行编辑。</p><h1 id="13-Git"><a href="#13-Git" class="headerlink" title="13 Git"></a>13 <a href="https://github.com/kemayo/sublime-text-git" target="_blank" rel="noopener">Git</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin007.gif" alt=""></div>  <p>虽然名字看上去并不友好，但作为开发者的你肯定一眼就能明白它是干什么的。这个插件会将Git整合进你的SublimeText，使的你可以在SublimeText中运行Git命令，包括添加，提交文件，查看日志，文件注解以及其它Git功能。  </p><h1 id="12-Terminal"><a href="#12-Terminal" class="headerlink" title="12 Terminal"></a>12 <a href="https://github.com/wbond/sublime_terminal" target="_blank" rel="noopener">Terminal</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin008.gif" alt=""></div>  <p>这个插件可以让你在Sublime中直接使用终端打开你的项目文件夹，并支持使用快捷键。</p><h1 id="11-CSSComb"><a href="#11-CSSComb" class="headerlink" title="11 CSSComb"></a>11 <a href="http://csscomb.com/" target="_blank" rel="noopener">CSSComb</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin009.gif" alt=""></div>  <p>这是用来给CSS属性进行排序的格式化插件。如果你想保持的代码干净整洁，并且希望按一定的顺序排列，那么这个插件是一种有效解决的方案。特别是当你和其他有自己代码编写风格的开发者一同协作的时候。</p><h1 id="10-CanIUse"><a href="#10-CanIUse" class="headerlink" title="10 CanIUse"></a>10 <a href="http://timkl.xyz/sublime-text-caniuse/" target="_blank" rel="noopener">CanIUse</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin010.gif" alt=""></div>  <p>如果你想检查浏览器是否支持你包括在你的代码中的CSS和HTML元素，那么这是你需要的插件。所有你需要做的就是选择有疑问的元素，插件将为你做其余的事情。</p><h1 id="9-Alignment"><a href="#9-Alignment" class="headerlink" title="9 Alignment"></a>9 <a href="https://github.com/wbond/sublime_alignment" target="_blank" rel="noopener">Alignment</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin011.gif" alt=""></div>  <p>这个插件让你能对齐你的代码，包括 PHP、CSS 和 Javascript。代码看起来更简洁和可读，便于编辑。您可以查看下面的图片来明白我说的意思。</p><h1 id="8-Trimmer"><a href="#8-Trimmer" class="headerlink" title="8 Trimmer"></a>8 <a href="https://github.com/jonlabelle/Trimmer" target="_blank" rel="noopener">Trimmer</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin012.gif" alt=""></div>  <p>你知道当你编写代码时，由于错误或别的某些原因，会产生一些不必要的空格。需要注意的是多余的空格有时也会造成错误。这个插件会自动删除这些不必要的空格。</p><h1 id="7-ColorPicker"><a href="#7-ColorPicker" class="headerlink" title="7 ColorPicker"></a>7 <a href="http://weslly.github.io/ColorPicker/" target="_blank" rel="noopener">ColorPicker</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin013.gif" alt=""></div>  <p>如果你经常要查看或设置颜色值，这个插件可以很方便地调用你本机的调色板应用。这是一个双向的功能，你既可以在调色板中选择一个颜色，然后按“确定”按钮把该值填写到 SublimeText 中活动文档的当前位置，也可以在活动文档中选择一个颜色的值，按此插件的快捷键就会在显示的调色板中定位到该值所对应的颜色。</p><h1 id="6-MarkdownEditing"><a href="#6-MarkdownEditing" class="headerlink" title="6 MarkdownEditing"></a>6 <a href="https://github.com/SublimeText-Markdown/MarkdownEditing" target="_blank" rel="noopener">MarkdownEditing</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin014.gif" alt=""></div>  <p>SublimeText不仅仅是能够查看和编辑 Markdown 文件，但它会视它们为格式很糟糕的纯文本。这个插件通过适当的颜色高亮和其它功能来更好地完成这些任务。</p><h1 id="5-FileDiffs"><a href="#5-FileDiffs" class="headerlink" title="5 FileDiffs"></a>5 <a href="https://github.com/colinta/SublimeFileDiffs" target="_blank" rel="noopener">FileDiffs</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin015.gif" alt=""></div>  <p>这个插件允许你看到SublimeText中两个不同文件的差异。你可以比较的对象可以是从剪贴板中复制的数据，或工程中的文件，当前打开的文件等。</p><h1 id="4-DocBlock"><a href="#4-DocBlock" class="headerlink" title="4 DocBlock"></a>4 <a href="https://github.com/spadgos/sublime-jsdocs" target="_blank" rel="noopener">DocBlock</a></h1><hr><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin016.gif" alt=""></div>  <p>DocBlockr 可以使你很方便地对代码建立文档。它会解析函数，变量，和参数，根据它们自动生成文档范式，你的工作就是去填充对应的说明。</p><h1 id="3-定制主题"><a href="#3-定制主题" class="headerlink" title="3 定制主题"></a>3 定制主题</h1><hr><p>拥有不同的主题可以触发创意和想法，你可能想使用这些插件来实现不同的主题，带来更好的和令人兴奋的前景。</p><h2 id="SpaceGray"><a href="#SpaceGray" class="headerlink" title="SpaceGray"></a><a href="https://github.com/kkga/spacegray/" target="_blank" rel="noopener">SpaceGray</a></h2><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin017.gif" alt=""></div>  <h2 id="Centurion"><a href="#Centurion" class="headerlink" title="Centurion"></a><a href="https://github.com/allanhortle/Centurion" target="_blank" rel="noopener">Centurion</a></h2><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin018.gif" alt=""></div>  <h1 id="2-Snippets"><a href="#2-Snippets" class="headerlink" title="2 Snippets"></a>2 Snippets</h1><hr><p>Snippets，你一定已经听说了，可以帮你快速书写代码。但它不是像上面提到的插件那样使用缩写，它是重用代码块以节省您的时间。你甚至可以创建自己的代码段，这完全取决于你自己。</p><h1 id="1-语法支持"><a href="#1-语法支持" class="headerlink" title="1 语法支持"></a>1 语法支持</h1><hr><p>如果有一个SublimeText本身所带语言包不包含的语言，它就无法显示适当的语法高亮。这些语言包括LESS，Sass，SCSS，Styls和Jade（或其它）。如果您正在使用这些语言，你可能要安装它们的语法插件。</p><ul><li><a href="https://github.com/danro/LESS-sublime" target="_blank" rel="noopener">LESS</a></li><li><a href="https://github.com/nathos/sass-textmate-bundle" target="_blank" rel="noopener">Sass</a></li><li><a href="https://github.com/MarioRicalde/SCSS.tmbundle" target="_blank" rel="noopener">SCSS</a></li><li><a href="https://github.com/billymoon/Stylus" target="_blank" rel="noopener">Stylus</a></li><li><a href="https://github.com/P233/Jade-Snippets-for-Sublime-Text-2" target="_blank" rel="noopener">Jade</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://inspiretrends.com/20-powerful-sublimetext-plugins/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;SublimeText是一款非常精巧的文本编辑器，适
      
    
    </summary>
    
      <category term="翻译" scheme="http://chuquan.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Sublime Text" scheme="http://chuquan.me/tags/Sublime-Text/"/>
    
      <category term="插件" scheme="http://chuquan.me/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>IT面试整理(5)——前端综合</title>
    <link href="http://chuquan.me/2017/05/01/it-interviews005/"/>
    <id>http://chuquan.me/2017/05/01/it-interviews005/</id>
    <published>2017-05-01T12:54:29.000Z</published>
    <updated>2018-02-07T05:08:33.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a><strong>XSS攻击</strong></h2><hr><ul><li>原理: 攻击者往web页面里插入恶意html标签或者javascript代码</li><li>示例: 攻击者在论坛中放一个看似安全的连接，骗取用户点击后，窃取cookie中用户私密信息；</li><li>防范:<br>  (1) 对用户输入的地方和变量要检查长度、对”&lt;”, “&gt;”, “;”, “‘“等字符过滤<br>  (2) 任何内容写入页面之前必须加以encode，避免不小心把html tag弄出来<br>  (3) 避免直接在cookie中泄漏用户隐私，如email、密码等<br>  (4) 通过cookie和系统ip绑定来降低cookir泄漏后的风险<br>  (5) 尽量采用POST而非GET提交表单</li></ul><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a><strong>CSRF攻击</strong></h2><hr><ul><li>原理: XSS是CSRF的一种实现方式。但XSS是获取信息，不用提前知道用户的页面代码和数据包；CSRF是代替用户完成指定的动作，需要知道用户页面的代码和数据包</li><li>示例: 1. 登陆受信任网站A，并在本地生成cookie；2. 在不登出A的情况下访问危险网站B</li><li>防范:<br>  (1) 在客户端增加伪随机数<br>  (2) 使用验证码  </li></ul><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><strong>SQL注入</strong></h2><hr><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a><strong>AJAX</strong></h2><hr><p>(1) 创建XMLHttpRequest对象，即异步调用对象<br>(2) 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL以及验证信息<br>(3) 设置响应HTTP请求状态变化的函数<br>(4) 发送HTTP请求<br>(5) 获取异步调用返回的数据<br>(6) 使用Javascript和DOM实现局部刷新</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a><strong>JSONP</strong></h2><hr><ul><li><p>原理<br>  利用script标签没有跨域限制的”漏洞”来达到与第三方通信的目的。当本站需要通信时，本站脚本创建一个script元素，地址指向第三方的API，形如:   </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://www.example.net/api?param1=1&amp;param2=2"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>  并提供了一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。<br>  第三方产生的响应为json数据的包装(json with padding)，形如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;<span class="string">"name"</span>: <span class="string">"baochuquan"</span>, <span class="string">"gender"</span>: <span class="string">"male"</span>&#125;);</span><br></pre></td></tr></table></figure><p>  这样浏览器就会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。</p></li></ul><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h2><hr><p>CORS与同源AJAX通信没有差别。关键是需要服务器支持CORS接口。</p><ul><li>简单请求<ul><li>条件<br>  (1) 请求方法<pre><code>- HEAD- GET- POST</code></pre>  (2) HTTP头信息超出以下几种字段<pre><code>- Accept- Accept-Language- Content-Language- Last-Event-ID- Content-Type: (只限于application/x-www-form-urlencodeed、multipart/formdata、text/plain)</code></pre></li><li>请求<br>  浏览器发现此次跨域AJAX请求是简单请求，自动在头信息中添加Origin字段。</li><li>响应<br>  (1) Access-Control-Allow-Origin: 必须(*或请求时Origin字段的值)<br>  (2) Access-Control-Allow-Credentials: 可选(是否允许发送cookie)<br>  (3) Access-Control-Expose-Headers: 可选(cache, )</li></ul></li></ul><h2 id="跨域的方法【参考】"><a href="#跨域的方法【参考】" class="headerlink" title="跨域的方法【参考】"></a><strong>跨域的方法</strong><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li><p>二级域名不同<br>  (1) Cookie  </p><pre><code>两个网页一级域名相同，二级域名不同，浏览器允许通过设置document.domain共享cookie。服务器可设置cookie所属域名document.domain = &apos;example.com&apos;document.cookie = &apos;key=value&apos;   </code></pre><p>  (2) iframe</p><pre><code>类似cookie, 一级域名相同，二级域名不同，可以通过浏览器设置document.domain共享相互获取DOM父窗口获取子窗口: document.getElementById(&quot;iframe&quot;)子窗口获取父窗口: window.parent.document.body  </code></pre></li><li><p>完全非同源<br>  (1) 片段标识符(URL#之后的部分)</p><pre><code>父窗口写子窗口: document.getElementById(&apos;iframe&apos;).src = originURL +&apos;#&apos; + data;子窗口写父窗口: parent.location.href = target + &apos;#&apos; + data;</code></pre><p>  (2) window.name</p><pre><code>同一个标签页window.name = datalocation = &apos;http://newurl.com&apos;windodw.name / var data = document.getElementById(&apos;iframe&apos;).contentWindow.name</code></pre><p>  (3) window.postMessage</p><pre><code>var popup = window.open(url);popup.postMessge(data, url);</code></pre><p>  (4) localStorage</p><pre><code>通过window.postMessage来操作localStorage</code></pre><p>  (5) JSONP(只能是GET请求)</p><pre><code>网页通过添加一个&lt;script&gt;元素向服务器请求JSON数据；服务器收到请求后将数据放在一个指定名的回调函数中传回来</code></pre><p>  (6) WebSocket</p><pre><code>WebSocket是一种通信协议，使用ws://(非加密)和wss://(加密)作为协议前缀，不实行同源策略，只要服务器支持即可进行跨域通信。服务器根据请求中的Origin字段判断请求源。</code></pre><p>  (7) CORS(可以是任何请求类型)</p><pre><code>和同源的AJAX一样。关键是需要服务器实现CORS接口。</code></pre><p>  (8) 设置服务器代理页面   </p></li></ul><h2 id="cookie、session"><a href="#cookie、session" class="headerlink" title="cookie、session"></a><strong>cookie、session</strong></h2><hr><ul><li>cookie数据存放在浏览器上；session数据存放在服务器上；</li><li>cookie安全性低；session相对安全；</li><li>单个cookie保存的数据不能超过4KB，很多浏览器会限制一个站点只能保存20个cookie</li><li>session会在一定时间内保存在服务器上。当访问增多，会占用服务器的性能</li></ul><h2 id="cookie、sessionStorage、localStorage"><a href="#cookie、sessionStorage、localStorage" class="headerlink" title="cookie、sessionStorage、localStorage"></a><strong>cookie、sessionStorage、localStorage</strong></h2><hr><table><thead><tr><th>特性</th><th>cookie</th><th>localStorage</th><th>sesstionStorage</th></tr></thead><tbody><tr><td>数据生命周期</td><td>可设置失效时间，默认关闭浏览器后失效</td><td>除非被清除，否则永久保存</td><td>仅在当前会话（当前标签页）下有效，关闭页面或浏览器后被清除</td></tr><tr><td>数据容量大小</td><td>4KB左右</td><td>一般为5MB</td><td>一般为5MB</td></tr><tr><td>与服务器端通信</td><td>每次都会携带在HTTP头中</td><td>仅在客户端中保存</td><td>仅在客户端中保存</td></tr></tbody></table><h2 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信"></a><strong>如何实现浏览器内多个标签页之间的通信</strong></h2><hr><ul><li>cookie、locaStorage</li><li>sessionStorage只能在一个标签页内传值</li></ul><h2 id="Get、Post的区别"><a href="#Get、Post的区别" class="headerlink" title="Get、Post的区别"></a><strong>Get、Post的区别</strong></h2><hr><p>GET: 向服务器请求数据，请求可在url中；长度有限(2KB)<br>POST: 向服务器提交数据，每次刷新或后退会重新提交，Post请求数据封装在http请求的首部里</p><h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a><strong>viewport</strong></h2><hr><h2 id="JS延迟加载的方式"><a href="#JS延迟加载的方式" class="headerlink" title="JS延迟加载的方式"></a><strong>JS延迟加载的方式</strong></h2><hr><pre><code>defer、async、动态创建DOM方式（JSONP）、AJAX</code></pre><h2 id="JS阻塞特性"><a href="#JS阻塞特性" class="headerlink" title="JS阻塞特性"></a><strong>JS阻塞特性</strong></h2><hr><p>所有浏览器在下载JS时，会阻止一切活动，如其他资源的下载、内容的呈现等。<br>直到JS下载、解析、执行完毕才开始继续并行下载其他资源并呈现内容。</p><h2 id="JS无阻塞加载具体方式"><a href="#JS无阻塞加载具体方式" class="headerlink" title="JS无阻塞加载具体方式"></a><strong>JS无阻塞加载具体方式</strong></h2><hr><p>(1) 将脚本放在底部<br>    link放在head中；script标签放在/body前<br>(2) 成组脚本<br>    限制页面的script总数。是用于内嵌脚本和外部脚本<br>(3) 非阻塞脚本<br>    等页面加载完后，再加载JS代码  </p><h2 id="XML、JSON的区别"><a href="#XML、JSON的区别" class="headerlink" title="XML、JSON的区别"></a><strong>XML、JSON的区别</strong></h2><hr><table><thead><tr><th>特性</th><th>XML</th><th>JSON</th></tr></thead><tbody><tr><td>数据体积</td><td>大</td><td>小</td></tr><tr><td>数据交互</td><td>较复杂</td><td>易解析</td></tr><tr><td>数据描述</td><td>好</td><td>差</td></tr><tr><td>传输速度</td><td>慢</td><td>快</td></tr></tbody></table><h2 id="减少页面加载时间的方法"><a href="#减少页面加载时间的方法" class="headerlink" title="减少页面加载时间的方法"></a><strong>减少页面加载时间的方法</strong></h2><hr><p>(1) 优化图片<br>(2) 图像格式的选择（GIF: 提供的颜色少，可用在一些对颜色要求不高的地方）<br>(3) 优化CSS（压缩合并CSS）<br>(4) 网址后加斜杠（www.example.com/目录，会判断）<br>(5) 表明高度和宽度<br>(6) 减少HTTP请求（合并文件、合并图片）</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h2><hr><p>一种新的协议(ws)，允许服务器和浏览器端进行全双工通信</p><h2 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a><strong>SSE</strong></h2><hr><p>一种轻量级的协议，基于HTTP，浏览器向服务器发送一个HTTP请求，然后 服务器不断单向地向浏览器推送信息</p><h2 id="Comet【参考】"><a href="#Comet【参考】" class="headerlink" title="Comet【参考】"></a><strong>Comet</strong><a href="http://www.ibm.com/developerworks/cn/web/wa-lo-comet/" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>定义: 基于HTTP长连接的“服务器推”技术</li><li>实现模型<br>  (1) 基于AJAX的长轮询方式<pre><code>1. 服务器会阻塞请求直到有数据传递或超时才返回2. 客户端JS响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接3. 当客户端处理接收的数据、重新建立连接时，服务器端可能有新数据到达；这些信息会被服务器端保存直到客户端重新建立连接，客户端一次取回当前服务器端所有的信息</code></pre>  (2) 基于iframe以及htmlfile的流方式<pre><code>1. 在HTML中嵌入一个隐藏的iframe，将其src属性设为对一个长连接的请求，服务器就能源源不断地往客户端输入数据  2. 服务器端返回对客户端JS函数的调用，类似于JSONP缺点：某些浏览器下端的进度栏显示加载未完成，且标签页图标旋转——采用htmlfile解决</code></pre></li></ul><h2 id="服务器推送的方式"><a href="#服务器推送的方式" class="headerlink" title="服务器推送的方式"></a><strong>服务器推送的方式</strong></h2><hr><p>(1) Comet：基于HTTP长连接的服务器推送技术<br>(2) 基于WebSocket的推送方案<br>(3) SSE：服务器推送数据新方式</p><h2 id="预加载、懒加载（延迟加载）【参考】"><a href="#预加载、懒加载（延迟加载）【参考】" class="headerlink" title="预加载、懒加载（延迟加载）【参考】"></a><strong>预加载、懒加载（延迟加载）</strong><a href="http://www.cnblogs.com/Leo_wl/p/3526254.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>懒加载（延迟加载）<ul><li>原理: 延迟加载图片或符合某些条件时才加载某些图片</li><li>意义: 作为服务器前端的优化，减少请求数或延迟请求数</li><li>实现方式<br>  (1) 纯粹的延迟加载，使用setTimeout或setInterval进行加载延迟<br>  (2) 条件加载，符合某些条件，或触发了某些事件才开始异步下载<br>  (3) 可视区加载，即仅加载用户可以看见的区域，一般会在距用户看到某些图片前一定距离就开始加载</li></ul></li><li>预加载<ul><li>原理: 提前加载图片，当用户需要查看时可以直接从本地缓存中渲染</li><li>意义: 牺牲服务器前端性能，换取更好的用户体验</li><li>实现方式<br>  (1) CSS(background)<br>  (2) JS(image)<br>  (3) HTML(<img>)</li></ul></li></ul><h2 id="渐进增强、优雅降级"><a href="#渐进增强、优雅降级" class="headerlink" title="渐进增强、优雅降级"></a><strong>渐进增强、优雅降级</strong></h2><hr><ul><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li><li>优雅降级: 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul><h2 id="浏览器缓存【参考01】【参考02】"><a href="#浏览器缓存【参考01】【参考02】" class="headerlink" title="浏览器缓存【参考01】【参考02】"></a><strong>浏览器缓存</strong><a href="https://segmentfault.com/a/1190000004486640" target="_blank" rel="noopener">【参考01】</a><a href="https://segmentfault.com/a/1190000005704489" target="_blank" rel="noopener">【参考02】</a></h2><hr><ul><li>定义: 浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器可以直接从本地磁盘加载文档。  </li><li>优点<br>  (1) 减少了冗余的数据传输<br>  (2) 减少了服务器的负担<br>  (3) 加快了客户端加载网页的速度</li><li>分类<ul><li>缓存协商(协商缓存)  </li><li>彻底缓存(强缓存)  </li></ul></li><li>缓存启动过程(当浏览器在第一次请求发生之后，再次请求时)<br>  (1) 浏览器先获取该资源缓存的header信息，根据其中的expires和cache-control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；<br>  (2) 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息(Last-Modified/IF-Modified-Since、Etag/IF-None-Match)，由服务器根据请求中的相关header字段信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中对应的header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容  </li><li>强缓存<ul><li>原理: 利用http返回头中的Expires或者Cache-Control两个字段来控制，用来表示资源的缓存时间</li><li>Expires:  值为一个绝对时间的GMT格式的时间字符串。缺点在于浏览器端和服务器端的时间可能不一致</li><li>Cache-Control: 利用该字段的max-age值进行判断，即相对时间<ul><li>max-age=3600</li><li>no-cache: 不使用本地缓存。需要使用协商缓存</li><li>no-store: 直接禁止浏览器缓存数据，每次用户请求资源都是新下载</li><li>public: 可以被所有用户缓存，包括终端用户和CDN等中间代理服务器</li><li>private: 只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器缓存</li></ul></li></ul></li><li>协商缓存<ul><li>原理: 由服务器来确定缓存资源是否可用，所以需要标识来进行通信。第一次请求的响应头带上某个字段(Last-Modified货Etag)，后续请求会带上对应的请求字段(If-Modified-Since货If-None-Match)</li><li>Last-Modified: 一个时间标识该资源的最后修改时间</li><li>If-Modified-Since: 值为Lst-Modified</li><li>ETag: 检验码，保证每个资源都是唯一的</li></ul></li></ul><h2 id="移动端性能陷阱和硬件加速【参考】"><a href="#移动端性能陷阱和硬件加速【参考】" class="headerlink" title="移动端性能陷阱和硬件加速【参考】"></a><strong>移动端性能陷阱和硬件加速</strong><a href="http://blog.csdn.net/lifeblood123/article/details/52152576" target="_blank" rel="noopener">【参考】</a></h2><hr><p>(1) 减少或避免回流、重绘<br>(2) 尽量缓存所有可以缓存的数据<br>(3) 使用CSS3 transform代替DOM操作<br>(4) 不要给非static元素增加CSS3动画，浏览器的性能开销会成倍增加<br>(5) 适当使用硬件加速，如: canvas, transform</p><h2 id="前端优化规则【参考】"><a href="#前端优化规则【参考】" class="headerlink" title="前端优化规则【参考】"></a><strong>前端优化规则</strong><a href="https://segmentfault.com/a/1190000002667662" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>尽可能的减少 HTTP 的请求数</li><li>使用CDN（内容分发网络）</li><li>添加Expire/Cache-Control 头</li><li>启用Gzip压缩</li><li>将css放在页面最上面</li><li>将script放在页面最下面</li><li>避免在CSS中使用Expressions </li><li>把javascript和css都放到外部文件中</li><li>减少DNS查询</li><li>压缩 JavaScript 和 CSS</li><li>避免重定向 </li><li>移除重复的脚本</li><li>配置实体标签</li><li>使 AJAX 缓存</li></ul><h2 id="性能优化方式"><a href="#性能优化方式" class="headerlink" title="性能优化方式"></a><strong>性能优化方式</strong></h2><hr><p>(1) 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。<br>(2) 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数<br>(3) 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。<br>(4) 当需要设置的样式很多时设置className而不是直接操作style。<br>(5) 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。<br>(6) 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。<br>(7) 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。</p><h2 id="移动端性能优化"><a href="#移动端性能优化" class="headerlink" title="移动端性能优化"></a><strong>移动端性能优化</strong></h2><hr><p>(1) 尽量使用CSS3动画，开启硬件加速；<br>(2) 适当使用touch事件代替click事件<br>(3) 避免使用CSS3渐变阴影效果<br>(4) 尽可能少的使用box-shadow和gradient————性能杀手</p><h2 id="前端兼容性问题【参考1】【参考2】"><a href="#前端兼容性问题【参考1】【参考2】" class="headerlink" title="前端兼容性问题【参考1】【参考2】"></a><strong>前端兼容性问题</strong><a href="http://blog.csdn.net/chuyuqing/article/details/37561313" target="_blank" rel="noopener">【参考1】</a><a href="http://www.w3cfuns.com/notes/18090/961a36d50f2efa676061b5a02c374f75.html" target="_blank" rel="noopener">【参考2】</a></h2><hr><p>(1) XMLHttpRequest、ActiveXObject<br>(2) W3C盒子模型、IE盒子模型<br>(3) 不同浏览器的标签默认margin和padding不同</p><pre><code>- 解决方案: * { margin: 0; padding: 0; }</code></pre><p>(4) 块属性标签float后，又有横向的margin情况下，IE6显示margin比设置的大</p><pre><code>- 解决方案: 在float的标签样式控制中加入display: inline，将其转换为行内属性</code></pre><p>(5) 设置较小高度标签(一般小于10px)，在IE6中，IE7，遨游中高度超出自己设置的高度</p><pre><code>- 解决方案: 给超出高度的标签设置overflow: hidden; 或者设置行高line-height小于你设置的高度</code></pre><p>(6) 行内属性标签，设置display: block后采用float布局，又有横向margin的情况，IE6间距BUG</p><pre><code>- 解决方案: 在display: block;后面加入display:inline;display:table</code></pre><p>(7) 图片默认有间距</p><pre><code>- 解决方案: 使用float属性为img布局</code></pre><p>(8) 标签最低高度设置min-height</p><pre><code>- 解决方案: 如果要设置一个标签的最小高度为200px，需要进行的设置为: {min-height:200px; height:auto !important; height: 200px; overflow: visible; }</code></pre><p>(9) 透明度的兼容CSS设置</p><pre><code>- 解决方案: CSS hack    - 如: height: 300px; *height: 200px; _height: 100px;    - IE6认识的hacker: _, *；IE7、遨游认识的hacker: *</code></pre><p>(10) var e = e || window.event;<br>(11) document.documentElement.clientWidth || document.body.clientWidth<br>(12) var target = e.target || e.srcElement<br>(13) cursor: hand, cursor.pointer//firefox不支持hand</p><h2 id="viewport【参考】"><a href="#viewport【参考】" class="headerlink" title="viewport【参考】"></a><strong>viewport</strong><a href="http://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>定义: 设备的屏幕上能用来显示网页的那一块区域。viewport不局限于浏览器可视区域的大小，可以比浏览器的可视区域大，也可以比浏览器的可视区域小。默认情况下，移动设备上的viewport大于浏览器可视区域。  </li><li>CSS中的像素是一个抽象的单位，在不同的设备或不同的环境中，css中的1px代表的物理像素是不同的。</li><li>window.devicePixelRatio属性: 设备物理像素和设备独立像素的比例，即devicePixelRatio = 物理像素/独立像素。</li><li>三个viewport理论<br>  (1) layout viewport: 浏览器默认的viewport，可通过document.documentElement.clientWidth获取，默认大于浏览器可视区域的宽度<br>  (2) visual viewport: 代表浏览器的可视区域，可通过window.innerWidth获取，但在Android 2, Opera mini, UC无法获取<br>  (3) ideal viewport: 没有固定的尺寸，不同的设备具有不同的ideal viewport。所有的iphone的ideal viewport都是320px，无论屏幕宽度是320还是640，css中320px就代表iphone屏幕的宽度</li><li>利用meta标签对viewport进行控制<ul><li><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0 user-scalable=0"></li><li>meta viewport的6个属性<br>  (1) width: 设置layout viewport的宽度，为一个正整数，或字符串”width-device”<br>  (2) initial-scale: 设置页面初始缩放值，为一个数字，可以带小数，相对于ideal viewport进行缩放<br>  (3) minimum-scale: 允许用户的最小缩放值，为一个数字，可以带小数<br>  (4) maximum-scale: 允许用户的最大缩放值，为一个数字，可以带小数<br>  (5) height: 设置layout viewport的高度，很少使用<br>  (6) user-scalable: 是否允许用户进行缩放，值为“no”或“yes”，no代表不允许，yes代表允许</li></ul></li><li>把当前的viewport宽度设置为ideal viewport的宽度<ul><li><meta name="width=device-width" content="width=device-width"></li><li>visual viewport宽度 = ideal viewport宽度 / 当前缩放值 </li></ul></li></ul><h2 id="浏览器输入URL后发生了什么"><a href="#浏览器输入URL后发生了什么" class="headerlink" title="浏览器输入URL后发生了什么"></a><strong>浏览器输入URL后发生了什么</strong></h2><hr><p>(1) 输入URL<br>(2) 浏览器查找域名的IP地址（DNS具体查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存）<br>(3) 浏览器web服务器发送一个HTTP请求<br>(4) 服务器的永久重定向响应（从<a href="http://example.com到http://www.example.com）" target="_blank" rel="noopener">http://example.com到http://www.example.com）</a><br>(5) 浏览器跟踪重定向地址<br>(6) 服务器处理请求<br>(7) 服务器返回一个HTTP响应<br>(8) 浏览器显示HTML<br>(9) 浏览器发送请求获取嵌入在HTML中的资源（如图片、视频、音频、CSS、JS等）<br>(10) 浏览器发送异步请求</p><h2 id="浏览器结构"><a href="#浏览器结构" class="headerlink" title="浏览器结构"></a><strong>浏览器结构</strong></h2><h2 id=""><a href="#" class="headerlink" title="  "></a><img src="http://segmentfault.com/img/bVcTMw" alt="">  </h2><p>(1) User Interface 用户界面<br>    如：顶部(前进、后退、刷新、停止、地址栏、书签栏、状态栏、工具栏等)<br>    侧栏(滚动条)、底栏（滚动条）、开发工具、下拉菜单、下载管理等<br>(2) Browser Engine 浏览器引擎<br>    作用: 向上连接用户界面，向下连接渲染引擎，向右连接数据持久层<br>(3) Rendering Engine 渲染引擎（浏览器内核）  </p><pre><code>- 作用: 能显示HTML、XML和图片，并且通过一个插件可以显示其他类型资源，如PDF view显示PDF格式    - 常见的渲染引擎      - webkit: Safari、Chrome    - gecko: Firefox- 流程:       - 从网络层获取请求文档的内容，解析HTML/SVG/XHTML，形成DOM树  ；    - 解析CSS形成CSS规则树；      - 两者结合构成渲染树；        - 通过JS解释器解析脚本     - 最后通过UI后盾提供的接口绘出效果   </code></pre><p>(4) Networking</p><pre><code>- 作用: 用于网络调用，如HTTP、HTTPS   </code></pre><p>(5) Javascript Interpreter JS解释器   </p><pre><code>- 作用: 解析和运行JS  </code></pre><p>(6) UI Backend UI后端   </p><pre><code>- 作用: 用于绘制基本的部件</code></pre><p>(7) DATA Persistence 数据持久层 </p><pre><code>- 作用: 浏览器需要保存各种分类的数据在硬盘，例如cookies和HTML5的本地数据库等，都是通过这层来实现的  </code></pre><h2 id="浏览器的内核有哪些"><a href="#浏览器的内核有哪些" class="headerlink" title="浏览器的内核有哪些"></a><strong>浏览器的内核有哪些</strong></h2><hr><ul><li>Trident<ul><li>IE、傲游、世界之窗浏览器、Avant、腾讯TT、Netscape8、</li></ul></li><li>Gecko<ul><li>Firefox、Netscape6-9</li></ul></li><li>Webkit<ul><li>Safari、chrome</li></ul></li><li>Presto<ul><li>Opera</li></ul></li></ul><h2 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h2><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS攻击&quot;&gt;&lt;/a&gt;&lt;strong&gt;XSS攻击&lt;/strong&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;原理: 攻击者往web页面里插入恶意html标签或者java
      
    
    </summary>
    
      <category term="面试" scheme="http://chuquan.me/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://chuquan.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>IT面试整理(4)——Javascript</title>
    <link href="http://chuquan.me/2017/04/27/it-interviews004/"/>
    <id>http://chuquan.me/2017/04/27/it-interviews004/</id>
    <published>2017-04-27T12:31:59.000Z</published>
    <updated>2018-02-07T05:08:33.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网页、屏幕宽度、高度的获取"><a href="#网页、屏幕宽度、高度的获取" class="headerlink" title="网页、屏幕宽度、高度的获取"></a><strong>网页、屏幕宽度、高度的获取</strong></h2><hr><ul><li>屏幕分辨率的宽度: window.screen.width</li><li>屏幕分辨率的高度: window.screen.height</li><li>屏幕可用工作区宽度: window.screen.availWidth</li><li>屏幕可用工作区高度: window.screen.availHeight</li><li>网页被卷起的高度: document.body.scrollTop</li><li>网页被卷起的左边: document.body.scrollLeft</li><li>网页正文的全文宽: document.body.scrollWidth</li><li>网页正文的全文高: document.body.scrollHeight</li><li>网页可见区域宽度:  document.body.offsetWidth, document.body.clientWidth;</li><li>网页可见区域高度:  document.body.offsetHeight, document.body.clientHeight;</li></ul><h2 id="元素宽度、高度的获取【参考】"><a href="#元素宽度、高度的获取【参考】" class="headerlink" title="元素宽度、高度的获取【参考】"></a><strong>元素宽度、高度的获取</strong><a href="http://www.cnblogs.com/jscode/archive/2012/09/03/2669299.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>clientWidth: 标准盒模型的宽度(包含border)</li><li>offsetWidth: 对象的宽度(width+padding+border)</li><li>style.width: 行内式才能获取，包含px, %  </li><li>offsetLeft: 距离上层左边的距离</li><li>style.left: 可设置<br><img src="http://pic002.cnblogs.com/images/2012/389001/2012090315221723.gif" alt=""></li></ul><h2 id="property、attribute的区别"><a href="#property、attribute的区别" class="headerlink" title="property、attribute的区别"></a><strong>property、attribute的区别</strong></h2><hr><ul><li>相同之处<ul><li>标准的DOM properties与attributes是同步。</li><li>公认的（非自定义）特性被以属性的形式添加到DOM对象中，如: id, align, style</li></ul></li><li>不同之处<ul><li>对于有些标准的特性的操作，getAttribute()与点号(.)获取的值存在差异，如href、src、value、style、onclick等</li></ul></li><li>property(属性): property的值不会出现在html中，只保存在js中</li><li>attribute(特性): 只能是字符串，大小写不敏感，出现在innerHTML中</li></ul><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><strong>typeof</strong></h2><hr><ul><li>string</li><li>number</li><li>boolean</li><li>undefined</li><li>function</li><li>object</li></ul><h2 id="Javascript、Nodejs的区别"><a href="#Javascript、Nodejs的区别" class="headerlink" title="Javascript、Nodejs的区别"></a><strong>Javascript、Nodejs的区别</strong></h2><hr><ul><li>Javascript<ul><li>ECMAScript: 语言基础，如：语法、数据类型结构、内置对象</li><li>DOM: 操作页面元素的方法</li><li>BOM: 操作浏览器的方法</li></ul></li><li>Nodejs<ul><li>ECMAScript: 语言基础，如：语法、数据类型结构、内置对象</li><li>os: 操作系统</li><li>file: 文件系统</li><li>net: 网络系统</li><li>database: 数据库</li></ul></li></ul><h2 id="escape、encodeURI、encodeURIComponent"><a href="#escape、encodeURI、encodeURIComponent" class="headerlink" title="escape、encodeURI、encodeURIComponent"></a><strong>escape、encodeURI、encodeURIComponent</strong></h2><hr><ul><li>escape: 将字符的unicode编码转换成为16进制序列，不编码字符有69个<ul><li>如: *，+，-，.，/，@，_，0-9，a-z，A-Z</li></ul></li><li>encodeURI: 将字符的unicode编码转换成为UTF-8，不编码的字符有82个<ul><li>如: !，#，$，&amp;，’，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z</li></ul></li><li>encodeURIComponent: 将字符的unicode编码转换成为UTF-8，不编码的字符有71个<ul><li>如: !， ‘，(，)，*，-，.，_，~，0-9，a-z，A-Z</li></ul></li></ul><h2 id="stopropagtion-stopImmediatePropagation"><a href="#stopropagtion-stopImmediatePropagation" class="headerlink" title="stopropagtion(), stopImmediatePropagation()"></a><strong>stopropagtion(), stopImmediatePropagation()</strong></h2><hr><ul><li>stopPropagation(): 阻止事件在DOM中继续传播</li><li>stopImmediatePropagation(): 阻止同一个事件的其他监听函数被调用</li></ul><h2 id="DOMContentLoaded事件-readstatechange事件"><a href="#DOMContentLoaded事件-readstatechange事件" class="headerlink" title="DOMContentLoaded事件, readstatechange事件**"></a><em>DOMContentLoaded事件, readstatechange事件**</em></h2><hr><ul><li>DOMContentLoaded事件: 比load事件早，文档下载并解析完成(DOM生成)，所有外部资源可能还没下载结束</li><li>readystatechange事件: 发生在Document对象和XMLHttpRequest对象，当其readyState属性发生变化时触发</li></ul><h2 id="Javascript前缀命名规范"><a href="#Javascript前缀命名规范" class="headerlink" title="Javascript前缀命名规范"></a><strong>Javascript前缀命名规范</strong></h2><hr><ul><li>s: 表示字符串。如：sName，sHtml；</li><li>n: 表示数字。例如：nPage，nTotal；</li><li>b: 表示逻辑。例如：bChecked，bHasLogin；</li><li>a: 表示数组。例如：aList，aGroup；</li><li>r: 表示正则表达式。例如：rDomain，rEmail；</li><li>f: 表示函数。例如：fGetHtml，fInit；</li><li>o: 表示以上未涉及到的其他对象，例如：oButton，oDate；</li><li>g: 表示全局变量，例如：gUserName，gLoginTime；</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h2><hr><ul><li>原理: 当某个函数调用时会创建一个执行环境以及作用域链，然后根据arguments和其他命名参数初始化形成活动对象。当外部函数调用结束后，其执行环境与作用域链被销毁，但是其活动对象保存在了闭包之中，最后在闭包函数调用结束后才销毁。</li><li>实现: 在函数中定义函数，并且内部函数引用了外部函数的变量，最后内部函数被返回</li><li>特性<br>  (1) 函数嵌套函数<br>  (2) 函数内部可以引用外部的参数和变量<br>  (3) 参数和变量不会被垃圾回收机制回收</li></ul><h2 id="Javascript垃圾回收原理"><a href="#Javascript垃圾回收原理" class="headerlink" title="Javascript垃圾回收原理"></a><strong>Javascript垃圾回收原理</strong></h2><hr><p>(1) 如果一个对象不再被引用，那么对象会被GC回收<br>(2) 如果两个对象相互引用，且不被第三者引用，那么这两个对象会被回收</p><h2 id="call、apply"><a href="#call、apply" class="headerlink" title="call、apply"></a><strong>call、apply</strong></h2><hr><ul><li>其作用是可以改变其this的指向，其调用方式有所不同。  </li><li>call传递参数；apply传递数组</li></ul><h2 id="Javascript数据类型"><a href="#Javascript数据类型" class="headerlink" title="Javascript数据类型"></a><strong>Javascript数据类型</strong></h2><hr><ul><li>基本数据类型<ul><li>string</li><li>number</li><li>boolean</li></ul></li><li>引用数据类型<ul><li>object</li><li>array</li></ul></li><li>特殊数据类型<ul><li>null</li><li>undefined</li></ul></li></ul><h2 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a><strong>原型、原型链</strong></h2><hr><p>原型: 一个普通的对象，自带隐式的proto属性，原型也有自己的原型<br>原型链: 有一些用来继承和共享属性的对象组成的（有限的）对象链</p><h2 id="null、undefined"><a href="#null、undefined" class="headerlink" title="null、undefined"></a><strong>null、undefined</strong></h2><hr><p>null: 一个表示“无”的对象，转为数值时为0；<br>undefined: 一个表示“无”的原始值，转为数值时为NaN</p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><strong>this指针</strong></h2><hr><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a><strong>arguments</strong></h2><hr><h2 id="ES6新特性【参考】"><a href="#ES6新特性【参考】" class="headerlink" title="ES6新特性【参考】"></a><strong>ES6新特性</strong><a href="http://www.cnblogs.com/Wayou/p/es6_new_features.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>箭头操作符：=&gt;</li><li>类的支持：class</li><li>增强的对象字面量：</li><li>可以再对象字面量里定义原型</li><li>可以直接调用父类方法</li><li>定义方法可以不用function关键字</li><li>字符串模板：·your name is ${num}·</li><li>解构：自动解析数组或对象中的值</li><li>默认参数、不定参数、拓展参数</li><li>let、const关键字</li><li>for of：值遍历</li><li>模块：module</li><li>Map、Set、WeakMap、WeakSet</li><li>Proxies</li><li>Symbols</li><li>Math、Number、String、Object的新API</li><li>Promises</li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><strong>Promise</strong></h2><hr><p>Promise的四种状态<br>    (1) pending: 初始状态，非fulfilled或rejected<br>    (2) fulfilled: 成功的操作<br>    (3) rejected: 失败的操作<br>    (4) settled: Promise已经被fulfilled或rejected，且不是pending</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a><strong>严格模式</strong></h2><hr><ul><li>目的<br>  (1) 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为<br>  (2) 消除代码运行的一些不安全之处，保证代码运行的安全；<br>  (3) 提高编译器效率，增加运行速度；<br>  (4) 为未来新版本的Javascript做好铺垫。</li><li>缺点<br>  (1) 与未采用严格模式的文件一起压缩，反而会浪费字节</li></ul><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a><strong>DOM操作</strong></h2><hr><ul><li>创建<br>  createDocumentFragment()<br>  createElement()<br>  createTextNode()</li><li>添加、移除、替换、插入<br>  appendChild()<br>  removeChild()<br>  replaeChild()<br>  insertBefor()</li><li>查找<br>  getElementsByTagName()<br>  getElementsByName()<br>  getElementById()</li></ul><h2 id="document-write、innerHTML的区别"><a href="#document-write、innerHTML的区别" class="headerlink" title="document.write、innerHTML的区别"></a><strong>document.write、innerHTML的区别</strong></h2><hr><p>document.write: 只能重绘整个页面<br>innerHTML: 可以重绘部分页面  </p><h2 id="Javascript对象创建的几种方式"><a href="#Javascript对象创建的几种方式" class="headerlink" title="Javascript对象创建的几种方式"></a><strong>Javascript对象创建的几种方式</strong></h2><hr><p>(1) 工厂模式<br>(2) 构造函数模式<br>(3) 原型模式<br>(4) 混合构造模式和原型模式<br>(5) 动态原型模式<br>(6) 寄生构造函数模式<br>(7) 稳妥构造函数模式</p><h2 id="Javascript继承的6中方法"><a href="#Javascript继承的6中方法" class="headerlink" title="Javascript继承的6中方法"></a><strong>Javascript继承的6中方法</strong></h2><hr><p>(1) 原型链继承<br>(2) 借用构造函数继承<br>(3) 组合继承（原型+借用构造）<br>(4) 原型式继承<br>(5) 寄生式继承<br>(6) 寄生组合式继承 </p><h2 id="如何获取UA"><a href="#如何获取UA" class="headerlink" title="如何获取UA"></a><strong>如何获取UA</strong></h2><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">whatBrowser</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.Browser.Name.value = navigator.appName;</span><br><span class="line">        <span class="built_in">document</span>.Browser.Version.value = navigator.appVersion;</span><br><span class="line">        <span class="built_in">document</span>.Browser.Code.value = navigator.appCodeName;</span><br><span class="line">        <span class="built_in">document</span>.Browser.Agent.value = navigator.userAgent;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="slice-、substr-、substring-的区别"><a href="#slice-、substr-、substring-的区别" class="headerlink" title="slice()、substr()、substring()的区别"></a><strong>slice()、substr()、substring()的区别</strong></h2><hr><ul><li>slice(start, [end])：参数可为负</li><li>substr(start, length)</li><li>substring(start, [end]): 参数不可为负</li></ul><h2 id="Array方法"><a href="#Array方法" class="headerlink" title="Array方法"></a><strong>Array方法</strong></h2><hr><ul><li>转换方法<ul><li>valueOf()</li><li>toString()</li><li>toLocaleString()</li><li>join()</li></ul></li><li>堆栈方法<ul><li>push()</li><li>pop()</li></ul></li><li>队列方法<ul><li>push()</li><li>shift()</li><li>unshift(item1, item2, …)</li></ul></li><li>排序方法<ul><li>reverse()</li><li>sort()</li></ul></li><li>操作方法<ul><li>concat(arr1, arr2, …)</li><li>slice()</li><li>splice()</li></ul></li><li>位置方法<ul><li>indexOf()</li><li>lastIndexOf()</li></ul></li><li>迭代方法<ul><li>every()</li><li>filter()</li><li>forEach()</li><li>map()</li><li>some()</li></ul></li><li>合并方法<ul><li>reduce()</li><li>reduceRight()</li></ul></li></ul><h2 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a><strong>String方法</strong></h2><hr><ul><li>字符方法<ul><li>charAt(index): 返回指定位置的字符</li><li>charCodeAt(): 返回指定位置的字符的unicode编码</li></ul></li><li>操作方法<ul><li>concat()</li><li>slice()</li><li>substring()</li><li>substr()</li></ul></li><li>位置方法<ul><li>indexOf()</li><li>lastIndexOf()</li></ul></li><li>trim方法<ul><li>trim()</li><li>trimLeft()</li><li>trimRight()</li></ul></li><li>大小写转换方法<ul><li>toLowerCase()</li><li>toLocaleLowerCase()</li><li>toUpperCase()</li><li>toLocaleUpperCase()</li></ul></li><li>模式匹配方法<ul><li>match(string/reg)：<ul><li>string: 返回匹配结果的数组</li><li>reg(g): 返回所有的匹配子串</li><li>reg: 返回一个数组：元素0存放的是匹配文本；其余元素存放与正则表达式的子表达式匹配的文本；input属性表示匹配文本的起始字符的位置；input属性表示输入字符串</li></ul></li><li>search()</li><li>replace()</li><li>split()</li></ul></li><li>其他方法<ul><li>localeCompare()</li><li>fromCharCode()</li></ul></li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><strong>正则表达式</strong></h2><hr><ul><li>定义方法<ul><li>直接定义: var r = /pattern/flags;</li><li>构造函数: var r = new RegExp(‘pattern’, ‘flags’);</li></ul></li><li>元字符: ( ) [ ] { } \ ^ $ | ? * + .</li><li>特殊元字符<ul><li>.: 查找单个字符</li><li>\w: 查找字母数字下划线</li><li>\W: 查找非字母数字下划线</li><li>\d: 查找数字</li><li>\D: 查找非数字字符</li><li>\s: 查找空白字符</li><li>\S: 查找非空白字符</li><li>\b: 匹配单词边界</li><li>\B: 匹配非单词边界</li><li>\0: 查找NULL字符</li><li>\n: 查找换行符</li><li>\f: 查找换页符</li><li>\t: 查找回车符</li><li>\v: 查找垂直制表符</li><li>\xxx: 查找以8进制xxx规定的字符</li><li>\xdd: 查找以16进制dd规定的字符</li><li>\uxxxx: 查找以16进制xxxx规定的unicode字符</li><li>[…]: 匹配括号中的任何一个字符</li><li>[^…]: 匹配不在括号中的任何一个字符</li><li>{m,n}: 最少匹配前面表达式m次，最多n次</li><li>{m,}: 最少匹配前面表达式m次</li><li>{m}: 正好匹配前面表达式m次</li><li>?: 匹配前面表达式0或1次</li><li>+: 最少匹配前面表达式1次</li><li>*: 最少匹配前面表达式0次</li><li>|: 匹配前面表达式或后面表达式</li><li>(…): 组合项目</li><li>^: 匹配字符串的开头</li><li>$: 匹配字符串的结尾</li></ul></li></ul><h2 id="正则表达式方法"><a href="#正则表达式方法" class="headerlink" title="正则表达式方法"></a><strong>正则表达式方法</strong></h2><hr><ul><li>test(): 返回一个布尔值，表示传入的 字符串是否匹配（从lastIndex属性指示的地方开始）</li><li>exec(): 返回一个包含了匹配结果的数组（额外具有两个属性: input表示本次搜索的目标字符串；index表示匹配结果在目标字符串内的位置）</li></ul><h2 id="常见的正则表达式"><a href="#常见的正则表达式" class="headerlink" title="常见的正则表达式"></a><strong>常见的正则表达式</strong></h2><hr><ul><li>匹配中文: [u4e00-u9fa5]</li><li>匹配URL<ul><li>/http(s)?:\/\/([\w-]+.)+[\w-]+(\/[\w-.\/\?%&amp;=]*)?/</li></ul></li><li>匹配Email: /^[\w-]+(.[\w-]+)*@[\w-]+(.[\w-]+)+$/</li></ul><h2 id="JS函数调用的方法【参考】"><a href="#JS函数调用的方法【参考】" class="headerlink" title="JS函数调用的方法【参考】"></a><strong>JS函数调用的方法</strong><a href="http://www.cnblogs.com/leejersey/p/3663278.html" target="_blank" rel="noopener">【参考】</a></h2><hr><p>(1) 方法调用模式<br>(2) 函数调用模式<br>(3) 构造器调用模式<br>(4) apply调用模式</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h2><hr><h2 id="随机打乱数组顺序"><a href="#随机打乱数组顺序" class="headerlink" title="随机打乱数组顺序"></a><strong>随机打乱数组顺序</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomArr</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现duplicate"><a href="#实现duplicate" class="headerlink" title="实现duplicate"></a><strong>实现duplicate</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicate</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        buf = [];</span><br><span class="line">        <span class="keyword">var</span> i = obj.length();</span><br><span class="line">        <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">            buf[i] = duplicate(obj[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</span><br><span class="line">        buf = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            buf[k] = duplicate(obj[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现数组去重"><a href="#实现数组去重" class="headerlink" title="实现数组去重"></a><strong>实现数组去重</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.indexOf(elem, index+<span class="number">1</span>) === <span class="number">-1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取元素到页面顶部和左边的距离"><a href="#获取元素到页面顶部和左边的距离" class="headerlink" title="获取元素到页面顶部和左边的距离"></a><strong>获取元素到页面顶部和左边的距离</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDistance</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = el.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> y = el.ofsetTop;</span><br><span class="line">    <span class="keyword">while</span>(el = el.offsetParent)&#123;</span><br><span class="line">        x += el.offsetLeft;</span><br><span class="line">        y += el.offsetTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'x'</span>: x,</span><br><span class="line">        <span class="string">'y'</span>: y</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现bind方法"><a href="#实现bind方法" class="headerlink" title="实现bind方法"></a><strong>实现bind方法</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        self.apply(context, <span class="built_in">arguments</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网页、屏幕宽度、高度的获取&quot;&gt;&lt;a href=&quot;#网页、屏幕宽度、高度的获取&quot; class=&quot;headerlink&quot; title=&quot;网页、屏幕宽度、高度的获取&quot;&gt;&lt;/a&gt;&lt;strong&gt;网页、屏幕宽度、高度的获取&lt;/strong&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="面试" scheme="http://chuquan.me/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Javascript" scheme="http://chuquan.me/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>IT面试整理(3)——CSS</title>
    <link href="http://chuquan.me/2017/03/17/it-interviews003/"/>
    <id>http://chuquan.me/2017/03/17/it-interviews003/</id>
    <published>2017-03-17T09:38:00.000Z</published>
    <updated>2018-02-07T05:08:33.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="盒子模型【参考】"><a href="#盒子模型【参考】" class="headerlink" title="盒子模型【参考】"></a><strong>盒子模型</strong><a href="http://www.cnblogs.com/cchyao/archive/2010/07/12/1775846.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>组成: content、padding、border、margin</li><li>标准盒模型<ul><li>width/height = content</li></ul></li><li>IE盒模型<ul><li>width/height = content + padding + border</li></ul></li></ul><h2 id="行级元素、块级元素的区别"><a href="#行级元素、块级元素的区别" class="headerlink" title="行级元素、块级元素的区别"></a><strong>行级元素、块级元素的区别</strong></h2><hr><ul><li>块级元素: margin、padding可设置</li><li>行级元素: margin、padding水平方向可设置；竖直方向不可设置</li></ul><h2 id="浮动及其原理"><a href="#浮动及其原理" class="headerlink" title="浮动及其原理"></a><strong>浮动及其原理</strong></h2><hr><ul><li>脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留</li><li>缺点<br>  (1) 父元素的高度无法被撑开，影响与父元素同级的元素<br>  (2) 与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>  (3) 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li><li>清除方法<br>  (1) clear:both清除浮动<br>  (2) 父级div定义overflow:auto<pre><code>overflow有三个值: hidden, auto, visible; hidden, auto可用来清除浮动, auto对SEO更友好</code></pre>  (3) :after方法</li></ul><h2 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a><strong>line-height</strong></h2><hr><h2 id="CSS-hack"><a href="#CSS-hack" class="headerlink" title="CSS hack"></a><strong>CSS hack</strong></h2><hr><ul><li>定义: 针对不同浏览器/版本而写CSS的过程叫做CSS hack</li><li>三种方法<br>  (1) IE条件注释法: 即在正常代码之外添加判断IE浏览器或对应版本的条件注释，符合条件的浏览器或版本号才会执行里面的代码。<pre><code>- &lt;!-- [if IE]&gt;要执行的代码&lt;![endif]--&gt;- &lt;!-- [if lt LE 8]&gt;要执行的代码&lt;![endif]--&gt;- &lt;!-- [if ! IE 8]&gt;要执行的代码&lt;![endif]--&gt;</code></pre>  (2) CSS属性前缀法: 即给CSS的属性添加前缀。比如: <em>可以被IE6/IE7识别，_只能被IE6识别，”\9”可以被IE6-IE10识别，IE6不能识别!important，Firefox不能识别</em>,_,\9<pre><code>- #example{ color: #111; color: #222\9; *color: #333; _color: #444; }</code></pre>  (3) 选择器前缀法: 即给选择器加上前缀<pre><code>- *div{ color: red; }- *+div{ color: red; }</code></pre></li></ul><h2 id="background-属性"><a href="#background-属性" class="headerlink" title="background-属性"></a><strong>background-属性</strong></h2><hr><ul><li>background-color: 规定要使用的背景颜色<ul><li>color-name</li><li>hex-number</li><li>rgb-number</li><li>transparent</li><li>inherit</li></ul></li><li>background-position: 规定背景图像的位置<ul><li>top/left/bottom/right/center</li><li>x% y%</li><li>xpos ypos</li></ul></li><li>background-size: 规定背景图片尺寸<ul><li>length</li><li>percentage</li><li>cover</li><li>contain</li></ul></li><li>background-repeat: 规定如何重复背景图像<ul><li>repeat</li><li>repeat-x</li><li>repeat-y</li><li>no-repeat</li><li>inherit</li></ul></li><li>background-origin: 规定背景的定位区域<ul><li>padding-box</li><li>border-box</li><li>content-box</li></ul></li><li>background-clip: 规定背景的绘制区域<ul><li>border-box</li><li>padding-box</li><li>content-box</li></ul></li><li>background-attachment: 规定背景图像是否固定或者随着页面的其余部分滚动<ul><li>scroll</li><li>fixed</li><li>inherit</li></ul></li><li>background-image: 规定要使用的背景图像<ul><li>url(‘URL’)</li><li>none</li><li>inherit</li></ul></li></ul><h2 id="display-none和visibility-hidden的区别"><a href="#display-none和visibility-hidden的区别" class="headerlink" title="display:none和visibility: hidden的区别"></a><strong>display:none和visibility: hidden的区别</strong></h2><hr><ul><li>display: none 隐藏对应的元素，在文档布局中不分配空间；   </li><li>visibility: hidden 隐藏对应的元素，但是在文档布局中仍然保留员阿里的空间</li></ul><h2 id="link、-import"><a href="#link、-import" class="headerlink" title="link、@import"></a><strong>link、@import</strong></h2><hr><ul><li>link属于HTML标签；而@import是CSS提供的</li><li>页面被加载时，link会被同时加载，而@import引用的CSS会等到页面被加载完再加载</li><li>link方式的样式的权重高于@import的权重</li></ul><h2 id="position-absolute和float的区别"><a href="#position-absolute和float的区别" class="headerlink" title="position: absolute和float的区别"></a><strong>position: absolute和float的区别</strong></h2><hr><ul><li>共同点: 对内联元素<code>float</code>和<code>absolute</code>属性，可以让元素脱离文档流，并且可以设置其宽高  </li><li>不同点: <code>float</code>仍会占据位置，<code>position</code>会覆盖文档流中的其他元素</li></ul><h2 id="relative、absolute、fixed、static"><a href="#relative、absolute、fixed、static" class="headerlink" title="relative、absolute、fixed、static"></a><strong>relative、absolute、fixed、static</strong></h2><hr><p>absolute: 生成绝对定位的元素，相对于最近一级的定位不是<code>static</code>的父元素来进行定位<br>fixed: 生成绝对定位的元素，相对于浏览器窗口进行定位<br>relative: 生成相对定位的元素，相对于其在普通流中的位置进行定位<br>static: 默认值。没有定位，元素出现在正常的流中</p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a><strong>box-sizing</strong></h2><hr><p>content-box: 让元素维持W3C的标准盒模型<br>border-box: 让元素位置IE传统盒模型</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a><strong>CSS选择器</strong></h2><hr><p>(1) id选择器(#myId)<br>(2) 类选择器(.myclassname)<br>(3) 标签选择器(div, h1, p)<br>(4) 相邻选择器(h1 + p)<br>(5) 子选择器(ul &gt; li)<br>(6) 后代选择器(li a)<br>(7) 通配符选择器(*)<br>(8) 属性选择器(a[rel=”external”])<br>(9) 伪类选择器(a: hover, li:nth-child)  </p><h2 id="CSS选择器【参考】"><a href="#CSS选择器【参考】" class="headerlink" title="CSS选择器【参考】"></a><strong>CSS选择器</strong><a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">【参考】</a></h2><h2 id="CSS伪类、伪元素"><a href="#CSS伪类、伪元素" class="headerlink" title="CSS伪类、伪元素"></a><strong>CSS伪类、伪元素</strong></h2><hr><ul><li><strong>伪类</strong><ul><li>定义: 基于当前元素所处的状态，或者说元素所具有的特性，而不是元素的id、class、属性等静态的标志。</li><li>:link</li><li>:visited</li><li>:hover</li><li>:active</li><li>:focus</li><li>:first-child</li><li>:lang</li></ul></li><li><strong>伪元素</strong><ul><li>定义: 目的是获取诸如元素内容第一个字、第一行，获取某些内容前面或后面这种普通的选择器无法完成的工作。  </li><li>:first-letter</li><li>:first-line</li><li>:before</li><li>:after</li></ul></li></ul><h2 id="CSS可被继承、不可被继承的样式"><a href="#CSS可被继承、不可被继承的样式" class="headerlink" title="CSS可被继承、不可被继承的样式"></a><strong>CSS可被继承、不可被继承的样式</strong></h2><hr><p><strong>可继承</strong>: font-size, font-family, color, text-indent<br><strong>不可继承</strong>: border, padding, margin, width, height</p><h2 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a><strong>CSS优先级</strong></h2><hr><p>!important &gt; 内联 &gt; id &gt; class &gt; tag &gt; 默认样式</p><h2 id="class属性覆盖"><a href="#class属性覆盖" class="headerlink" title="class属性覆盖"></a><strong>class属性覆盖</strong></h2><hr><p>当存在多个类名时，类名的位置不会对属性的渲染产生影响。只有在style中定义的位置才会有影响，同一条属性，后面的定义会覆盖前面的定义</p><h2 id="CSS选择器权重"><a href="#CSS选择器权重" class="headerlink" title="CSS选择器权重"></a><strong>CSS选择器权重</strong></h2><hr><ul><li>通用选择器: 0-0-0</li><li>标签选择器，伪元素: 0-0-1</li><li>类选择器，属性选择器，伪类: 0-1-0</li><li>ID选择器: 1-0-0</li></ul><h2 id="em-rem-px【参考】"><a href="#em-rem-px【参考】" class="headerlink" title="em, rem, px【参考】"></a><strong>em, rem, px</strong><a href="http://www.cnblogs.com/leejersey/p/3662612.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>px: 像素。相对长度单位。像素px是相对显示器屏幕分辨率而言的</li><li>em: 相对长度单位。相对于当前对象内文本的字体尺寸。如果当前对内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</li><li>rem: 相对长度单位。相对于HTML根元素。既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应</li></ul><h2 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a><strong>CSS3新特性</strong></h2><hr><ul><li>边框：border-radius、box-shadow、border-image</li><li>背景：background-size、background-origin</li><li>文本：text-shadow、word-wrap</li><li>字体：@font-face</li><li>2D转换：transform、translate()、rotate()、scale()、skew()、matrix()</li><li>3D转换：rotateX()、rotateY()</li><li>过度：transition</li><li>动画：@keyframes、animation<h2 id="水平垂直居中【参考】"><a href="#水平垂直居中【参考】" class="headerlink" title="水平垂直居中【参考】"></a><strong>水平垂直居中</strong><a href="https://segmentfault.com/a/1190000006245264" target="_blank" rel="noopener">【参考】</a></h2></li></ul><hr><p>(1) 绝对定位 + 负margin</p><pre><code>- 优点: 兼容性好- 缺点: 需要知道宽高，不够灵活</code></pre><p>(2) 绝对定位 + Transform</p><pre><code>- 优点: 不需要知道宽高，灵活- 缺点: 兼容性不好，在移动设备上建议使用</code></pre><p>(3) 绝对定位 + 自动margin</p><pre><code>- 优点: 灵活性兼容性好- 缺点: 适用于本身有尺寸的元素，如图片，对于段落等必须显示设置其宽高</code></pre><p>(4) CSS3 flexbox </p><pre><code>- 优点: 不需要知道宽高- 缺点: 兼容性不好，在移动设备上建议使用</code></pre><p>(5) table display</p><pre><code>- 优点: 兼容性好    - 缺点: 增加了无用的html结构</code></pre><h2 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a><strong>两列布局</strong></h2><hr><p>(1) 左浮动 + 右margin<br>(2) 左绝对定位 + 右margin<br>(3) flex实现两列布局: 设置为flex布局后，子元素的float、clear、 vertical-align属性将失效<br>(4) calc实现两列布局: 使用百分比、em、px、rem单位值计算出其宽度或者高度。通过对右div设置width: calc(100%-100px)来实现自适应布局<br>(5) float + margin负值</p><pre><code>- 给右边的div外面套上一个父div，然后让父div的宽度设为100%。对父div的宽度设为100%</code></pre><h2 id="水平居中【参考】"><a href="#水平居中【参考】" class="headerlink" title="水平居中【参考】"></a><strong>水平居中</strong><a href="https://segmentfault.com/a/1190000005353303" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>行内元素<ul><li>对父元素设置文本居中，如: text-align: center</li><li>适用于inline, inline-block, inline-table, inline-flex</li></ul></li><li>块级元素<ul><li>margin: 0 auto</li></ul></li><li>浮动元素</li></ul><h2 id="Box、Formatting-Context【参考】"><a href="#Box、Formatting-Context【参考】" class="headerlink" title="Box、Formatting Context【参考】"></a><strong>Box、Formatting Context</strong><a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>Box: CSS布局的基本单位，一个页面由多个Box组成。元素的类型和display属性，决定了Box的类型。不同类型的Box，会参与不同的Formatting Context（一个决定如何渲染文档的容器），即Box内的元素会以不同的方式渲染。<br>  (1) block-level box: display属性为block、list-item、table的元素<br>  (2) inline-level box: display属性为inline、inline-block、inline-table的元素<br>  (3) run-in box: CSS3存在</li><li>Formatting context: 页面中的一块渲染区域，并且有一套渲染规则，其决定了其子元素将如何定位，以及和其他元素的    关系和相互作用<br>  (1) BFC: Block Formatting Context<br>  (2) IFC: Inline Formatting Context<br>  (3) GFC: CSS3<br>  (4) FFC: CSS3</li></ul><h2 id="BFC【参考】"><a href="#BFC【参考】" class="headerlink" title="BFC【参考】"></a><strong>BFC</strong><a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>定义: 块级格式化上下文。一个独立的渲染区域，只有block-level box参与，规定了内部的 block-level box如何布局。</li><li>BFC布局规则<br>  (1) 内部的box会在垂直方向一个个进行放置<br>  (2) box垂直方向的距离由margin决定。属于同一个BFC的两个相邻box的margin会发生重叠<br>  (3) 每个元素的margin box的左边，与包含块border box的左边相接触。即使存在浮动也是如此。<br>  (4) BFC的区域不会与float box重叠<br>  (5) BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素<br>  (6)  计算BFC的高度时，浮动元素也参与计算</li><li>生成BFC的元素<ul><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为 inline-block，table-cell，table-caption，flex，inline-flex</li><li>overflow不为visible</li></ul></li></ul><h2 id="边界塌陷-amp-边界重叠"><a href="#边界塌陷-amp-边界重叠" class="headerlink" title="边界塌陷 &amp; 边界重叠"></a><strong>边界塌陷 &amp; 边界重叠</strong></h2><hr><p><strong>定义</strong>: CSS中存在一个margin collapse， 即边界塌陷或边界重叠。对于上下两个并列的div，上面的div的margin-bottom和下面的div的margin-top会塌陷，取两者margin的最大值</p><h2 id="CSS-sprite"><a href="#CSS-sprite" class="headerlink" title="CSS sprite"></a><strong>CSS sprite</strong></h2><hr><p>把网页中的一些背景图片整合到一张图片中，再利用CSS的<code>background-repeat</code>,<code>background-image</code>,<code>background-position</code>的组合进行定位</p><h2 id="CSS-媒体查询【参考】"><a href="#CSS-媒体查询【参考】" class="headerlink" title="CSS 媒体查询【参考】"></a><strong>CSS 媒体查询</strong><a href="http://www.runoob.com/cssref/css3-pr-mediaquery.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>作用: @media可以针对不同的屏幕尺寸设置不同的样式，特别是设置响应式的页面</li><li>语法<ul><li>@media mediatype and|not|only (mediafeature){ CSS-Code; }<ul><li>如: @media screen and (max-width: 300px) { … }, @media</li></ul></li><li>mediatype<ul><li>all: 用于所有设备</li><li>print: 用于打印机和打印预览</li><li>screen: 用于电脑屏幕，平板电脑，智能手机等</li><li>speech: 应用于屏幕阅读器等发声设备</li></ul></li><li>mediafeature<ul><li>aspect-ratio: 定义输出设备中的页面可见区域宽度和高度的比率</li><li>color: 定义输出设备每一组彩色原件的个数</li><li>color-index</li><li>device-aspect-ratio</li><li>device-height</li><li>device-width</li><li>grid</li><li>height</li><li>max-aspect-ratio</li><li>max-color</li><li>max-device-s</li><li>…</li></ul></li></ul></li></ul><h2 id="font-face【参考】"><a href="#font-face【参考】" class="headerlink" title="@font-face【参考】"></a><strong>@font-face</strong><a href="http://www.runoob.com/cssref/css3-pr-font-face-rule.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>语法: @font-face { font-properties }</li><li>font-properties<ul><li>font-family: 定义字体的名称(必须)</li><li>src: 定义字体的下载地址(必须)</li><li>font-stretch: 定义字体该如何被拉长</li><li>font-style: 定义字体该是怎样的样式</li><li>font-weight: 定义字体的粗细</li><li>unicode-range: 定义字体支持Unicode字符的范围</li></ul></li></ul><h2 id="CSS3画一个旋转的3-4的圆环"><a href="#CSS3画一个旋转的3-4的圆环" class="headerlink" title="CSS3画一个旋转的3/4的圆环"></a><strong>CSS3画一个旋转的3/4的圆环</strong></h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">20px</span> solid black;</span><br><span class="line">    <span class="attribute">border-left-color</span>: transparent;</span><br><span class="line">    <span class="attribute">-webkit-animation</span>: mycircle <span class="number">1s</span> infinite linear;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> mycircle &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(0deg); &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-360deg); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;盒子模型【参考】&quot;&gt;&lt;a href=&quot;#盒子模型【参考】&quot; class=&quot;headerlink&quot; title=&quot;盒子模型【参考】&quot;&gt;&lt;/a&gt;&lt;strong&gt;盒子模型&lt;/strong&gt;&lt;a href=&quot;http://www.cnblogs.com/cchyao/ar
      
    
    </summary>
    
      <category term="面试" scheme="http://chuquan.me/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="CSS" scheme="http://chuquan.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>IT面试整理(2)——HTML</title>
    <link href="http://chuquan.me/2017/03/07/it-interviews002/"/>
    <id>http://chuquan.me/2017/03/07/it-interviews002/</id>
    <published>2017-03-07T09:00:49.000Z</published>
    <updated>2018-02-08T10:29:02.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Doctype"><a href="#Doctype" class="headerlink" title="Doctype"></a><strong>Doctype</strong></h2><hr><ul><li><strong>作用</strong><br>  (1) 对文档进行有效性验证： 告诉用户代理和校验器该文档的DTD<br>  (2) 决定浏览器的呈现模式：通知浏览器读取文档时采用何种解析算法。浏览器有三种方式解析HTML文档(标准模式、怪异模式、部分怪异模式)  </li><li><strong>种类</strong><br>  (1) HTML 4.01: Strict, Transitional, Framset<br>  (2) XHTML 1.0: Strict, Transitional, Framset</li></ul><h2 id="标准模式、怪异模式"><a href="#标准模式、怪异模式" class="headerlink" title="标准模式、怪异模式"></a><strong>标准模式、怪异模式</strong></h2><hr><ul><li><strong>标准模式</strong>：页面按照HTML与CSS的定义渲染</li><li><strong>怪异模式</strong>：浏览器为了了兼容很早之前针对旧版本浏览器设计、并未严格遵循W3C标准的网页而产生的一种页面渲染模式</li></ul><h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a><strong>语义化</strong></h2><hr><p>(1) 去掉或丢失样式时能够让页面呈现出清晰的结构<br>(2) 有利于SEO：爬虫依赖于标签来确定上下文和各个关键字的权重<br>(3) 方便其他设备解析以意义的方式来渲染网页<br>(4) 可读性更好，方便团队开发</p><h2 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a><strong>XHTML</strong></h2><hr><p>(1) 所有的标记都必须要有一个相应的结束标记<br>(2) 所有标签的元素和属性的名字都必须使用小写<br>(3) 所有的XML标记都必须合理嵌套<br>(4) 所有的属性必须用引号””括起来<br>(5) 把所有&lt;和&amp;特殊符号用编码表示<br>(6) 给所有属性赋一个值<br>(7) 不要在注释内容中使“–”<br>(8) 图片必须有说明文字</p><h2 id="data-属性"><a href="#data-属性" class="headerlink" title="data-属性"></a><strong>data-属性</strong></h2><hr><p>自定义属性，可通过对象的dataset属性获取，或通过getAttribute方法获取：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-author</span>=<span class="string">"baochuquan"</span> <span class="attr">data-time</span>=<span class="string">"2016-06-20"</span> <span class="attr">data-comment</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.dataset.commentNum;<span class="comment">//10</span></span><br></pre></td></tr></table></figure><h2 id="input的type属性【参考】"><a href="#input的type属性【参考】" class="headerlink" title="input的type属性【参考】"></a><strong>input的type属性</strong><a href="http://www.w3school.com.cn/html5/att_input_type.asp" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>button</li><li>checkbox</li><li>color</li><li>date</li><li>datetime</li><li>datetime-local</li><li>month</li><li>week</li><li>time</li><li>email</li><li>file</li><li>hidden</li><li>image</li><li>number</li><li>password</li><li>radio</li><li>range</li><li>reset</li><li>search</li><li>submit</li><li>tel</li><li>text</li><li>url</li></ul><h2 id="iframe的优缺点"><a href="#iframe的优缺点" class="headerlink" title="iframe的优缺点"></a><strong>iframe的优缺点</strong></h2><hr><ul><li><strong>优点</strong><br>(1) 解决加载缓慢的第三方内容(如图标和广告等)的加载问题<br>(2) Security sandbox<br>(3) 并行加载脚本  </li><li><strong>缺点</strong><br>(1) iframe会阻塞主页面的onload事件<br>(2) 即使内容为空，加载也需要时间<br>(3) 没有语义  </li></ul><h2 id="HTML表单元素【参考】"><a href="#HTML表单元素【参考】" class="headerlink" title="HTML表单元素【参考】"></a><strong>HTML表单元素</strong><a href="http://www.w3school.com.cn/html/html_form_elements.asp" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li>input</li><li>select</li><li>option</li><li>textarea</li><li>button</li></ul><h2 id="HTMl5表单元素【参考】"><a href="#HTMl5表单元素【参考】" class="headerlink" title="HTMl5表单元素【参考】"></a><strong>HTMl5表单元素</strong><a href="http://www.w3school.com.cn/html5/html_5_form_elements.asp" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li><code>datalist</code>: datalist元素规定输入域的选项列表，列表是通过datalist内的option元素创建的</li><li><code>keygen</code>: keygen元素的作用是提供一种验证用户的可靠方法</li><li><code>output</code>: output元素用于不同类型的输出，如计算或脚本输出</li></ul><h2 id="head标签及其内容【参考】"><a href="#head标签及其内容【参考】" class="headerlink" title="head标签及其内容【参考】"></a><strong>head标签及其内容</strong><a href="http://blog.csdn.net/puppylpg/article/details/47953181" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li><strong>作用</strong>: 描述了文档的各种属性和信息，包括文档的标题、在web中的位置以及和其它文档的关系等</li><li><strong>内容</strong><ul><li>title: 定义文档的标题，是head部分中唯一必需的元素</li><li>base: 为页面上的所有链接规定默认地址或默认目标<ul><li>必选: href</li><li>可选: target</li></ul></li><li>meta: 可提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词<ul><li>必选: content</li><li>可选<ul><li>http-equiv(Content-Type, expires, Refresh, set-cookie)</li><li>name: author, description, keywords, generator, revised, others</li></ul></li></ul></li><li>link: 链接一个外部样式表<ul><li>rel, href, type, charset</li></ul></li><li>script: 直接包含脚本，或者通过src属性指向外部脚本文件</li><li>style: 为HTML文档定义样式信息</li></ul></li></ul><h2 id="块级元素、行内元素、空元素"><a href="#块级元素、行内元素、空元素" class="headerlink" title="块级元素、行内元素、空元素"></a><strong>块级元素、行内元素、空元素</strong></h2><hr><ul><li>块级元素<ul><li>div、dl、dt、dd、ul、li、ol、p、h1-6、table、fieldset、form</li></ul></li><li>行内元素<ul><li>a、em、strong、i、img、b、label、select、textarea、sub、sup、q</li></ul></li><li>空元素<ul><li>br、hr</li></ul></li></ul><h2 id="自闭合元素"><a href="#自闭合元素" class="headerlink" title="自闭合元素"></a><strong>自闭合元素</strong></h2><hr><ul><li>自闭合标签不加斜杠，如: br, link</li></ul><h2 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a><strong>HTML5新特性</strong></h2><hr><ul><li>新的文档类型：&lt;!DOCTYPR html&gt;</li><li>脚本和链接不需要type：</li><li>语义标签：header、footer</li><li>hgroup</li><li>标记元素：mark</li><li>图形元素：figure</li><li>必要属性：require</li><li>音频视频：video, audio</li><li>正则表达式：pattern属性</li><li>canvas API：栅格图形API</li><li>SVG：矢量图形API</li><li>Geolocation API</li><li>Communication API</li><li>WebSockets API</li><li>Form API</li><li>Web Works API</li><li>Web Storage API</li></ul><h2 id="置换元素、不可置换元素"><a href="#置换元素、不可置换元素" class="headerlink" title="置换元素、不可置换元素"></a><strong>置换元素、不可置换元素</strong></h2><hr><ul><li>置换元素<ul><li>定义：浏览器根据元素的标签和属性，来决定元素的具体显示内容</li><li>如：imt, input, textarea, select, object</li></ul></li><li>不可替换元素<ul><li>定义：其内容直接呈现给用户</li></ul></li></ul><h2 id="meta标签【参考】"><a href="#meta标签【参考】" class="headerlink" title="meta标签【参考】"></a><strong>meta标签</strong><a href="http://www.jb51.net/web/158860.html" target="_blank" rel="noopener">【参考】</a></h2><hr><ul><li><strong>作用</strong><ul><li>通常用来为搜索引擎robots定义页面主题，或者是定义用户浏览器上的cookie；</li><li>可以用于鉴别作者，设定页面格式，标注内容提要和关键字；</li><li>可以设置页面使其可以根据自己定义的时间间隔刷新自己</li><li>设置RASC内容等级</li></ul></li><li><strong>分类</strong><br>  (1) http-equiv: HTTP标题信息<pre><code>- Content-Type、Content-Language    - 说明: 设定页面使用的字符集，用以说明主页只做所使用的文字及语言    - 用法        - &lt;meta http-equiv=&quot;Content-Type&quot; Content=&quot;text/html; Charset=gb2312&quot;&gt;        - &lt;meta http-equiv=&quot;Content-Language&quot; Content=&quot;zh-CN&quot;&gt;- Refresh    - 说明: 让网页多长时间刷新自己，或在多长时间后让网页自动链接到其他网页    - 用法        - &lt;meta http-equiv=&quot;Refresh&quot; Content=&quot;30&quot;&gt;        - &lt;meta http-equiv=&quot;Refresh&quot; Content=&quot;5;Url=&quot;http://www.baidu.com&quot;&gt;- Expires    - 说明: 指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新调整        - &lt;meta http-equiv=&quot;Expires&quot; Content=&quot;0&quot;&gt;        - &lt;meta http-equiv=&quot;Expires&quot; Content=&quot;Wed, 26 Feb 1997 08:21:57 GMT&quot;&gt;- Pragma(cache模式)    - 说明: 禁止浏览器从本地机的缓存中调阅页面内容- Set-Cookie(cookie设定)</code></pre>  (2) name: 页面描述信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Doctype&quot;&gt;&lt;a href=&quot;#Doctype&quot; class=&quot;headerlink&quot; title=&quot;Doctype&quot;&gt;&lt;/a&gt;&lt;strong&gt;Doctype&lt;/strong&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;br
      
    
    </summary>
    
      <category term="面试" scheme="http://chuquan.me/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="HTML" scheme="http://chuquan.me/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>IT面试整理(1)——网络</title>
    <link href="http://chuquan.me/2017/03/02/it-interviews001/"/>
    <id>http://chuquan.me/2017/03/02/it-interviews001/</id>
    <published>2017-03-02T12:25:34.000Z</published>
    <updated>2018-02-08T10:28:30.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><hr><ul><li><strong>OSI五层模型</strong><ul><li><em>应用层</em></li><li><em>传输层</em></li><li><em>网络层</em></li><li><em>数据链路层</em></li><li><em>物理层</em> </li></ul></li><li><strong>OSI七层模型</strong><ul><li><em>应用层</em>: 文件传输，电子邮件，文件服务，虚拟终端<ul><li>（协议族: FTP,HTTP,SMTP,DNS,Telnet,SNMP）</li></ul></li><li><em>表示层</em>: 数据格式化，代码转换，数据加密。对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</li><li><em>会话层</em>: 解除或建立与别的节点的联系。管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</li><li><em>传输层</em>: 提供端到端的接口。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层处理端到端的差错控制和流量控制问题。<ul><li>（协议族: TCP, UDP）</li></ul></li><li><em>网络层</em>: 为数据包选择路由。还可以实现拥塞控制、网际互连等功能<ul><li>（协议族: IP, ICMP, RIP, OSPF, BGP, IGMP）</li></ul></li><li><em>数据链路层</em>: 传输有地址的帧以及错误检测功能。在不可靠的物理介质上提供可靠的传输，该层的作用包括：物理地址寻址、数据的成帧、流量控制、 数据的检错、重发等<ul><li>（协议族: SLIP, CSLIP, PPP, ARP, RARP, MTU）</li></ul></li><li><em>物理层</em>: 以二进制数据形式在物理媒介上传输数据。激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性<ul><li>（协议族: ISO2110, IEEE802, IEEE802.2）          <h2 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h2></li></ul></li></ul></li></ul><hr><ul><li><strong>原理</strong>: 适用于局域网，主机在发送帧前将目标IP地址转换成目标MAC地址的过程</li><li><strong>工作过程</strong>  <ul><li><strong>(1)</strong> 当主机A向本局域网上主机B发送IP数据报时，先在自己的ARP缓冲表中查看有无主机B的IP地址；</li><li><strong>(2)</strong> 如果有，查出对应的硬件地址，并将此硬件地址写入MAC帧，然后通过以太网将数据包发送到目的主机中     </li><li><strong>(3)</strong> 如果查不到主机B的IP地址的表项，高速缓存表可能是空的。主机A就自动运行ARP协议  <ul><li>ARP进程在本局域网上广播一个ARP请求分组。ARP请求分组的主要内容表明：我的IP地址是192.168.0.2，我的硬件地址是00-C0-15-AD-18，我想知道IP地址为192.168.0.4的主机的硬件地址</li><li>本局域网上的所有主机上运行的AR进程都接收此ARP请求分组 </li><li>主机B在ARP请求分组中见到自己的IP地址，就向主机A发送ARP响应分组，并写入自己的硬件地址</li><li>主机A收到主机B的ARP响应分组后，在其ARP高速缓存中写入主机B的IP地址硬件地址的映射</li></ul></li></ul></li></ul><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><hr><ul><li><strong>RIP协议</strong><ul><li>底层是Bellmanford算法，其选择路由的度量标准是跳数，最大跳数是15跳，如果大于15跳，则丢弃数据包</li></ul></li><li><strong>OSPF协议</strong><ul><li>底层是Dijskra算法，是链状状态路由选择协议，其选择路由的度量标准是带宽、延迟</li></ul></li></ul><h2 id="NAT协议、DHCP议、DNS协议"><a href="#NAT协议、DHCP议、DNS协议" class="headerlink" title="NAT协议、DHCP议、DNS协议"></a>NAT协议、DHCP议、DNS协议</h2><hr><ul><li><strong>NAT协议</strong><ul><li>网络地址转换协议: 一种将私有地址转换成合法IP地址的转换技术，完美解决了IP地址不足的问题，还能有效避免来自网络外部的攻击</li></ul></li><li><strong>DHCP协议</strong><ul><li>动态主机配置协议: 一种局域网的网络协议，使用UDP协议工作，主要用途: <ul><li>(1) 给内部网络或者网络供应商自动分配IP地址</li><li>(2) 给用户或者内部网络管理员作为对所有计算机作中央管理的手段</li></ul></li></ul></li><li><strong>DNS协议</strong><ul><li>将域名和IP地址相互映射的一个分布式数据库</li></ul></li></ul><h2 id="实现可靠传输的协议"><a href="#实现可靠传输的协议" class="headerlink" title="实现可靠传输的协议"></a>实现可靠传输的协议</h2><hr><ul><li><strong>(1) 停止等待协议</strong><ul><li>每发完一帧就停止发送，直到收到接收确认信号再发送下一帧，如果没有收到接收确认信号，则通过设定的定时器 超时后重传上一帧，通过序号判断之前的帧是否被接收</li></ul></li><li><strong>(2) 连续ARQ协议</strong><ul><li>发送窗口大于1，接收窗口等于1。如果发送窗口已经发送到了序号为5的帧，但是接收端收到序号为3的帧出错，那么3以后的帧都需重传。为了避免后面的帧重传，可以使用缓存</li></ul></li><li><strong>(3) 选择重传协议</strong></li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><hr><p><a href="http://blog.csdn.net/sicofield/article/details/9708383" target="_blank" rel="noopener">【参考】</a></p><ul><li><strong>定义</strong>: 防止过多的数据注入网络中，可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制是指点对点通信量的控制</li><li><strong>方法</strong>: <ul><li><strong>(1) 慢开始与拥塞避免</strong><ul><li>慢开始： 先探测网络的拥塞程度，从小到大逐渐增加拥塞窗口的大小</li><li>拥塞避免: 让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1</li></ul></li><li><strong>(2) 快重传与快恢复</strong></li><li><strong>(3) 随机早起检测RED</strong></li></ul></li></ul><h2 id="网络设备及其相关层"><a href="#网络设备及其相关层" class="headerlink" title="网络设备及其相关层"></a>网络设备及其相关层</h2><hr><ul><li><strong>网关</strong>: 网络层以上的设备</li><li><strong>网络层</strong>: 路由器</li><li><strong>数据链路层</strong>: 网桥、交换机</li><li><strong>物理层</strong>: 中继器、集线器</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><hr><p><a href="https://segmentfault.com/a/1190000004467714" target="_blank" rel="noopener">【参考】</a></p><ul><li>在HTTP和TCP协议之间建立一层TLS/SSL协议</li></ul><h2 id="HTTP头"><a href="#HTTP头" class="headerlink" title="HTTP头"></a>HTTP头</h2><hr><p><a href="https://segmentfault.com/a/1190000004093321" target="_blank" rel="noopener">【参考】</a></p><ul><li>报文格式<ul><li>报文首部</li><li>空行</li><li>报文主体</li></ul></li><li><p>请求报文首部</p><ul><li>请求行（GET /index.html/ HTTP/1.1）</li><li>请求首部字段<ul><li>请求信息性首部字段<ul><li>From: 请求来自何方，格式是客户端用户的有效电子邮件地址</li><li>Host: 服务器的主机名和端口号</li><li>Referer: 这次请求的URL是从哪里获得的</li><li>User-Agent: 客户端的浏览器或代理信息</li></ul></li><li>Accept首部字段<ul><li>Accept: 客户端通过该首部字段告诉服务器自己可以接收哪些媒体类型，如text/html。此外，还有可以权重系数（q值）来表示媒体类型的优先级。</li><li>Accept-Charset: 客户端可以接收哪些字符集，也可以有q值</li><li>Accept-Encoding: 客户端支持的内容编码及内容编码的优先级顺序。</li><li>Accept-Language: 客户端能够处理的自然语言集（中文、英文等）</li><li>TE: 客户端能够处理的传输编码，还可以指定伴随trailer字段的分块传输编码方式</li></ul></li><li>条件请求首部字段<ul><li>Expect: 客户端通过该首部字段告知服务器它们需求某种行为，现在该首部与响应码100 Continue紧密相关。如果服务器无法理解该首部的值，就应该返回417 Expectation Failed</li><li>If-Match: 服务器会比对该字段的值和资源的ETag值，仅当两者一致时，才会执行请求，否则，返回412 Precondition Failed。该字段值为*时，会忽略ETag值</li><li>If-Modified-Since: 该字段值应该是一个日期，如果服务器上资源的更新时间较该字段值新则处理该请求，否则，返回304 Not Modified</li><li>If-None-Match: 与If-Match相反，该字段的值与请求资源的ETag不一致时，处理该请求</li><li>If-Range: 该字段的值（ETag或时间）与资源的ETag或时间一致时，作为范围请求处理（参加首部字段Range）。否则，返回全体资源</li><li>If-Unmodified-Since: 与If-Modified-Since相反，服务器上资源的更新时间早于该字段值时处理请求，否则，返回412 Precondition Failed</li><li>Range: 范围请求，只获取部分资源。如Range: bytes=5001-10000，表示获取从第5001字节至10000字节的资源。成功处理范围请求时返回206 Partial Content响应，无法处理范围请求时返回200 OK响应及全部资源</li></ul></li><li>安全请求首部字段<ul><li>Authorization: 向服务器回应自己的身份验证信息。客户端收到来自服务器的401 Authentication Required响应后，要在其请求中包含这个首部</li><li>Cookie: HTTP/1.1中没有定义，用于客户端识别和跟踪的扩展首部               </li></ul></li><li>代理请求首部字段<ul><li>Max-Forwards: 只能和TRACE方法一起使用，指定经过代理或其他中间节点的最大数目。每个收到带此首部的TRACE请求的应用程序，在请求转发之前都要将这个值减1；如果应用程序收到请求时，该首部值为0，则立即回应一条200 OK响应</li></ul></li><li>Proxy-Authorization: 与Authorization类似，用于客户端与代理服务器之间的身份验证 </li></ul></li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li></ul></li><li><p>响应报文首部</p><ul><li>状态行（HTTP/1.1 200 OK）</li><li>响应首部字段<ul><li>响应信息性首部字段  <pre><code>- Age: 响应已经产生了多长时间。HTTP/1.1规定缓存服务器在创建响应时必须包含Age首部</code></pre><ul><li>Location: 客户端应重定向到指定URI，基本配合响应出现</li><li>Retry-After: 告诉客户端多久之后再次发送请求。主要配合503 Service Unavailable使用，或与3**响应一起使用</li><li>Server: HTTP服务器的应用程序信息</li><li>Warning:</li></ul></li><li>协商首部字段<ul><li>Accept-Ranges: 服务器是否能处理范围请求，bytes表示能，none表示不能</li><li>Vary:</li></ul></li><li>安全响应首部字段<ul><li>Proxy-Authorizate: 与WWW-Authenticate类似，用于代理与客户端之间的认证，407 Proxy Authentication Required响应必须包含该首部</li><li>Set-Cookie: 非HTTP/1.1标准首部</li><li>WWW-Authenticate: 告诉客户端访问所请求资源的认证方案，401 Unauthorized响应中肯定有该首</li></ul></li></ul></li><li>通用首部字段<ul><li>通用信息性首部字段<ul><li>Connection: 两个作用<ol><li>控制不再转发给代理的首部字段</li><li>管理持久连接</li></ol></li><li>Date: 创建HTTP报文的时间和日期</li><li>Trailer: 说明在报文主体后记录了哪些首部字段</li><li>Transfer-Encoding: 传输报文主体时采用的编码方式</li><li>Upgrade: 用于检测HTTP协议及其他协议是否可使用更高的版本进行通信</li><li>Via: 追踪客户端与服务器之前的请求和响应报文的传输路径</li></ul></li><li>通用缓存首部字段<ul><li>Cache-Control: 管理缓存信息，是HTTP/1.1引入的一个复杂首部</li><li>Pragma: HTTP/1.1以前的遗留字段Pargma: no-cache与Cache-Control: no-cache功能一致，只用在客户端发送请求时</li></ul></li></ul></li><li>实体首部字段<ul><li>实体信息性首部字段<ul><li>Allow: 通知客户端可以对特定资源使用那些HTTP方法。405 Method Not Allowed响应中必须包含该首部</li></ul></li><li>内容首部字段<ul><li>Content-Encoding: 告诉客户端实体的主体部分选用的内容编码方式。具体方式参见Accept-Encoding</li><li>Content-Language: 告诉客户端实体主体使用的自然语言（中文、英文等）</li><li>Content-Length: 表明实体主体部分的大小（单位：字节）。对实体主体进行内容编码传输时，不能再使用该首部字段</li><li>Content-Location: 报文主体部分相对应的URI</li><li>Content-MD5: 一串由MD5算法生成的值。对于检查在传输过程中数据是否被无意的修改非常有用，但不能用于安全目的，因为报文如果被有意的修改，该字段的值也可以计算后作相应修改</li><li>Content-Range: 针对范围请求，提供了请求实体在原始实体内的位置（范围），还给出了整个实体的长度</li><li>Content-Type: 响应报文中对象的媒体类型</li></ul></li><li>实体缓存首部字段<ul><li>ETag: 实体标记，就是一种标识资源的方式</li><li>Expires: 资源失效日期，当Cache-Control有指定max-age指令时，会优先处理max-age</li><li>Last-Modified: 资源最终修改时间</li></ul></li></ul></li><li>其他</li></ul></li></ul><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><hr><ul><li><strong>GET</strong>: 最常见，向服务器请求某个资源  </li><li><strong>POST</strong>: 起初用于向服务器输入数据。实际上，通常用于HTML表单数据的提交  </li><li><strong>HEAD</strong>: 与GET的行为类似，但服务器返回的响应中只包含首部，不会返回主体部分  </li><li><strong>PUT</strong>: 向服务器写入文档  </li><li><strong>DELETE</strong>: 删除指定资源  </li><li><strong>TRACE</strong>: 服务器回送收到的请求信息给客户端，主要用于诊断  </li><li><strong>ONNECT</strong>  </li><li><strong>OPTIONS</strong>: 查询服务器支持的方法（通用或针对指定资源）  </li></ul><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><hr><ul><li><strong>100 Continue</strong>: 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li><li><strong>200 OK</strong>: 正常返回信息 </li><li><strong>201 Created</strong>: 请求成功并且服务器创建了新的资源</li><li><strong>202 Accepted</strong>: 服务器已接受请求，但尚未处理</li><li><strong>301 Moved Permanently</strong>: 请求的网页已永久移动到新位置。</li><li><strong>302 Found</strong>: 临时性重定向。</li><li><strong>303 See Other</strong>: 临时性重定向，且总是使用 GET 请求新的 URI。</li><li><strong>304 Not Modified</strong>: 自从上次请求后，请求的网页未修改过。</li><li><strong>400 Bad Request</strong>: 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li><li><strong>401 Unauthorized</strong>: 请求未授权。</li><li><strong>403 Forbidden</strong>: 禁止访问。</li><li><strong>404 Not Found</strong>: 找不到如何与 URI 相匹配的资源。</li><li><strong>500 Internal Server Error</strong>: 最常见的服务器端错误。</li><li><strong>503 Service Unavailable</strong>: 服务器端暂时无法处理请求（可能是过载或维护）。</li></ul><h2 id="域名劫持"><a href="#域名劫持" class="headerlink" title="域名劫持"></a>域名劫持</h2><hr><ul><li><strong>原理</strong>: 通过攻击域名解析服务器或者伪造域名解析服务器的方法，把目标网站域名解析到错误的地址。</li></ul><h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><hr><ul><li><strong>含义</strong>: 用于指定请求和响应的HTTP内容类型。如果未指定，默认为text/html</li><li><strong>格式</strong>: [type]/[subtype];parameter<ul><li>type<ul><li>text: 用于标准化地表示文本信息，文本消息可以是多种字符集或多种格式的</li><li>multipart: 用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据</li><li>application: 用于传输应用程序数据或二进制数据</li><li>message: 用于包装一个email消息</li><li>image: 用于传输静态图片数据</li><li>audio: 用于传输音频数据</li><li>video: 用于传输动态影像数据，可以是与音频编辑在一起的视频格式的数据 q</li><li>subtype</li><li>patameter</li></ul></li></ul></li><li><strong>常见值</strong><ul><li>text/html</li><li>text/plain</li><li>text/css</li><li>text/javascript</li><li>application/x-www-form-urlencoded: 常用的表单发包方式，POST发包方式</li><li>multipart/form-data: 发送文件的POST包</li><li>application/json</li><li>application/xml</li></ul></li></ul><h2 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h2><hr><h2 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h2><hr><ul><li><strong>private</strong>: 默认值。内容只缓存到私有缓存中（仅客户端可以换成，代理服务器不可缓存）</li><li><strong>public</strong>: 所用内容都可以被缓存（客户端和代理服务器都可缓存）<br>cache会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载</li><li><strong>no-store</strong>: 所有内容都不会被缓存到缓存或Internet临时文件中</li><li><strong>max-age</strong>: 缓存的内容将在xxx秒后失效</li><li><strong>must-revalidate/proxy-revalidation</strong>: 如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证</li></ul><h2 id="三次握手、四次挥手"><a href="#三次握手、四次挥手" class="headerlink" title="三次握手、四次挥手"></a>三次握手、四次挥手</h2><hr><div align="center"><img src="https://segmentfault.com//image?src=http://7xj8xg.com1.z0.glb.clouddn.com/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.gif&amp;objectId=1190000004138638&amp;token=d1b8c871d955e926a423b86be60a384b" alt=""></div>  <ul><li><strong>三次握手</strong>  <ol><li>Client端发送连接请求报文  </li><li>Server端接收连接请求，并回复ACK报文，并为此次连接分配资源  </li><li>Client端接收ACK报文，向Server端发送ACK报文，并分配资源  </li></ol></li></ul><div align="center"><img src="http://hi.csdn.net/attachment/201108/7/0_1312718564tZXD.gif" alt=""></div>  <ul><li><strong>四次挥手</strong>  <ol><li>Client端发送中断请求，即FIN报文  </li><li>Server端收到FIN报文，发送ACK报文，并继续发送数据  </li><li>Client端收到ACK报文，进入FIN_WAIT状态  </li><li>Server端数据发送完毕，发送FIN报文  </li><li>Client端收到FIN报文，发送ACK报文，等待2MSL  </li></ol></li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><hr><ul><li><strong>特殊的IP地址</strong><ul><li><em>网络地址</em><ul><li>IP地址由网络号和主机号组成，网络地址的主机号为全0，网络地址代表整个网络</li></ul></li><li><em>广播地址（直接广播地址）</em><ul><li>IP地址主机号全为1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息</li><li>既可本地广播，也可跨网段广播</li></ul></li><li><em>组播地址</em><ul><li>D类即主播地址</li></ul></li><li><em>255.255.255.255（受限广播地址）</em><ul><li>受限广播地址，只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组</li></ul></li><li><em>0.0.0.0</em><ul><li>表示整个网络。它的作用是帮助路由器发送路由表中无法查询的包。如果设置了全零网络的路由，路由表中无法查询的包都将送到全零网络的路由中去。</li></ul></li><li><em>回环地址</em><ul><li>表示本机地址</li></ul></li><li><em>A、B、C类私有地址</em><ul><li>A类私有地址: 10.0.0.0/8, 范围: 10.0.0.0~10.255.255.255</li><li>B类私有地址: 172.16.0.0/12, 范围: 172.16.0.0~172.31.255.255</li><li>C类私有地址: 182.168.0.0/16, 范围: 192.168.0.0~192.168.255.255</li></ul></li></ul></li><li><strong>IP地址分类</strong><ul><li><em>A类地址</em>: 0开头，8位网络号</li><li><em>B类地址</em>: 10开头，16位网络号</li><li><em>C类地址</em>: 110开头，24位网络号</li><li><em>D类地址</em>: 1110开头，用于多播</li><li><em>E类地址</em>: 1111开头</li></ul></li></ul><h2 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h2><hr><ul><li><strong>原理</strong>: 从二级IP地址到三级IP地址<ul><li>二级IP地址: &lt;网络号&gt;&lt;主机号&gt;，默认子网掩码为网络号的长度</li><li>三级IP地址: &lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;，默认子网掩码为网络号+子网号的长度</li></ul></li></ul><h2 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h2><hr><ul><li><strong>原理</strong>: 变长子网掩码，无分类编址CIDR</li><li><strong>IP地址</strong>: &lt;网络前缀&gt;&lt;主机号&gt;</li><li><strong>特点</strong>: </li></ul><h2 id="TCP、UDP"><a href="#TCP、UDP" class="headerlink" title="TCP、UDP"></a>TCP、UDP</h2><hr><p><a href="https://segmentfault.com/a/1190000004138638" target="_blank" rel="noopener">【参考】</a><br><img src="https://segmentfault.com/image?src=http://7xj8xg.com1.z0.glb.clouddn.com/TCP%EF%BC%8CUDP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.gif&amp;objectId=1190000004138638&amp;token=90d2ba2f129588bcae0a08299e765232" alt="">  </p><ul><li><strong>报文格式</strong>  <ul><li>共有字段: <ul><li>源端口和目的端口号</li><li>数据长度</li><li>校验和</li><li>数据域</li></ul></li><li>TCP特有字段<ul><li>序列号和确认号</li><li>接收窗口</li><li>TCP首部</li><li>标识字段</li></ul></li></ul></li><li><strong>区别</strong><ul><li><em>TCP</em><ul><li>面向连接的协议，提供可靠的数据传输</li><li>当数据接收方收到数据发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在收到确认消息之后才会继续发送其他信息；</li><li>报文最大长度允许超过512字节</li></ul></li><li><em>UDP</em><ul><li>用户数据报协议，一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务</li><li>报文最大长度为512字节</li></ul></li></ul></li></ul><h2 id="TCP对应的协议和UDP对应的协议"><a href="#TCP对应的协议和UDP对应的协议" class="headerlink" title="TCP对应的协议和UDP对应的协议"></a>TCP对应的协议和UDP对应的协议</h2><hr><ul><li><strong>TCP</strong><ul><li>FTP: 定义了文件传输协议，使用21端口</li><li>Telnet: 一种用于远程登录的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DO S模式下的通信服务，使用23端口</li><li>SMTP: 定义了简单邮件传送协议，使用25端口</li><li>POP3: 和SMTP对应，POP3用于接收邮件，使用110端口</li><li>HTTP: 从web服务器传输超文本到本地浏览器的传送协议</li></ul></li><li><strong>UDP</strong><ul><li>DNS: 用于域名解析服务，将域名地址转换为IP地址，使用53端口</li><li>SNMP: 简单网络管理协议，用来管理网络设备，使用161端口</li><li>TFTP: 简单文件传输协议，使用69端口</li></ul></li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><hr><ul><li><strong>套接字</strong><ul><li>是支持TCP/IP协议的网络通信的基本操作单元，是网络通信过程中端点的抽象表示，包含进行</li><li>套接字 = 连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口</li></ul></li></ul><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><hr><ul><li><strong>特性</strong><ul><li>入服务器端推: 允许服务器端在客户端需要数据之前就主动地将数据发送到客户端缓存  </li><li>提供更多加密技术  </li><li>使用多路技术，允许多个消息在一个连接上同时交叉</li><li>增加了头压缩，即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络体系结构&quot;&gt;&lt;a href=&quot;#网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;网络体系结构&quot;&gt;&lt;/a&gt;网络体系结构&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OSI五层模型&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;em&gt;应用层&lt;/e
      
    
    </summary>
    
      <category term="面试" scheme="http://chuquan.me/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="计算机网络" scheme="http://chuquan.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
